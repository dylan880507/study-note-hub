{"./":{"url":"./","title":"Introduction","keywords":"","body":"学习笔记 包含backend(net core, python), webend及os教程。 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-27 15:50:04 "},"NetCore/ABP.html":{"url":"NetCore/ABP.html","title":"ABP","keywords":"","body":"1>相关文章 1-1>ABP官网 https://abp.io https://github.com/abpframework/abp Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-03-31 14:12:12 "},"NetCore/AOP.html":{"url":"NetCore/AOP.html","title":"AOP","keywords":"","body":"1>相关文章 1-1>Norns.Urd (基于emit实现动态代理的轻量级AOP框架) https://github.com/fs7744/Norns.Urd https://github.com/fs7744/Norns.Urd/blob/main/docs/zh-cn/index.md Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/c_sharp.html":{"url":"NetCore/c_sharp.html","title":"c_sharp","keywords":"","body":"1>相关文章 C#中Struct与Class的区别 SQL Server 2012使用Offset/Fetch Next实现分页 2>Tuple(元组) //Tuple元组: C# 4.0的新特性, 只读 //是一种数据结构，引用类型，具有特定数量和元素序列 //最多有八个元素，要想更多只能通过最后一个元素进行嵌套扩展，（使用值元组的嵌套和Rest属性实现） //访问元素通过ItemX去访问，使用前需要明确元素顺序，属性名字没有实际意义 private System.Tuple TestFunc6() { System.Tuple tuple = new System.Tuple(\"key\", 1); Debug.Log(tuple.Item1 + tuple.Item2); return tuple; } 3>ValueTuple(值元组) //ValueTuple值元组: C# 7.0的新特性 //也是一种数据结构，是值类型，用于表示特定数量和元素序列 //值元组元素是可变的，不是只读的，值元组的数据成员是字段不是属性 private System.ValueTuple TestFunc7() { System.ValueTuple valueTuple = new System.ValueTuple(\"key\", 1); Debug.Log(valueTuple.Item1 + valueTuple.Item2); return valueTuple; } //ValueTuple值元组，返回值可以不明显指定ValueTuple，如(string, int) private (string, int) TestFunc8() { return (\"key\", 1); } //ValueTuple值元组，返回值可以指定元素名字，方便赋值和访问 private (string key, int value) TestFunc9() { return (key: \"key\", value: 1); } 4>switch类型模式 public string GetDataFormat(IFormatCreater entity, Data data) => entity switch { CSVFormatCreater csvFormatCreater => csvFormatCreater.ToCSV(data), JsonFormatCreater jsonFormatCreater => jsonFormatCreater.ToJson(data), XMLFormatCreater xmlFormatCreater => xmlFormatCreater.ToXML(data), YamlFormatCreater yamlFormatCreater => yamlFormatCreater.ToYAML(data), _ => \"this format is not adapted\" }; 5>sealed关键字 *当对一个类应用 sealed 修饰符时，此修饰符会阻止其他类从该类继承。类似于Java中final关键字。 class A {} sealed class B : A {} *能够允许类从基类继承，并防止它们重写特定的虚方法或虚属性。 public class D { /* ConsoleApplication1.MSFun.Sealed.D.M()' * cannot be sealed because it is not an override */ public sealed void M() { Console.WriteLine(\"D.M()\"); } } public class A { protected virtual void M() { Console.WriteLine(\"A.M()\"); } protected virtual void M1() { Console.WriteLine(\"A.M1()\"); } } public class B : A { protected sealed override void M() { Console.WriteLine(\"B.M()\"); } protected override void M1() { Console.WriteLine(\"B.M1()\"); } } public sealed class C : B { /* ConsoleApplication1.MSFun.Sealed.C.M()': * cannot override inherited member 'ConsoleApplication1.MSFun.Sealed.B.M()' * because it is sealed */ //protected override void M() { Console.WriteLine(\"C.M()\"); } protected override void M1() { Console.WriteLine(\"C.M1()\"); } } Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/EF_Core.html":{"url":"NetCore/EF_Core.html","title":"EF_Core","keywords":"","body":" 从数据库对象的粒度上可粗略的分为server、database、schema、table、colmun。这里server相当于instance（实例），一台机器可以装多个实例，一个实例有多个数据库，一个数据库有多个schema(模式），schema相当于把相似的表做个归类。 --查询当前库中的架构 SELECT * FROM sys.schemas AS s --若schema不存在, 则创建schema IF SCHEMA_ID('xxx') IS NULL EXEC sp_executesql N'CREATE SCHEMA xxx' 1>相关文章 1-1>EF Core *EF Core 相关的千倍性能之差： AutoMapper ProjectTo VS Mapster ProjectToType https://www.cnblogs.com/dudu/p/10449485.html *好大一个坑： EF Core 异步读取大字符串字段比同步慢100多倍 https://www.cnblogs.com/dudu/p/10423126.html *EF Core官网教程 https://docs.microsoft.com/zh-cn/ef/core/ *Entity Framework Core 3.1 极简入门教程（完结） https://www.bilibili.com/video/BV1xa4y1v7rR *ASP.NET MVC+EF实现如何驾驭超复杂业务逻辑而不失漂亮的代码 https://www.bilibili.com/video/BV12v411b7yF *EF Core中如何使用LEFT JOIN https://www.cnblogs.com/OpenCoder/p/12324249.html *EF Core 3.1 系列 asp.net core 系列 19 EFCore介绍 asp.net core 系列 20 EF基于数据模型创建数据库 asp.net core 系列 21 EF现有数据库进行反向工程 asp.net core 系列 22 EF(连接字符串,连接复原,DbContext) asp.net core系列 23 EF模型配置(概述, 类型和属性的包含与排除) asp.net core系列 24 EF模型配置(主键,生成值,最大长度,并发标记) asp.net core系列 25 EF模型配置(隐藏属性) asp.net core系列 26 EF模型配置(实体关系) asp.net core系列 27 EF模型配置(索引,备用键,继承) asp.net core系列 28 EF模型配置(字段,构造函数，拥有实体类型) asp.net core系列 29 EF模型配置(查询类型,关系数据库建模) asp.net core系列 30 EF管理数据库架构--必备知识 迁移 asp.net core系列 31 EF管理数据库架构--必备知识 反向工程 asp.net core系列 32 EF查询数据 必备知识(1) asp.net core系列 33 EF查询数据 (2) asp.net core系列 34 EF保存数据(1) asp.net core系列 35 EF保存数据(2) -- EF系列结束 *NetCore3.1webApi + EFCore + DI 框架封装 https://www.cnblogs.com/ouyangkai/p/12850893.html *利用EFCore 封装Repository（可扩展不同数据的sql操作） https://www.cnblogs.com/lxshwyan/p/10794412.html *IOC+EF+Core项目搭建EF封装(1~3) https://www.cnblogs.com/shuaimeng/p/11338620.html https://www.cnblogs.com/shuaimeng/p/11338760.html https://www.cnblogs.com/shuaimeng/p/11338802.html EF Core日志记录生成的sql语句 *并发令牌讲解(ChangeTracker, Timestamp, rowversion) https://www.cnblogs.com/rajesh/p/11093193.html *EF Core乐观并发控制：RowVersion https://haokan.baidu.com/v?pd=wisenatural&vid=16607248529233004348 *EF Core系列 https://www.cnblogs.com/yaopengfei/p/10666076.html *EFCore 复杂SQL查询踩坑记录 https://blog.csdn.net/weixin_38138153/article/details/115282786 *对于经常接触的分页你确定你真的会吗 https://www.cnblogs.com/xuejiaming/p/14187680.html *Wei.Repository EFCore3.0+Dapper 封装Repository https://github.com/a34546/Wei.Repository 1-2>MySQL *MySQL系列 mysql 基础篇系列(23) mysql 进阶篇系列(55) mysql 架构篇系列(3) Docker 搭建 MySQL8.0 主从复制环境 1-3>Fluent API *FluentAPI详细用法 https://www.cnblogs.com/wangshaod/p/10025836.html *官网 https://www.learnentityframeworkcore.com/configuration/fluent-api 1-4>Mapster 官方文档 https://github.com/MapsterMapper/Mapster/wiki [非专业翻译] 高性能对象映射框架 - Mapster https://www.cnblogs.com/staneee/p/14912794.html Mapster (C# 对象映射器) https://www.cnblogs.com/fanfan-90/p/12164927.html 说说 abp vnext 与 Mapster https://www.cnblogs.com/jidanfan/p/14506944.html 1-5>AutoMapper automapper https://www.cnblogs.com/keatkeat/p/10041574.html 1-6>UnitofWork 1-7>Dapper *用了Dapper之后通篇还是SqlConnection，真的看不下去了 https://blog.csdn.net/huangxinchen520/article/details/107812338 *DotNet Core中使用dapper https://www.cnblogs.com/taotaozhuanyong/p/11757738.html *Net Core中使用Dapper封装数据操作库 https://blog.csdn.net/qazlj/article/details/87283155 *NetCore Dapper封装 https://www.cnblogs.com/xtxk110/p/14901387.html *C#的dapper使用 https://www.cnblogs.com/flywong/p/9666963.html *.net core 中简单封装Dapper.Extensions https://www.cnblogs.com/nontracey/p/9988759.html *.Net Core中使用Dapper构建泛型仓储 https://www.cnblogs.com/zhangnever/p/11926045.html *.NET Core实战项目之CMS 第十二章 开发篇-Dapper封装GURD及仓储代码生成器实现 https://blog.csdn.net/qq_36178899/article/details/85111256 *.NetCore中使用Dapper https://blog.51cto.com/u_15127634/3273203 *Dapper 官网 https://github.com/DapperLib/Dapper 2>DbContext 安装包: Microsoft.EntityFrameworkCore.SqlServer 2-1>DbContext 生存期 *DbContext的生存期从创建实例时开始，并在释放实例时结束。 *使用后释放DbContext非常重要 *DbContext 不是线程安全的. 2-2>依赖注入DbContext public void ConfigureServices(IServiceCollection services) { services.AddControllers(); services.AddDbContext ( options => options.UseSqlServer(\"name=ConnectionStrings:DefaultConnection\") ); } public class ApplicationDbContext : DbContext { public ApplicationDbContext(DbContextOptions options) : base(options) { } //或者在这里配置连接字符串 protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(_connectionString); } } public class MyController { private readonly ApplicationDbContext _context; public MyController(ApplicationDbContext context) { _context = context; } } 2-3>使用new实例化DbContext public class ApplicationDbContext : DbContext { private readonly string _connectionString; public ApplicationDbContext(string connectionString) { _connectionString = connectionString; } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(_connectionString); } } //或 public class ApplicationDbContext : DbContext { public ApplicationDbContext(DbContextOptions options) : base(options) { } } var contextOptions = new DbContextOptionsBuilder() .UseSqlServer(@\"Server=(localdb)\\mssqllocaldb;Database=Test\") .Options; using var context = new ApplicationDbContext(contextOptions) { //TODO... } 2-4>使用DbContext工厂 public void ConfigureServices(IServiceCollection services) { services.AddDbContextFactory( options => options.UseSqlServer(@\"Server=(localdb)\\mssqllocaldb;Database=Test\")); } public class ApplicationDbContext : DbContext { public ApplicationDbContext(DbContextOptions options) : base(options) { } } private readonly IDbContextFactory _contextFactory; public MyController(IDbContextFactory contextFactory) { _contextFactory = contextFactory; } public void DoSomething() { using (var context = _contextFactory.CreateDbContext()) { //TODO... } } 2-5>DbContextOptions 三种方式获取此生成器: 在 AddDbContext 和相关方法中 在 OnConfiguring 中 使用 new 显式构造 3-1>UseQueryTrackingBehavior(设置查询的默认跟踪行为) *跟踪查询 TrackAll: 已追踪的实例会被标识解析, 如果是相同的实体, 则每次返回相同实例. *非跟踪查询 NoTracking: 不会标识解析, 即使是相同的实体, 也会返回新实例. var blogs = context.Blogs .AsNoTrackingWithIdentityResolution() .ToList(); *标识解析 NoTrackingWithIdentityResolution:后台使用独立的更改追踪器, 每个实例具体化一次, 建议使用AsNoTrackingWithIdentityResolution代替AsNoTracking, 性能优化. *自定义投影: 如果设置了跟踪查询, 那么查询返回的结果只要包含了实体类行, 就会跟踪这个实体类型, 非实体类型不跟踪. 2-6>避免 DbContext 线程处理问题 不支持在同一 DbContext 实例上运行多个并行操作. 3>实体配置 3-1>在DbContext.OnModelCreating内配置实体 3-2>通过特性配置 *排除表映射: [NotMapped] *表名称: [Table(\"blogs\")] *表架构: [Table(\"blogs\", Schema = \"blogging\")] *表注释: [Comment(\"Blogs managed on the website\")] *排除属性映射: [NotMapped] *列名: [Column(\"blog_id\")], 实体属性会自动映射到与属性同名的列. *列数据类型: [Column(TypeName = \"varchar(200)\")] *最大长度: [MaxLength(500)] *必填: [Required] *列注释: [Comment(\"The URL of the blog\")] *主键: [Key], 将Id或[class name]Id的属性自动映射为主键, 联合主键只能通过Fluent API来设置. *指定值生成的时机: [DatabaseGenerated(DatabaseGeneratedOption.Identity)], [DatabaseGenerated(DatabaseGeneratedOption.Computed)], [DatabaseGenerated(DatabaseGeneratedOption.None)] *并发标记: 下面两种方式采用乐观锁机制, 在性能和死锁情况上都优于悲观锁. ConcurrencyCheck: 对某个字段进行并发检测. Timestamp: 对所有列进行并发检测 [Timestamp] public byte[] Timestamp { get; set; } *索引 [Index(nameof(Url))] public class Blog { //TODO... } *复合索引: [Index(nameof(FirstName), nameof(LastName))] *唯一索引: [Index(nameof(Url), IsUnique = true)] *指定索引名称: [Index(nameof(Url), Name = \"Index_Url\")] *支持字段: public class Blog { private string _validatedUrl; public int BlogId { get; set; } [BackingField(nameof(_validatedUrl))] public string Url { get { return _validatedUrl; } } public void SetUrl(string url) { // put your validation code here _validatedUrl = url; } } *无键实体类型: [Keyless] public class BlogPostsCount { public string BlogName { get; set; } public int PostCount { get; set; } } 3-3>通过Fluent API配置 *从模型中排除类型: modelBuilder.Ignore(); *从迁移中排除: modelBuilder .Entity() .ToTable(\"AspNetUsers\", t => t.ExcludeFromMigrations()); *表名称: modelBuilder .Entity() .ToTable(\"blogs\"); *表架构: modelBuilder .Entity() .ToTable(\"blogs\", schema: \"blogging\"); *也可以设置上限文的默认架构 modelBuilder.HasDefaultSchema(\"blogging\"); *视图映射: 视图不会在 add-migration 自动创建, 需要手动创建 modelBuilder .Entity() .ToView(\"blogsView\", schema: \"blogging\"); *表值函数映射: 若要将实体映射到表值函数, 该函数必须是无参数的. CREATE FUNCTION dbo.BlogsWithMultiplePosts() RETURNS TABLE AS RETURN ( SELECT b.Url, COUNT(p.BlogId) AS PostCount FROM Blogs AS b JOIN Posts AS p ON b.BlogId = p.BlogId GROUP BY b.BlogId, b.Url HAVING COUNT(p.BlogId) > 1 ) modelBuilder.Entity().HasNoKey().ToFunction(\"BlogsWithMultiplePosts\"); var query = from b in context.Set() where b.PostCount > 3 select new { b.Url, b.PostCount }; *表注释: modelBuilder .Entity() .HasComment(\"Blogs managed on the website\"); *排除属性映射: modelBuilder.Entity() .Ignore(b => b.LoadedFromDatabase); *列名: modelBuilder.Entity() .Property(b => b.BlogId) .HasColumnName(\"blog_id\"); *列数据类型: modelBuilder.Entity( eb => { eb.Property(b => b.Url).HasColumnType(\"varchar(200)\"); eb.Property(b => b.Rating).HasColumnType(\"decimal(5, 2)\"); }); *最大长度: modelBuilder.Entity() .Property(b => b.Url) .HasMaxLength(500); *精度和小数位数: 一般是decimal和DateTime. modelBuilder.Entity() .Property(b => b.Score) .HasPrecision(14, 2); modelBuilder.Entity() .Property(b => b.LastUpdated) .HasPrecision(3); *必填: modelBuilder.Entity() .Property(b => b.Url) .IsRequired(); *列排序比较规则: (下面的例子表示列的值不区分大小写) modelBuilder.Entity() .Property(c => c.Name) .UseCollation(\"SQL_Latin1_General_CP1_CI_AS\"); *列注释: modelBuilder.Entity() .Property(b => b.Url) .HasComment(\"The URL of the blog\"); *主键: 可以设置单个主键及联合主键, 可以自定义主键的名称, modelBuilder.Entity() .HasKey(c => c.LicensePlate); modelBuilder.Entity() .HasKey(c => new { c.State, c.LicensePlate }); modelBuilder.Entity() .HasKey(b => b.BlogId) .HasName(\"PrimaryKey_BlogId\"); *默认值(如果插入的行没有该列的值，将使用默认值): modelBuilder.Entity() .Property(b => b.Rating) .HasDefaultValue(3); modelBuilder.Entity() .Property(b => b.Created) .HasDefaultValueSql(\"getdate()\"); *计算列(通常具有引用其他列的表达式): modelBuilder.Entity() .Property(p => p.DisplayName) .HasComputedColumnSql(\"[LastName] + ', ' + [FirstName]\"); 可以使用stored来持久化计算列的值, 即将计算后的结果存到列. modelBuilder.Entity() .Property(p => p.DisplayName) .HasComputedColumnSql(\"[LastName] + ', ' + [FirstName]\", stored: true); *指定值生成的时机: modelBuilder.Entity() .Property(b => b.Inserted) .ValueGeneratedOnAdd(); modelBuilder.Entity() .Property(b => b.LastUpdated) .ValueGeneratedOnAddOrUpdate(); modelBuilder.Entity() .Property(b => b.BlogId) .ValueGeneratedNever(); *日期/时间值生成: AddTime可以使用默认值的方式 modelBuilder.Entity() .Property(b => b.Created) .HasDefaultValueSql(\"getdate()\"); UpdateTime需要自行实现(如下面例子的触发器): CREATE TRIGGER [dbo].[Blogs_UPDATE] ON [dbo].[Blogs] AFTER UPDATE AS BEGIN SET NOCOUNT ON; IF ((SELECT TRIGGER_NESTLEVEL()) > 1) RETURN; DECLARE @Id INT SELECT @Id = INSERTED.BlogId FROM INSERTED UPDATE dbo.Blogs SET LastUpdated = GETDATE() WHERE BlogId = @Id END *并发标记: //指定某个字段为并发字段 modelBuilder.Entity() .Property(p => p.LastName) .IsConcurrencyToken(); //指定整个实体的并发字段, 实体任何字段有更改, 并发字段的值都会自动改变 modelBuilder.Entity() .Property(p => p.Timestamp) .IsRowVersion(); *配置1对N: 导航属性可以最终只保留 public List Posts { get; set; }, 这个属性足以说明Blog与Post的1对多关系. public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public int BlogId { get; set; } public Blog Blog { get; set; } } HasOne/WithOne用于引用导航属性, HasMany/WithMany用于集合导航属性, 配置的套路: 把关系配置在多的一端. 下面是1对N的例子: public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public Blog Blog { get; set; } } modelBuilder.Entity() .HasOne(p => p.Blog) .WithMany(b => b.Posts); 或者 public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List Posts { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } } modelBuilder.Entity() .HasMany(b => b.Posts) .WithOne(); *配置导航属性: 对已经配置好的导航属性, 用Navigation进行细节配置. modelBuilder.Entity() .HasMany(b => b.Posts) .WithOne(); modelBuilder.Entity() .Navigation(b => b.Posts) .UsePropertyAccessMode(PropertyAccessMode.Property); *指定外键: //单个外键 modelBuilder.Entity() .HasOne(p => p.Blog) .WithMany(b => b.Posts) .HasForeignKey(p => p.BlogForeignKey); //联合外键 modelBuilder.Entity() .HasOne(s => s.Car) .WithMany(c => c.SaleHistory) .HasForeignKey(s => new { s.CarState, s.CarLicensePlate }); *指定外键名称: modelBuilder.Entity() .HasOne(p => p.Blog) .WithMany(b => b.Posts) .HasForeignKey(p => p.BlogId) .HasConstraintName(\"ForeignKey_Post_Blog\"); *没有导航属性, 设置1对多关系(一般也没人会这么干吧-_-||): public class Blog { public int BlogId { get; set; } public string Url { get; set; } } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public int BlogId { get; set; } } modelBuilder.Entity() .HasOne() .WithMany() .HasForeignKey(p => p.BlogId); *指定外键是否必填: modelBuilder.Entity() .HasOne(p => p.Blog) .WithMany(b => b.Posts) .IsRequired(); *级联删除: modelBuilder.Entity() .HasOne(p => p.Blog) .WithMany(b => b.Posts) .OnDelete(DeleteBehavior.Cascade); *配置1对1: 在一对多关系中，具有引用导航的实体是依赖实体，具有集合导航的实体是主体. 在1对1的关系中, 需要显示指定主从关系. public class Blog { public int BlogId { get; set; } public string Url { get; set; } public BlogImage BlogImage { get; set; } } public class BlogImage { public int BlogImageId { get; set; } public byte[] Image { get; set; } public string Caption { get; set; } public int BlogForeignKey { get; set; } public Blog Blog { get; set; } } modelBuilder.Entity() .HasOne(b => b.BlogImage) .WithOne(i => i.Blog) .HasForeignKey(b => b.BlogForeignKey); *配置N对N: 多对多关系需要两侧的集合导航属性. public class User { public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } public bool Gender { get; set; } } public class Role { public int Id { get; set; } public string RoleName { get; set; } } public class UserRoleRelation { public int Id { get; set; } public int UserId { get; set; } public int RoleId { get; set; } public virtual User User { get; set; } public virtual Role Role { get; set; } } modelBuilder .Entity(). .ToTable(\"UserRoleRelation\") .HasKey(r => r.Id) .Property(r => r.UserId).IsRequired() .Property(r => r.RoleId).IsRequired() .HasOne(r => r.User).WithMany().HasForeignKey(r => r.UserId).IsRequired().OnDelete(DeleteBehavior.ClientCascade)) .HasOne(r => r.Role).WithMany().HasForeignKey(r => r.RoleId).IsRequired().OnDelete(DeleteBehavior.ClientCascade)); *索引: modelBuilder.Entity() .HasIndex(b => b.Url); *复合索引: modelBuilder.Entity() .HasIndex(p => new { p.FirstName, p.LastName }); *唯一索引: modelBuilder.Entity() .HasIndex(b => b.Url) .IsUnique(); *指定索引名称: modelBuilder.Entity() .HasIndex(b => b.Url) .HasDatabaseName(\"Index_Url\"); *条件约束: modelBuilder.Entity() .HasCheckConstraint(\"CK_Prices\", \"[Price] > [DiscountedPrice]\", c => c.HasName(\"CK_Product_Prices\")); *继承: 没用到, 需要了解可参考:https://docs.microsoft.com/zh-cn/ef/core/modeling/inheritance *序列: 没用到, 需要了解可参考:https://docs.microsoft.com/zh-cn/ef/core/modeling/sequences *支持字段: modelBuilder.Entity() .Property(b => b.Url) .HasField(\"_validatedUrl\"); *值转换 Expression> convertToProviderExpression Expression> convertFromProviderExpression 一个是写库时要把实体属性类型转为表字段类型, 一个是读库时, 把表字段类型回转为实体模型中属性的类型. var converter = new ValueConverter, string> ( v => JsonHelper.ToJson(v), v => JsonHelper.ToObject>(v) ); modelBuilder .Entity() .Property(e => e.TestName) .HasConversion(converter); *内置的转换器: https://docs.microsoft.com/zh-cn/ef/core/modeling/value-conversions?tabs=fluent-api *值比较器: https://docs.microsoft.com/zh-cn/ef/core/modeling/value-comparers?tabs=ef5 *种子数据: https://docs.microsoft.com/zh-cn/ef/core/modeling/data-seeding *实体类型构造函数: 可以注入容器的所有服务 *表拆分(表共享): 多个实体共同映射同一张表的不同字段, 组成一张总的表. 将主键映射到相同的列, 并且在同一个实体类型的主键与另一个实体类型的主键之间配置至少一个关系. public class Order { public int Id { get; set; } public OrderStatus? Status { get; set; } public DetailedOrder DetailedOrder { get; set; } } public class DetailedOrder { public int Id { get; set; } public OrderStatus? Status { get; set; } public string BillingAddress { get; set; } public string ShippingAddress { get; set; } public byte[] Version { get; set; } } modelBuilder.Entity( dob => { dob.ToTable(\"Orders\"); dob.Property(o => o.Status).HasColumnName(\"Status\"); }); modelBuilder.Entity( ob => { ob.ToTable(\"Orders\"); ob.Property(o => o.Status).HasColumnName(\"Status\"); ob.HasOne(o => o.DetailedOrder).WithOne().HasForeignKey(o => o.Id); }); *从属属性: https://docs.microsoft.com/zh-cn/ef/core/modeling/owned-entities *无键实体类型: modelBuilder.Entity() .HasNoKey(); *在具有相同 DbContext 类型的多个模型之间交替: https://www.jianshu.com/p/d401c0bb3046 *空间数据: https://docs.microsoft.com/zh-cn/ef/core/modeling/spatial *指定基类型: HasBaseType. modelBuilder.Entity().HasBaseType(); *隐藏属性: 也叫影子属性，该属性不是在.net实体类中定义的属性，而是在EFCore模型中为该实体类型定义的属性。这些属性的值和状态完全在变更跟踪器中维护。 //配置隐藏属性, 只能通过 Fluent API 来创建 public class Blog { public int BlogId { get; set; } public string Url { get; set; } } modelBuilder.Entity().Property(\"LastUpdated\"); //设置隐藏属性值, 通过ChangeTracker API可以为隐藏属性LastUpdated设置时间值, 提交到数据库表中。 BloggingContext.Entry(blog).Property(\"LastUpdated\").CurrentValue = DateTime.Now; BloggingContext.Add(blog); await BloggingContext.SaveChangesAsync(); //读取blog表数据 var blogs = context.Blogs.OrderBy(b => EF.Property(b, \"LastUpdated\")); 4>管理数据库架构 4-1>Code first使用Migration, DB First使用方向工程. 4-2>使用命令的注意事项 *默认启动项目需要能生成exe, 在dbcontext的项目及exe项目安装nuget包 Microsoft.EntityFrameworkCore.Tools *之前命令前, 记得在Startup.ConfigureServices配置上下文: services.AddDbContext(); 4-3>指令列表 Add-Migration Adds a new migration. Script-Migration Generates a SQL script from migrations. Update-Database Updates the database to a specified migration. Remove-Migration Removes the last migration. Drop-Database Drops the database. Get-DbContext Lists and gets information about available DbContext types. Get-Migration Lists available migrations. Scaffold-DbContext Scaffolds a DbContext and entity types for a database. Script-DbContext Generates a SQL script from the DbContext. Bypasses any migrations. 4-4>管理迁移文件 //生成迁移文件 Add-Migration InitCALCDb Add-Migration InitCALCDb -OutputDir DbMigration Add-Migration InitCALCDb -Context CALCDbContext -OutputDir DbMigration //删除迁移(若迁移文件已用于执行update-database, 则无法使用Remove-Migration, 只能从最新的迁移文件一个一个往回删除) Remove-Migration Remove-Migration -Context CALCDbContext //删除最新生成的迁移文件 //生成数据库脚本 Script-Migration Script-Migration -Context CALCDbContext Script-Migration -Context CALCDbContext -Output CALCDbScript.sql //脚本生成到启动项目根目录下 Script-Migration -Context CALCDbContext -Output F:\\100_StudyPro\\NetCoreDemos\\Dylan.Repository\\DbMigrationScript\\CALCDbScript.sql //脚本生成到指定物理路径下 Script-Migration UpdateCALCDb1 AddIsDeleteInAuthor -Context CalcDbContext //生成UpdateCALCDb1版本到AddIsDeleteInAuthor版本之间的SQL //更新数据库结构 Update-Database //升级到最新版本 Update-Database -Context CALCDbContext //升级到最新版本 update-database AddIsDeleteInAuthor -Context CALCDbContext //降级/升级到指定版本 Update-Database -Context CALCDbContext -Migration:0 //删除数据库中所有表(除了迁移历史表) 4-5>迁移文件注意事项 *系统自动生成的迁移文件不一定都是对的，有时候需要手动修改Add-Migration生成的文件, 比如修改字段名. 若系统已经存在列A, 若对实体做了重命名操作, 自动生成的脚本会执行drop column & add column操作, 这样的操作会导致列的值丢失, 因此需要手动干预. migrationBuilder.DropColumn( name: \"Name\", table: \"Customers\"); migrationBuilder.AddColumn( name: \"FullName\", table: \"Customers\", nullable: true); //应该改成如下操作 migrationBuilder.RenameColumn( name: \"Name\", table: \"Customers\", newName: \"FullName\"); *往生成的迁移文件里添加原始sql语句 migrationBuilder.AddColumn( name: \"FullName\", table: \"Customer\", nullable: true); migrationBuilder.Sql( @\" UPDATE Customer SET FullName = FirstName + ' ' + LastName; \"); migrationBuilder.DropColumn( name: \"FirstName\", table: \"Customer\"); migrationBuilder.DropColumn( name: \"LastName\", table: \"Customer\"); 4-6>迁移文件动态编程 https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/migrations/operations 4-7>动态指定上下文 public static IHostBuilder CreateHostBuilder(string[] args) => Host.CreateDefaultBuilder(args) .ConfigureServices( (hostContext, services) => { services.AddHostedService(); // Set the active provider via configuration var configuration = hostContext.Configuration; var provider = configuration.GetValue(\"Provider\", \"SqlServer\"); services.AddDbContext( options => _ = provider switch { \"Sqlite\" => options.UseSqlite( configuration.GetConnectionString(\"SqliteConnection\"), x => x.MigrationsAssembly(\"SqliteMigrations\")), \"SqlServer\" => options.UseSqlServer( configuration.GetConnectionString(\"SqlServerConnection\"), x => x.MigrationsAssembly(\"SqlServerMigrations\")), _ => throw new Exception($\"Unsupported provider: {provider}\") }); }); Add-Migration MyMigration -Args \"--provider SqlServer\" Add-Migration MyMigration -Args \"--provider Sqlite\" 4-8>自定义迁移历史记录表 https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/migrations/history-table optionsBuilder.UseSqlServer(connectionString: connStr, sqlServerOptionsAction => { sqlServerOptionsAction.EnableRetryOnFailure(3, TimeSpan.FromMilliseconds(100), null); //设置重连 if (!string.IsNullOrEmpty(Schema)) { sqlServerOptionsAction.MigrationsHistoryTable(tableName: \"__T_DBMigrationsHistory\", schema: Schema); } }); 5>并发 先来了解下帮助解决并发冲突的三组值： Current values 当前值： 应用程序尝试写入数据库的值 Original values 原始值： 被 EF Core 从数据库检索出来的值，位于任何更新操作之前的值 Database values 数据库值： 当前数据库实际存储的值 当SaveChanges时, 如果捕获了DbUpdateConcurrencyException, 说明发生了并发冲突, 使用DbUpdateConcurrencyException.Entries为受影响的实体准备一组新值, 重新获取数据库中的值的并发令牌来刷新Original values, 然后重试直到没有任何冲突产生. [HttpPut] public async Task Update([FromBody]Person current) { Person original = null; try { original = await _db.People.FindAsync(current.Id); original.FirstName = current.FirstName; original.LastName = current.LastName; await _db.SaveChangesAsync(); } catch (DbUpdateConcurrencyException e) { foreach (var entry in e.Entries) { var currentValues = entry.CurrentValues; var databaseValues = await entry.GetDatabaseValuesAsync(); if (entry.Entity is Person person) { // 更新什么值取决于实际需要 person.FirstName = currentValues[nameof(Person.FirstName)]?.ToString(); person.LastName = currentValues[nameof(Person.LastName)]?.ToString(); // 这步操作是为了刷新当前 Tracker 的值， 为了通过下一次的并发检查 entry.OriginalValues.SetValues(databaseValues); } } await _db.SaveChangesAsync(); } return original; } //官方处理方式 using var context = new PersonContext(); // Fetch a person from database and change phone number var person = context.People.Single(p => p.PersonId == 1); person.PhoneNumber = \"555-555-5555\"; // Change the person's name in the database to simulate a concurrency conflict context.Database.ExecuteSqlRaw( \"UPDATE dbo.People SET FirstName = 'Jane' WHERE PersonId = 1\"); var saved = false; while (!saved) { try { // Attempt to save changes to the database context.SaveChanges(); saved = true; } catch (DbUpdateConcurrencyException ex) { foreach (var entry in ex.Entries) { if (entry.Entity is Person) { var proposedValues = entry.CurrentValues; var databaseValues = entry.GetDatabaseValues(); foreach (var property in proposedValues.Properties) { var proposedValue = proposedValues[property]; var databaseValue = databaseValues[property]; // TODO: decide which value should be written to database // proposedValues[property] = ; } // Refresh original values to bypass next concurrency check entry.OriginalValues.SetValues(databaseValues); } else { throw new NotSupportedException( \"Don't know how to handle concurrency conflicts for \" + entry.Metadata.Name); } } } } *通常的处理方式： *Reload一下，放弃当前内存中的实体，重新到数据库中加载当前实体，然后用当前数据库中的值进行相应的业务处理。 *直接提示用户，信息被修改，请重新操作一遍(可以更友好的提示一下) { //保证T_Concurrency02有一条id=01的记录（age=10） ypfContext db1 = new ypfContext(); ypfContext db2 = new ypfContext(); try { var data1 = db1.T_Concurrency02.Where(u => u.id == \"01\").FirstOrDefault(); var data2 = db2.T_Concurrency02.Where(u => u.id == \"01\").FirstOrDefault(); data1.age = data1.age - 2; int result1 = db1.SaveChanges(); data2.age = data2.age - 4; int result2 = db2.SaveChanges(); //发现age的值和原先查出来的不一致，会抛异常进入cache } catch (DbUpdateConcurrencyException ex) { var entityEntry = ex.Entries.Single(); var original = entityEntry.OriginalValues.ToObject() as T_Concurrency02; //数据库原始值 10 var database = entityEntry.GetDatabaseValues().ToObject() as T_Concurrency02; //数据库现在值 8 var current = entityEntry.CurrentValues.ToObject() as T_Concurrency02; //当前内存值 6 entityEntry.Reload(); //放弃当前内存中的实体，重新到数据库中加载当前实体 current.age = database.age - 4; //应该拿着当前数据库实际的值去处理，即8-4=4 entityEntry.CurrentValues.SetValues(current); int result3 = db2.SaveChanges(); } } try { var firstPeople1 = EFDbContext.Peoples.FirstOrDefault(); var peopleId = firstPeople1.Id; firstPeople1.Name = \"people1\"; await EFDbContext.SaveChangesAsync(cancellationToken); return Json(new { peopleId }); } catch (DbUpdateConcurrencyException ex) { try { //将源数据更新为db数据, 然后现有数据更新为最新数据 long id = default; foreach (var entry in ex.Entries) { var dbProValues = await entry.GetDatabaseValuesAsync(cancellationToken); var curProValues = entry.CurrentValues; id = long.Parse(curProValues[\"Id\"].ToString()); //若需要修改当前值, 可用下面的方法 var curPeople = curProValues.ToObject() as People; if (curPeople == default) { throw ex; } curPeople.Name = \"并发people\"; entry.CurrentValues.SetValues(curPeople); //将原始值用数据库值更新, 保证并发令牌为最新 entry.OriginalValues.SetValues(dbProValues); } await EFDbContext.SaveChangesAsync(cancellationToken); return Json(new { id }); } catch { throw ex; } } catch (Exception ex) { var errorMsg = ex.GetInnerExceptionMsg(); return Json(new { errorMsg }); } 6>反向工程 (不建议使用) https://www.cnblogs.com/MrHSR/p/10425437.html 对于已经存在的老项目, 需要升级到EF Core, 用Code first(EF Core只剩下Code First模式)作为ORM, 我的想法是手动创建好所有的类以DB Context, 然后在旧项目的库里手动创建迁移历史表, 往表里插入Init记录, 等以后有加新的表或者对旧库有新的更改，就可以继续使用Migration进行数据库维护. 7>查询 7-1>跟踪/非跟踪查询 跟踪查询: 从实体查询出来, 一直到执行SaveChanges(), 系统会监视实体的所有改变. 非跟踪查询: 查询出来的实体, 系统不进行跟踪查询, 可用于非保存的查询, 如列表查询. //跟踪查询 var resultList = await EFDbContext.Authors.AsTracking().Where(a => a.Name.Contains(\"_1\")).ToListAsync(); //非跟踪查询 var resultList = await EFDbContext.Authors.AsNoTracking().Where(a => a.Name.Contains(\"_1\")).ToListAsync(); //非跟踪查询(带标识解析, 性能更好) var resultList = await EFDbContext.Authors.AsNoTrackingWithIdentityResolution().Where(a => a.Name.Contains(\"_1\")).ToListAsync(); 7-2>导航属性的数据加载方式 7-2-1>预加载 //1>不预加载导航属性, 查询出来的导航属性值为空 var resultList = await EFDbContext.Authors .Take(3) .ToListAsync(); //2>预加载导航属性, 可以查询初导航属性的值 var resultList = await EFDbContext.Authors .Include(a => a.Blog) .Take(3) .ToListAsync(); //3>多级加载 /* SELECT [t0].[Id], [t0].[AddIP], [t0].[AddTime], [t0].[AddUserId], [t0].[Address], [t0].[BirthDate], [t0].[Code], [t0].[CompanyName], [t0].[Email], [t0].[Hometown], [t0].[LastUpdateIP], [t0].[LastUpdateTime], [t0].[LastUpdateUserId], [t0].[Name], [t0].[Tel], [t0].[Title], [t0].[Token], [t1].[Id], [t1].[AddIP], [t1].[AddTime], [t1].[AddUserId], [t1].[AuthorId], [t1].[LastUpdateIP], [t1].[LastUpdateTime], [t1].[LastUpdateUserId], [t1].[OpenDate], [t1].[Token], [t1].[Url], [t2].[Id], [t2].[AddIP], [t2].[AddTime], [t2].[AddUserId], [t2].[BlogId], [t2].[Content], [t2].[IsDelete], [t2].[LastUpdateIP], [t2].[LastUpdateTime], [t2].[LastUpdateUserId], [t2].[PostStatus], [t2].[ReleaseTime], [t2].[Title], [t2].[Token] FROM ( SELECT TOP(3) [t].[Id], [t].[AddIP], [t].[AddTime], [t].[AddUserId], [t].[Address], [t].[BirthDate], [t].[Code], [t].[CompanyName], [t].[Email], [t].[Hometown], [t].[LastUpdateIP], [t].[LastUpdateTime], [t].[LastUpdateUserId], [t].[Name], [t].[Tel], [t].[Title], [t].[Token] FROM [CALC].[T_Author] AS [t] ) AS [t0] LEFT JOIN [CALC].[T_Blog] AS [t1] ON [t0].[Id] = [t1].[AuthorId] LEFT JOIN [CALC].[T_Post] AS [t2] ON [t1].[Id] = [t2].[BlogId] ORDER BY [t0].[Id], [t1].[Id], [t2].[Id] */ var resultList = await EFDbContext.Authors .Include(a => a.Blog) .ThenInclude(b=>b.Posts) .Take(3) .ToListAsync(); //=>等同于下面的写法 resultList = await EFDbContext.Authors .Include(a => a.Blog.Posts) .Take(3) .ToListAsync(); //4>预加载的数据可以执行where, OrderBy, OrderByDescending, ThenBy, ThenByDescending, Skip 和 Take. var resultList = EFDbContext.Authors .Include(a => a.Blog.Posts.Where(p => p.PostStatus == EnumPostStatus.Draft).OrderByDescending(p => p.Content)) .Take(3); 7-2-2>显式加载(加载查询出来实体的属性导航) //1>显示加载导航属性 var resultList = EFDbContext.Authors.OrderByDescending(a => a.Name).ThenBy(a => a.Tel).Take(1).ToList(); if (resultList.Any()) { await EFDbContext.Entry(resultList[0]) .Reference(a => a.Blog) .LoadAsync(); await EFDbContext.Entry(resultList[0].Blog) .Collection(b => b.Posts) .LoadAsync(); } 7-3>拆分查询/合并查询 *EF默认使用拆分查询, 用户可以根据实际需求配置 protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder .UseSqlServer( @\"Server=(localdb)\\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True\", o => o.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery)); } //使用拆分查询 using (var context = new BloggingContext()) { var blogs = context.Blogs .Include(blog => blog.Posts) .AsSplitQuery() .ToList(); } //使用合并查询 using (var context = new SplitQueriesBloggingContext()) { var blogs = context.Blogs .Include(blog => blog.Posts) .AsSingleQuery() .ToList(); } 7-4>连接查询(cross join, inner join, left join) //1>笛卡尔积查询(cross join) /* SELECT [t].[Id] AS [AuthorId], [t].[Name], [t0].[Url], [t0].[OpenDate] FROM [CALC].[T_Author] AS [t] CROSS JOIN [CALC].[T_Blog] AS [t0] WHERE [t].[Id] = [t0].[AuthorId] ORDER BY [t].[Name], [t0].[Url] DESC */ var resultList = (from ab in (from author in EFDbContext.Authors from blog in EFDbContext.Blogs where author.Id == blog.AuthorId select new { AuthorId = author.Id, author.Name, blog.Url, blog.OpenDate })//.ToList(); orderby ab.Name, ab.Url descending select ab).ToList(); //2>内连接(inner join) /* SELECT [t].[Id] AS [AuthorId], [t].[Name], [t0].[Url], [t0].[OpenDate] FROM [CALC].[T_Author] AS [t] INNER JOIN [CALC].[T_Blog] AS [t0] ON [t].[Id] = [t0].[AuthorId] ORDER BY [t].[Name], [t0].[Url] DESC */ var resultList = await (from ab in (from author in EFDbContext.Authors join blog in EFDbContext.Blogs on author.Id equals blog.AuthorId select new { AuthorId = author.Id, author.Name, blog.Url, blog.OpenDate }) orderby ab.Name, ab.Url descending select ab).ToListAsync(); //3>先内连接(inner join), 再左外连接(left join) /* SELECT [t].[Id] AS [AuthorId], [t].[Name] AS [AuthorName], [t0].[Url] AS [BlogUrl], [t0].[OpenDate] AS [BlogOpenDate], [t1].[Title], [t1].[PostStatus], [t1].[ReleaseTime] FROM [CALC].[T_Author] AS [t] INNER JOIN [CALC].[T_Blog] AS [t0] ON [t].[Id] = [t0].[AuthorId] LEFT JOIN [CALC].[T_Post] AS [t1] ON [t0].[Id] = [t1].[BlogId] ORDER BY [t].[Name], [t1].[Title] DESC */ var resultList = await (from author in EFDbContext.Authors join blog in EFDbContext.Blogs on author.Id equals blog.AuthorId join post in EFDbContext.Posts on blog.Id equals post.BlogId into rPosts from rPost in rPosts.DefaultIfEmpty() orderby author.Name, rPost.Title descending select new { AuthorId = author.Id, AuthorName = author.Name, BlogUrl = blog.Url, BlogOpenDate = blog.OpenDate, Title = rPost.Title, PostStatus = rPost.PostStatus, ReleaseTime = rPost.ReleaseTime }).ToListAsync(); //4>on条件不止一个, 用匿名对象 var query = from photo in context.Set() join person in context.Set() on new { Id = (int?)photo.PersonPhotoId, photo.Caption } equals new { Id = person.PhotoId, Caption = \"SN\" } select new { person, photo }; //5>left join 另一种写法 var query2 = from b in context.Set() from p in context.Set().Where(p => b.BlogId == p.BlogId).DefaultIfEmpty() select new { b, p }; 7-5>分组查询(group by) //1>EF的Goup by后的结果只能使用聚合操作(Average, Count, LongCount, Max, Min, Sum), 无法查询分组的明细(报错), 可以使用AsEnumerable将数据加载到内存操作 var resultList = await (from author in EFDbContext.Authors group author by author.Code into g select new { GroupKey = g.Key, Count = g.Count() }).ToListAsync(); //2>加载到内存进行分组操作 var resultList = (from author in EFDbContext.Authors.AsEnumerable() group author by author.Code / 100 into g select new { GroupKey = g.Key, List = g.ToList() }).ToList(); 7-6>原生SQL查询(查询操作及非查询操作) *使用原生SQL查询时需注意以下几个限制: SQL 查询必须返回实体类型的所有属性的数据。 结果集中的列名必须与属性映射到的列名称匹配。 SQL 查询不能包含关联数据。 //执行普通查询, 使用占位符实现参数化查询 var queryParam1 = \"Name_8%\"; var schema = EFDbContext.Schema; var resultList = await EFDbContext.Authors.FromSqlRaw(@\"select top 10 T_Author.* from CALC.T_Author as T_Author inner join CALC.T_Blog as T_Blog on T_Author.Id = T_Blog.AuthorId where exists ( select T_Post.Id from CALC.T_Post as T_Post where T_Post.BlogId = T_Blog.Id and exists ( select T_PostCollects.Id from CALC.T_PostCollects as T_PostCollects where T_PostCollects.PostId = T_Post.Id ) and exists ( select T_PostComments.Id from CALC.T_PostComments as T_PostComments where T_PostComments.PostId = T_Post.Id ) ) and T_Author.Name like {0}\", queryParam1) .AsNoTrackingWithIdentityResolution() .Include(a => a.Blog.Posts) .ToListAsync(); //使用@参数名实现参数化查询 var queryParam1 = new SqlParameter(parameterName: \"@AuthorName\", value: \"Name_8%\"); var schema = EFDbContext.Schema; var resultList = await EFDbContext.Authors.FromSqlRaw(@\"select top 10 T_Author.* from CALC.T_Author as T_Author inner join CALC.T_Blog as T_Blog on T_Author.Id = T_Blog.AuthorId where exists ( select T_Post.Id from CALC.T_Post as T_Post where T_Post.BlogId = T_Blog.Id and exists ( select T_PostCollects.Id from CALC.T_PostCollects as T_PostCollects where T_PostCollects.PostId = T_Post.Id ) and exists ( select T_PostComments.Id from CALC.T_PostComments as T_PostComments where T_PostComments.PostId = T_Post.Id ) ) and T_Author.Name like @AuthorName\", queryParam1) .AsNoTrackingWithIdentityResolution() .Include(a => a.Blog.Posts) .ToListAsync(); //执行普通查询, 使用模板插值实现参数化查询, 也可以执行返回表数据的存储过程 var user = \"johndoe\"; var blogs = context.Blogs .FromSqlInterpolated($\"EXECUTE dbo.GetMostPopularBlogsForUser {user}\") .ToList(); //执行存储过程 var user = \"johndoe\"; var blogs = context.Blogs .FromSqlRaw(\"EXECUTE dbo.GetMostPopularBlogsForUser {0}\", user) .ToList(); //混合LINQ写法(存储过程无法使用LINQ组合查询, 若需要, 可在FromSqlInterpolated后使用AsEnumerable/AsAsyncEnumerable, 将数据加载到内存使用) var searchTerm = \"Lorem ipsum\"; var blogs = context.Blogs .FromSqlInterpolated($\"SELECT * FROM dbo.SearchBlogs({searchTerm})\") .Where(b => b.Rating > 3) .OrderByDescending(b => b.Rating) .AsNoTracking() .ToList(); //执行原生非查询操作 //使用原生sql执行非查询操作 var paramArr = new SqlParameter[] { new SqlParameter(parameterName:\"@AuthorName\",value:\"Name_8%\"), }; var sql = string.Format(@\"delete from CALC.T_PostComments where exists ( select T_Author.Id from CALC.T_Author as T_Author inner join CALC.T_Blog as T_Blog on T_Blog.AuthorId = T_Author.Id inner join CALC.T_Post as T_Post on T_Post.BlogId = T_Blog.Id where T_Author.Name like @AuthorName and T_PostComments.PostId = T_Post.Id )\"); var removeCount = await EFDbContext.Database.ExecuteSqlRawAsync(sql, paramArr, cancellationToken); //也可以使用模板内查值方式 EFDbContext.Database.ExecuteSqlInterpolatedAsync 7-7>用户自定义的函数映射 7-7-1>映射数据库的标量函数 CREATE FUNCTION dbo.CommentedPostCountForBlog(@id int) RETURNS int AS BEGIN RETURN (SELECT COUNT(*) FROM [Posts] AS [p] WHERE ([p].[BlogId] = @id) AND (( SELECT COUNT(*) FROM [Comments] AS [c] WHERE [p].[PostId] = [c].[PostId]) > 0)); END public int ActivePostCountForBlog(int blogId) => throw new NotSupportedException(); modelBuilder.HasDbFunction(typeof(BloggingContext).GetMethod(nameof(ActivePostCountForBlog), new[] { typeof(int) })) .HasName(\"CommentedPostCountForBlog\"); //调用函数 /* SELECT [b].[BlogId], [b].[Rating], [b].[Url] FROM [Blogs] AS [b] WHERE [dbo].[CommentedPostCountForBlog]([b].[BlogId]) > 1 */ var query1 = from b in context.Blogs where context.ActivePostCountForBlog(b.BlogId) > 1 select b; 7-7-2>映射数据库的表值函数 CREATE FUNCTION dbo.PostsWithPopularComments(@likeThreshold int) RETURNS TABLE AS RETURN ( SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title] FROM [Posts] AS [p] WHERE ( SELECT COUNT(*) FROM [Comments] AS [c] WHERE ([p].[PostId] = [c].[PostId]) AND ([c].[Likes] >= @likeThreshold)) > 0 ) public IQueryable PostsWithPopularComments(int likeThreshold) => FromExpression(() => PostsWithPopularComments(likeThreshold)); modelBuilder.Entity().ToTable(\"Posts\"); modelBuilder.HasDbFunction(typeof(BloggingContext).GetMethod(nameof(PostsWithPopularComments), new[] { typeof(int) })); //调用 /* SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title] FROM [dbo].[PostsWithPopularComments](@likeThreshold) AS [p] ORDER BY [p].[Rating] */ var likeThreshold = 3; var query5 = from p in context.PostsWithPopularComments(likeThreshold) orderby p.Rating select p; 7-7-3>其他不常用的复杂的功能 https://docs.microsoft.com/zh-cn/ef/core/querying/user-defined-function-mapping 7-8>全局查询筛选器(HasQueryFilter) *常用于下面两种场景 假删除: IsDeleted=0 多租户(同一张表, 使用租户Id的模式): TenantId=@TenantId 多租户的实现方法(假想, 未验证): public class Blog { public int BlogId { get; set; } public string Name { get; set; } public string Url { get; set; } public List Posts { get; set; } } //配置全局查询筛选器 modelBuilder.Entity().HasQueryFilter(b => EF.Property(b, \"TenantId\") == _tenantId); //实体保存时, 利用AOP拦截保存动作, 写入影子属性TenantId的值 EFDbContext.Entry(blog).Property(\"TenantId\").CurrentValue = systemConfigOption.Value?.TenantId; *为指定表注册查询筛选器 modelBuilder.Entity().HasQueryFilter(b => EF.Property(b, \"_tenantId\") == _tenantId); modelBuilder.Entity().HasQueryFilter(p => !p.IsDeleted); //查询过滤(IsDeleted=0) /* SELECT [t0].[Id], [t0].[AddIP], [t0].[AddTime], [t0].[AddUserId], [t0].[Address], [t0].[BirthDate], [t0].[Code], [t0].[CompanyName], [t0].[Email], [t0].[Hometown], [t0].[IsDeleted], [t0].[LastUpdateIP], [t0].[LastUpdateTime], [t0].[LastUpdateUserId], [t0].[Name], [t0].[Tel], [t0].[Title], [t0].[Token], [t1].[Id], [t1].[AddIP], [t1].[AddTime], [t1].[AddUserId], [t1].[AuthorId], [t1].[LastUpdateIP], [t1].[LastUpdateTime], [t1].[LastUpdateUserId], [t1].[OpenDate], [t1].[Token], [t1].[Url], [t2].[Id], [t2].[AddIP], [t2].[AddTime], [t2].[AddUserId], [t2].[BlogId], [t2].[Content], [t2].[IsDelete], [t2].[LastUpdateIP], [t2].[LastUpdateTime], [t2].[LastUpdateUserId], [t2].[PostStatus], [t2].[ReleaseTime], [t2].[Title], [t2].[Token] FROM ( SELECT TOP(10) [t].[Id], [t].[AddIP], [t].[AddTime], [t].[AddUserId], [t].[Address], [t].[BirthDate], [t].[Code], [t].[CompanyName], [t].[Email], [t].[Hometown], [t].[IsDeleted], [t].[LastUpdateIP], [t].[LastUpdateTime], [t].[LastUpdateUserId], [t].[Name], [t].[Tel], [t].[Title], [t].[Token] FROM [CALC].[T_Author] AS [t] WHERE [t].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t].[Name] DESC, [t].[Id] ) AS [t0] LEFT JOIN [CALC].[T_Blog] AS [t1] ON [t0].[Id] = [t1].[AuthorId] LEFT JOIN [CALC].[T_Post] AS [t2] ON [t1].[Id] = [t2].[BlogId] ORDER BY [t0].[Name] DESC, [t0].[Id], [t1].[Id], [t2].[Id] */ var resultList = await EFDbContext.Authors .Include(a => a.Blog.Posts) .AsNoTrackingWithIdentityResolution() .OrderByDescending(a => a.Name) .ThenBy(a => a.Code) .Take(10) .ToListAsync(cancellationToken); *查询过滤器进阶用法, 可以配置在导航属性上 modelBuilder.Entity().HasQueryFilter(b => b.Posts.Count > 0); //若配置了正反导航属性, 且对导航属性值做了全局过滤, 那么正反向的导航属性都需要配置上过滤条件, 避免LINQ查询没有使用Include, 导致查询结果不正确. modelBuilder.Entity().HasQueryFilter(b => b.Url.Contains(\"fish\")); modelBuilder.Entity().HasQueryFilter(p => p.Blog.Url.Contains(\"fish\")); *在查询中禁用筛选器 blogs = db.Blogs .Include(b => b.Posts) .IgnoreQueryFilters() .ToList(); 7-9>生成的SQL添加注释 *方便在众多的sql中定位目标sql(Tag支持多行文本) private IQueryable TaskLimitCount(IQueryable resultSource, int count = 10) => resultSource?.Take(count).TagWith(\"Tag in TaskLimitCount.\"); private IQueryable GetAuthors(int code = 0) => EFDbContext.Authors.Where(a => a.Code >= code).OrderByDescending(a => a.Name).TagWith(\"Tag in GetAuthors.\"); /* -- Tag in GetAuthors. -- Tag in TaskLimitCount. SELECT TOP(@__p_1) [t].[Id], [t].[AddIP], [t].[AddTime], [t].[AddUserId], [t].[Address], [t].[BirthDate], [t].[Code], [t].[CompanyName], [t].[Email], [t].[Hometown], [t].[IsDeleted], [t].[LastUpdateIP], [t].[LastUpdateTime], [t].[LastUpdateUserId], [t].[Name], [t].[Tel], [t].[Title], [t].[Token] FROM [CALC].[T_Author] AS [t] WHERE ([t].[IsDeleted] <> CAST(1 AS bit)) AND ([t].[Code] >= @__p_0) ORDER BY [t].[Name] DESC */ var resultList = await TaskLimitCount(GetAuthors(800), 15).ToListAsync(); 7-10>null判断 *尽量用==来替换!= *对于可空列的判断, 尽量先对该列进行null判断(entity.column1 != null) var query2 = context.Entities.Where( e => e.String1 != null && e.String2 != null && (e.String1 != e.String2 || e.String1.Length == e.String2.Length)); 7-11>查询的工作原理 LINQ 查询由 Entity Framework Core 处理，用于生成已准备好由数据库提供程序处理的表示形式 结果会被缓存，以便每次执行查询时无需进行此处理 结果会传递到数据库提供程序 数据库提供程序确定可以在数据库中评估查询的哪些部分 查询的这些部分会转换为特定数据库的查询语言（例如关系数据库的 SQL） 查询会发送到数据库并返回结果集（返回的是数据库中的值，而不是实体实例中的） 对于结果集中的每一项 如果该查询是跟踪查询，EF 会检查数据是否表示上下文实例内更改跟踪器中的现有实体 如果是，则会返回现有实体 如果不是，则会创建新实体、设置更改跟踪并返回该新实体 如果该查询是非跟踪查询，将始终创建并返回新实体 7-12>LINQ用法大全 First/FirstOrDefault: 返回集合中符合条件的第一个元素, 其实质就是在SQL语句中加TOP (1). Last/LastOrDefault: 返回集合中符合条件的最后一个元素, 需要结合LINQ的OrderBy使用, 否则报错. Single: 返回序列中的唯一记录, 如果没有或返回多条记录, 则引发异常. SingleOrDefault: 回序列中的唯一记录, 如果该序列为空, 则返回默认值, 如果该序列包含多个元素, 则引发异常. ElementAt: 返回指定索引的元素，如果索引超过集合长度，则抛出异常。 ElementAtOrDefault: 返回指定索引的元素，如果索引超过集合长度，则返回元素的默认值，不抛出异常。 //超出索引报错 var d2 = pList.ElementAt(3); //超出索引，不报错，返回默认值，这里为null var d3 = pList.ElementAtOrDefault(3); Distinct: 去重. Count/LongCount: 求个数. var count= db.Customers.Count(); var count=db.Customers.Count(c=>c.age>20); //等价于 var count=db.Customers.Where.(c=>c.age>20).Count(); Sum: 求和. var q=db.Product.Select(o=>o.Freight).Sum(); var q=db.Product.Sum(o=>o.Freight); Min: 最小值. var q=db.Products.Select(p=>p.unitPrice).Min(); var q=db.Products.Min(p=>p.unitPrice); Max: 最大值. var q=db.Products.Select(p=>p.unitPrice).Max(); var q=db.Products.Max(p=>p.unitPrice); Average: 求平均. var q=db.Products.Select(p=>p.unitPrice).Average(); var q=db.Products.Average(p=>p.unitPrice); orderby: 排序. //单字段排序 var q = from p in db.Products orderby p.unitPirce select p; //多字段排序 var q = from c in db.Customers orderby c.City descending, c.Name select c; //多字段排序 var resultList = await EFDbContext.Authors .OrderByDescending(a => a.Name) .ThenBy(a => a.AddTime) .Take(5) .ToListAsync(); Take: 获取集合的前n个元素(top N) TakeWhile: 直到指定条件就停止获取. EF无法翻译, 需要使用AsEnumerable将数据加载到内存计算. var resultList = EFDbContext.Authors.AsEnumerable() .TakeWhile(a => a.Code Skip: 跳过集合的前n个元素, 求剩下的元素. /* SELECT [t].[Id], [t].[AddIP], [t].[AddTime], [t].[AddUserId], [t].[Address], [t].[BirthDate], [t].[Code], [t].[CompanyName], [t].[Email], [t].[Hometown], [t].[IsDeleted], [t].[LastUpdateIP], [t].[LastUpdateTime], [t].[LastUpdateUserId], [t].[Name], [t].[Tel], [t].[Title], [t].[Token] FROM [CALC].[T_Author] AS [t] WHERE [t].[IsDeleted] <> CAST(1 AS bit) ORDER BY (SELECT 1) OFFSET 100 ROWS */ var resultList = await EFDbContext.Authors .Skip(100) .ToListAsync(); SkipWhile: 跳过集合的前n个元素, 直到符合指定条件为止, 求剩下的元素. EF无法翻译, 需要使用AsEnumerable将数据加载到内存计算. Any: 用于判断集合中是否有元素满足某一条件. /* SELECT CASE WHEN EXISTS ( SELECT 1 FROM [CALC].[T_Author] AS [t] WHERE ([t].[IsDeleted] <> CAST(1 AS bit)) AND ([t].[Code] > CAST(800 AS bigint))) THEN CAST(1 AS bit) ELSE CAST(0 AS bit) END */ var resultList = await EFDbContext.Authors .AnyAsync(a => a.Code > 800); All: 用于判断集合中所有元素是否都满足某一条件. /* SELECT CASE WHEN NOT EXISTS ( SELECT 1 FROM [CALC].[T_Author] AS [t] WHERE ([t].[IsDeleted] <> CAST(1 AS bit)) AND ([t].[Code] a.Code > 800); Contains: 用于查看包含关系、模糊查询等. var resultList = await EFDbContext.Authors .Where(a => a.Name.Contains(\"Name_80\")).ToListAsync(); //等同于 var resultList = await EFDbContext.Authors .Where(a => EF.Functions.Like(a.Name, \"%Name_80%\")).ToListAsync(); Concat: 连接不同的集合, 不会自动过滤相同项, 多个集合中连接的字段的类型必须完全一致.(类似SQL的Union All) /* SELECT [t2].[Name] FROM ( SELECT TOP(5) [t].[Name], [t].[Id], [t0].[Id] AS [Id0] FROM [CALC].[T_Author] AS [t] LEFT JOIN [CALC].[T_Blog] AS [t0] ON [t].[Id] = [t0].[AuthorId] WHERE ([t].[IsDeleted] <> CAST(1 AS bit)) AND (( SELECT COUNT(*) FROM [CALC].[T_Post] AS [t1] WHERE [t0].[Id] IS NOT NULL AND ([t0].[Id] = [t1].[BlogId])) > 0) ) AS [t2] UNION ALL SELECT [t6].[Name] FROM ( SELECT TOP(5) [t3].[Name], [t3].[Id], [t4].[Id] AS [Id0] FROM [CALC].[T_Author] AS [t3] LEFT JOIN [CALC].[T_Blog] AS [t4] ON [t3].[Id] = [t4].[AuthorId] WHERE ([t3].[IsDeleted] <> CAST(1 AS bit)) AND (( SELECT COUNT(*) FROM [CALC].[T_Post] AS [t5] WHERE [t4].[Id] IS NOT NULL AND ([t4].[Id] = [t5].[BlogId])) > 0) ORDER BY [t3].[Name] DESC ) AS [t6] */ var resultList = await ( EFDbContext.Authors .Include(a => a.Blog.Posts) .AsNoTrackingWithIdentityResolution() .Where(a => a.Blog.Posts.Count > 0) .Take(5) .Select(a => a.Name) .Concat ( EFDbContext.Authors .Include(a => a.Blog.Posts) .AsNoTrackingWithIdentityResolution() .Where(a => a.Blog.Posts.Count > 0) .OrderByDescending(a => a.Name) .Take(5) .Select(a => a.Name) ) ).ToListAsync(); Union: 连接多个不同的集合，自动过滤相同的选项，即求并集.(类似SQL的Union) /* SELECT [t0].[Id], [t0].[AddIP], [t0].[AddTime], [t0].[AddUserId], [t0].[Address], [t0].[BirthDate], [t0].[Code], [t0].[CompanyName], [t0].[Email], [t0].[Hometown], [t0].[IsDeleted], [t0].[LastUpdateIP], [t0].[LastUpdateTime], [t0].[LastUpdateUserId], [t0].[Name], [t0].[Tel], [t0].[Title], [t0].[Token] FROM ( SELECT TOP(4) [t].[Id], [t].[AddIP], [t].[AddTime], [t].[AddUserId], [t].[Address], [t].[BirthDate], [t].[Code], [t].[CompanyName], [t].[Email], [t].[Hometown], [t].[IsDeleted], [t].[LastUpdateIP], [t].[LastUpdateTime], [t].[LastUpdateUserId], [t].[Name], [t].[Tel], [t].[Title], [t].[Token] FROM [CALC].[T_Author] AS [t] WHERE [t].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t].[Name] ) AS [t0] UNION SELECT [t2].[Id], [t2].[AddIP], [t2].[AddTime], [t2].[AddUserId], [t2].[Address], [t2].[BirthDate], [t2].[Code], [t2].[CompanyName], [t2].[Email], [t2].[Hometown], [t2].[IsDeleted], [t2].[LastUpdateIP], [t2].[LastUpdateTime], [t2].[LastUpdateUserId], [t2].[Name], [t2].[Tel], [t2].[Title], [t2].[Token] FROM ( SELECT TOP(3) [t1].[Id], [t1].[AddIP], [t1].[AddTime], [t1].[AddUserId], [t1].[Address], [t1].[BirthDate], [t1].[Code], [t1].[CompanyName], [t1].[Email], [t1].[Hometown], [t1].[IsDeleted], [t1].[LastUpdateIP], [t1].[LastUpdateTime], [t1].[LastUpdateUserId], [t1].[Name], [t1].[Tel], [t1].[Title], [t1].[Token] FROM [CALC].[T_Author] AS [t1] WHERE [t1].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t1].[Name] ) AS [t2] */ var resultList = await (EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .TagWith(\"First collection\") .OrderBy(a => a.Name) .Take(4) .Union ( EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .TagWith(\"Sec collection\") .OrderBy(a => a.Name) .Take(3) )) .ToListAsync(); Intersect: 求多个几个集合之间的交集. /* SELECT [t0].[Id], [t0].[AddIP], [t0].[AddTime], [t0].[AddUserId], [t0].[Address], [t0].[BirthDate], [t0].[Code], [t0].[CompanyName], [t0].[Email], [t0].[Hometown], [t0].[IsDeleted], [t0].[LastUpdateIP], [t0].[LastUpdateTime], [t0].[LastUpdateUserId], [t0].[Name], [t0].[Tel], [t0].[Title], [t0].[Token] FROM ( SELECT TOP(2) [t].[Id], [t].[AddIP], [t].[AddTime], [t].[AddUserId], [t].[Address], [t].[BirthDate], [t].[Code], [t].[CompanyName], [t].[Email], [t].[Hometown], [t].[IsDeleted], [t].[LastUpdateIP], [t].[LastUpdateTime], [t].[LastUpdateUserId], [t].[Name], [t].[Tel], [t].[Title], [t].[Token] FROM [CALC].[T_Author] AS [t] WHERE [t].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t].[Name] ) AS [t0] INTERSECT SELECT [t2].[Id], [t2].[AddIP], [t2].[AddTime], [t2].[AddUserId], [t2].[Address], [t2].[BirthDate], [t2].[Code], [t2].[CompanyName], [t2].[Email], [t2].[Hometown], [t2].[IsDeleted], [t2].[LastUpdateIP], [t2].[LastUpdateTime], [t2].[LastUpdateUserId], [t2].[Name], [t2].[Tel], [t2].[Title], [t2].[Token] FROM ( SELECT TOP(4) [t1].[Id], [t1].[AddIP], [t1].[AddTime], [t1].[AddUserId], [t1].[Address], [t1].[BirthDate], [t1].[Code], [t1].[CompanyName], [t1].[Email], [t1].[Hometown], [t1].[IsDeleted], [t1].[LastUpdateIP], [t1].[LastUpdateTime], [t1].[LastUpdateUserId], [t1].[Name], [t1].[Tel], [t1].[Title], [t1].[Token] FROM [CALC].[T_Author] AS [t1] WHERE [t1].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t1].[Name] ) AS [t2] */ var resultList =await EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .TagWith(\"First collection\") //.AsEnumerable() .OrderBy(a => a.Name) .Take(4) .Intersect ( EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .TagWith(\"Sec collection\") //.AsEnumerable() .OrderBy(a => a.Name) .Take(3) ) .ToListAsync(); Except: 求差集. /* SELECT [t0].[Id], [t0].[AddIP], [t0].[AddTime], [t0].[AddUserId], [t0].[Address], [t0].[BirthDate], [t0].[Code], [t0].[CompanyName], [t0].[Email], [t0].[Hometown], [t0].[IsDeleted], [t0].[LastUpdateIP], [t0].[LastUpdateTime], [t0].[LastUpdateUserId], [t0].[Name], [t0].[Tel], [t0].[Title], [t0].[Token] FROM ( SELECT TOP(4) [t].[Id], [t].[AddIP], [t].[AddTime], [t].[AddUserId], [t].[Address], [t].[BirthDate], [t].[Code], [t].[CompanyName], [t].[Email], [t].[Hometown], [t].[IsDeleted], [t].[LastUpdateIP], [t].[LastUpdateTime], [t].[LastUpdateUserId], [t].[Name], [t].[Tel], [t].[Title], [t].[Token] FROM [CALC].[T_Author] AS [t] WHERE [t].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t].[Name] ) AS [t0] EXCEPT SELECT [t2].[Id], [t2].[AddIP], [t2].[AddTime], [t2].[AddUserId], [t2].[Address], [t2].[BirthDate], [t2].[Code], [t2].[CompanyName], [t2].[Email], [t2].[Hometown], [t2].[IsDeleted], [t2].[LastUpdateIP], [t2].[LastUpdateTime], [t2].[LastUpdateUserId], [t2].[Name], [t2].[Tel], [t2].[Title], [t2].[Token] FROM ( SELECT TOP(1) [t1].[Id], [t1].[AddIP], [t1].[AddTime], [t1].[AddUserId], [t1].[Address], [t1].[BirthDate], [t1].[Code], [t1].[CompanyName], [t1].[Email], [t1].[Hometown], [t1].[IsDeleted], [t1].[LastUpdateIP], [t1].[LastUpdateTime], [t1].[LastUpdateUserId], [t1].[Name], [t1].[Tel], [t1].[Title], [t1].[Token] FROM [CALC].[T_Author] AS [t1] WHERE [t1].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t1].[Name] ) AS [t2] */ var resultList =await EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .TagWith(\"First collection\") //.AsEnumerable() .OrderBy(a => a.Name) .Take(4) .Except ( EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .TagWith(\"Sec collection\") //.AsEnumerable() .OrderBy(a => a.Name) .Take(3) ) .ToListAsync(); ToArray: 将序列转换为数组 ToList: 将序列转为泛型List ToDictionary: 将序列转换成字典 var q = from c in db.Customers select c; Dictionary cDict= q.ToDictionary(p=>p.cId); OfType: 获取集合中指定类型元素 object[] obj = { 1, 23, 4, 5, 555, \"aaa\", \"bbb\" }; int max = obj.OfType().Max(); //结果是55, 获取int类型中的最大值 selectMany: 相当于二次遍历查找. var resultList = await EFDbContext.Authors .Skip(10) .Take(3) .Include(a=>a.Blog.Posts) .SelectMany(a => a.Blog.Posts) .ToListAsync(); join: 内连接. var resultList = await EFDbContext.Authors .Join(EFDbContext.Blogs, a => a.Id, b => b.AuthorId, (a, b) => new { a, b }) .AsNoTrackingWithIdentityResolution() .Take(3) .ToListAsync(); //等价于 var resultList = await ( from a in EFDbContext.Authors join b in EFDbContext.Blogs on a.Id equals b.AuthorId select new { a, b } ) .AsNoTrackingWithIdentityResolution() .Take(3) .ToListAsync(); GroupJoin: 左外连接/右外连接 var queryable = from lc in _calcDbContext.Persons join o in _calcDbContext.Cars on lc.Id equals o.PersonId into og from ro in og.DefaultIfEmpty() orderby lc.Id descending, ro.Id ascending select new { PersonId = lc.Id, lc.Name, CarId = ro.Id, MSN = ro.MSN, ro.Price, }; //=>等价于下面的语句 var queryable = _calcDbContext .Persons .GroupJoin ( _calcDbContext.Cars, c => c.Id, o => o.PersonId, (c, os) => new { Person = c, Cars = os } ) .SelectMany ( combination => combination.Cars.DefaultIfEmpty(), (c, o) => new { CustomerId = c.Person.Id, c.Person.Name, CarId = o.Id, MSN = o.MSN, o.Price, } ) .OrderByDescending(o => o.CustomerId).ThenBy(o => o.CarId) .TagWith(\"my sql\"); var resultList = await queryable.TagWith(\"test sql\").Take(3).ToListAsync(); ToLookup: 当同一个key要求对应多个value情况, ToLookup方法是非常有用的. ToLookup返回一种特殊的数据结构类似sql的group, 可以把集合分组并且可以用索引访问这些元素. Lookup的结果集是ReadOnly的. *EF无法翻译. var resultList = EFDbContext.Posts .ToLookup(p => p.BlogId) .Select(g => new { Key = g.Key.ToString(), List = g.ToList() }) .Take(3) .ToList(); SequenceEqual: 比较list和list之间, 数组和数组之间是否相等. var isSequenceEqual = EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .OrderBy(a => a.Name) .Take(3) .ToList() .SequenceEqual ( await EFDbContext.Authors .AsNoTrackingWithIdentityResolution() .OrderBy(a => a.Name) .Take(3) .ToListAsync() ); DefaultIfEmpty: 返回指定序列的元素, 如果序列为空, 则返回单一实例集合中的类型参数的默认值, 多用于外连接查询. int[] arr1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };//构造带元素的数组 int[] arr2 = { }; //构造一个空数组 string[] str = { }; var d1 = arr1.DefaultIfEmpty().ToList(); //9个元素 var d2 = arr2.DefaultIfEmpty().ToList(); //1个元素,且为0,即int类型的默认值 var d3 = arr2.DefaultIfEmpty(86).ToList(); //1个元素,且为86,即int类型的默认值 var d4 = str.DefaultIfEmpty().ToList(); //1个元素,且为null,即string类型的默认值 Empty: 内部生成了一个T[]数组, 数组的个数为0. (想象不出可以用在什么业务场景上╮(╯▽╰)╭) var strArr = Enumerable.Empty().ToArray(); Range: 生成指定范围内的整数的序列. //生成0-9的数组 var list = Enumerable.Range(0, 10); Repeat: 生成一个重复值的序列. //生成N个任意类型的数据 var list = Enumerable.Repeat(\"dylan\", 10); Aggregate: 累计计算. var list = Enumerable.Repeat(\"dylan\", 10); var resultList = list.Aggregate(\"total:\", (current, str) => $\"{current}{str},\", str => string.IsNullOrEmpty(str) ? \"\" : str.Substring(0, str.Length - 1)); var resultList = list.Aggregate(\"total:\", (current, str) => { return $\"{current}{str},\"; }, str => { return string.IsNullOrEmpty(str) ? \"\" : str.Substring(0, str.Length - 1); }); AsEnumerable: 是延迟执行的, 实际上什么都没有发生, 当真正使用对象的时候才执行. AsQueryable: 也是延迟执行的, 将一个序列向下转换为一个IQueryable, 它生成了一个本地查询的IQueryable包装. Cast: 将 IQueryable 的元素转换为指定的类型. 7-13>EF.Functions 7-13-1>常用的方法如下: Like: SQL的Like var list = await EFDbContext.Authors .Where(a => EF.Functions.Like(a.Name, \"name_80%\")) .Take(2) .Select(a => new { Name = a.Name, Code = a.Code }).ToListAsync(); Collate: 可以用来解决查询的时候某些字段是否区分大小写的问题. SQL_Latin1_General_CP1_CI_AS(不区分大小写), SQL_Latin1_General_CP1_CS_AS(区分大小写). /* SELECT TOP(@__p_1) [t].[Name], [t].[Code] FROM [CALC].[T_Author] AS [t] WHERE ([t].[IsDeleted] <> CAST(1 AS bit)) AND ([t].[Name] COLLATE SQL_Latin1_General_CP1_CS_AS LIKE N'name_80%') */ var list = await EFDbContext.Authors .Where(a => EF.Functions.Like(EF.Functions.Collate(a.Name, \"SQL_Latin1_General_CP1_CS_AS\"), \"name_80%\")) .Take(2) .Select(a => new { Name = a.Name, Code = a.Code }).ToListAsync(); DataLength: 求字节长度(1个中文字符2位, 1个英文字符1位), varchar用来存在只有非中文的串, nvarchar用来存放含有中文的串, 建议全部创建成nvarchar类型. DateDiffXXX: 各种操作时间的方法, 按照实际需求调用. 7-13-2>拓展EF.Functions https://www.cnblogs.com/GuZhenYin/p/14657024.html https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.entityframeworkcore.query.isqlexpressionfactory.function?view=efcore-5.0 对于某些数据库的内置函数, 如果实际业务中需要用到, 可以自己拓展EF.Functions 来达到支持的效果, 以下拓展 SQL Server的 STUFF --我的课程 SELECT STUFF('MySQL课程',1,2,'我的') *可以参考demo里的实现 核心拓展类SQLServerFunctionsTranslateImpl.cs using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Diagnostics; using Microsoft.EntityFrameworkCore.Query; using Microsoft.EntityFrameworkCore.Query.SqlExpressions; using System; using System.Collections.Generic; using System.Linq; using System.Reflection; using System.Text; using System.Threading.Tasks; namespace Dylan.Repository.DbFunctionsExtension { /// /// SQL Server的调用方法转换器 /// public class SQLServerFunctionsTranslateImpl : IMethodCallTranslator { /// /// 反射SQLServerFunctionsExtensions.SQLServerStuff获得的方法对象 /// private static readonly MethodInfo _SQLServerStuffMethod = typeof(SQLServerFunctionsExtensions) .GetMethod ( nameof(SQLServerFunctionsExtensions.SQLServerStuff), new[] { typeof(DbFunctions), typeof(string), typeof(int), typeof(int),typeof(string), } ); /// /// 表达式工厂 /// private readonly ISqlExpressionFactory _expressionFactory; /// /// 构造函数 /// /// 表达式工厂 public SQLServerFunctionsTranslateImpl(ISqlExpressionFactory expressionFactory) { _expressionFactory = expressionFactory; } /// /// 生成SQL表达式对象 /// /// /// /// /// /// public SqlExpression Translate(SqlExpression instance, MethodInfo method, IReadOnlyList arguments, IDiagnosticsLogger logger) { //TODO 后续可以继续拓展其他函数 //判断方法是否一致 if (method == _SQLServerStuffMethod) { var args = new List { arguments[1], arguments[2], arguments[3], arguments[4] }; var argumentsPropagateNullabilitys = new List { true, false, false, true }; return _expressionFactory.Function(\"STUFF\", args, true, argumentsPropagateNullabilitys, typeof(string)); } return null; } } } 最后调用代码: /* SELECT TOP(@__p_0) STUFF([t].[Name], 1, 4, N'dylan') AS [Name], [t].[Code] FROM [CALC].[T_Author] AS [t] WHERE [t].[IsDeleted] <> CAST(1 AS bit) ORDER BY [t].[Name] */ var resultList = await EFDbContext.Authors.OrderBy(a => a.Name).Take(2).Select(a => new { Name = EF.Functions.SQLServerStuff(a.Name, 1, 4, \"dylan\"), a.Code }).ToListAsync(); 8>新增/修改 *每个EF上下文实例都有一个 ChangeTracker(更改跟踪器), 它负责跟踪需要写入数据库的更改. 当更改实体类的实例时(修改属性, 删除实例, 新建实例等), 这些更改会记录在 ChangeTracker 中, 然后在调用 SaveChanges 时被写入数据库. 此数据库提供程序负责将更改, 转换为特定的数据库操作（例如关系数据库的 INSERT,UPDATE 和 DELETE 命令）. //新增 var blog = new Blog { Url = \"http://sample.com\" }; context.Blogs.Add(blog); context.SaveChanges(); //修改 var blog = context.Blogs.First(); blog.Url = \"http://sample.com/blog\"; context.SaveChanges(); *单个 SaveChanges 中的多个操作 //add context.Blogs.Add(new Blog { Url = \"http://sample.com/blog_one\" }); context.Blogs.Add(new Blog { Url = \"http://sample.com/blog_two\" }); //update var firstBlog = context.Blogs.First(); firstBlog.Url = \"\"; //remove var lastBlog = context.Blogs.Last(); context.Blogs.Remove(lastBlog); context.SaveChanges(); *在某些情况下, 实体通过A上下文查询出来后, 需要在B上下文保存, 这时候需要通过执行context.Add/context.Update public static void Insert(DbContext context, object entity) { context.Add(entity); context.SaveChanges(); } public static void Update(DbContext context, object entity) { context.Update(entity); context.SaveChanges(); } *如果实体不使用自动生成的键，则应用程序必须确定是应插入实体还是应更新实体 public static void InsertOrUpdate(BloggingContext context, Blog blog) { var existingBlog = context.Blogs.Find(blog.BlogId); if (existingBlog == null) { context.Add(blog); } else { // SetValues 调用将根据需要，标记要更新的实体属性。原理是：要更新的实体与之前查询的实体进行比较，只会更新实际发生更改的列 context.Entry(existingBlog).CurrentValues.SetValues(blog); } context.SaveChanges(); } *实体级联操作 *级联添加 var blog = new Blog { Url = \"http://blogs.msdn.com/dotnet\", Posts = new List { new Post { Title = \"Intro to C#\" }, new Post { Title = \"Intro to VB.NET\" }, new Post { Title = \"Intro to F#\" } } }; context.Blogs.Add(blog); context.SaveChanges(); var blog = context.Blogs.Include(b => b.Posts).First(); var post = new Post { Title = \"Intro to EF Core\" }; //引用新实体 blog.Posts.Add(post); context.SaveChanges(); //新增一个主体实体 var blog = new Blog { Url = \"http://blogs.msdn.com/visualstudio\" }; var post = context.Posts.First(); //post更新关系 post.Blog = blog; context.SaveChanges(); var blog = context.Blogs.Include(b => b.Posts).First(); var post = blog.Posts.First(); //删除一条post依赖实体 blog.Posts.Remove(post); context.SaveChanges(); 9>删除 //第一种情况 var blog = context.Blogs.First(); context.Blogs.Remove(blog); context.SaveChanges(); //第二种情况 Blog blog = new Blog() { Url = \"www.baidu.com\" }; //添加后该实体为已添加，尚未保存到数据库 BloggingContext.Blogs.Add(blog); //删除实体类的实例 BloggingContext.Blogs.Remove(blog); //从上下文中移除blog实体 BloggingContext.SaveChanges(); *级联删除 var blog = context.Blogs.Include(b => b.Posts).First(); var posts = blog.Posts.ToList(); context.Remove(blog); context.SaveChanges(); //测试不预加载, 是否可以执行级联删除(测试结果:可以) var id = 1470214131637424132L; var people = await EFDbContext.Peoples.TagWith(\"my statement\") .AsTracking() .SingleOrDefaultAsync(p => p.Id == id); EFDbContext.Peoples.Remove(people); var affectRowCount = await EFDbContext.SaveChangesAsync(cancellationToken); var people = await EFDbContext.Peoples.Include(t => t.Cars).Where(t => t.Cars.Count > 0).FirstOrDefaultAsync(); //使用clear(测试结果: 删除了people的Cars) people.Cars.Clear(); var affectRowCount = await EFDbContext.SaveChangesAsync(cancellationToken); var entry1 = EFDbContext.Entry(people); _ = entry1.DebugView.LongView; //测试结果: 删除了people的Cars EFDbContext.Cars.RemoveRange(people.Cars); _ = entry1.DebugView.LongView; var affectRowCount = await EFDbContext.SaveChangesAsync(cancellationToken); 10>事务 *dbcontext.SaveChanges 默认数据库提供程序支持事务, 就会执行事务行为(隐式事务) *显式控制事务 /// /// 测试事务 /// /// /// public async Task TestTransaction(CancellationToken cancellationToken) { //1>显示使用事务 using CALCDbContext dbContext = new(SystemConfigOption); using var transaction = dbContext.Database.BeginTransaction(); try { var nameCharList = new char[] { 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z', 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z', '0','1','2','3','4','5','6','7','8','9' }; var charCount = nameCharList.Count(); //构造people var nameLength = FramePublicFun.GetRandomByGuid(4, 11); var nameStr = \"\"; for (var j = 0; j carList = new(); var carCount = FramePublicFun.GetRandomByGuid(1, 4); for (var ii = 0; ii *保存点 /// /// 测试事务 /// /// /// public async Task TestTransaction(CancellationToken cancellationToken) { //1>显示使用事务 using CALCDbContext dbContext = new(SystemConfigOption); using var transaction = dbContext.Database.BeginTransaction(); try { var nameCharList = new char[] { 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z', 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z', '0','1','2','3','4','5','6','7','8','9' }; var charCount = nameCharList.Count(); //构造people var nameLength = FramePublicFun.GetRandomByGuid(4, 11); var nameStr = \"\"; for (var j = 0; j carList = new(); var carCount = FramePublicFun.GetRandomByGuid(1, 4); for (var ii = 0; ii *跨多个上下文事务（仅限关系数据库） DbContext必须用同一个DbContextOptions实例化, 否则会报错. public class BloggingContext : DbContext { private DbConnection _connection; public BloggingContext(DbConnection connection) { _connection = connection; } public DbSet Blogs { get; set; } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(_connection); } } using var connection = new SqlConnection(connectionString); var options = new DbContextOptionsBuilder() .UseSqlServer(connection) .Options; using var context1 = new BloggingContext(options); using var transaction = context1.Database.BeginTransaction(); try { context1.Blogs.Add(new Blog { Url = \"http://blogs.msdn.com/dotnet\" }); context1.SaveChanges(); using (var context2 = new BloggingContext(options)) { context2.Database.UseTransaction(transaction.GetDbTransaction()); var blogs = context2.Blogs .OrderBy(b => b.Url) .ToList(); } // Commit transaction if all commands succeed, transaction will auto-rollback // when disposed if either commands fails transaction.Commit(); } catch (Exception) { // TODO: Handle failure } *多种数据访问技术共享事务 using var connection = new SqlConnection(connectionString); connection.Open(); using var transaction = connection.BeginTransaction(); try { // Run raw ADO.NET command in the transaction var command = connection.CreateCommand(); command.Transaction = transaction; command.CommandText = \"DELETE FROM dbo.Blogs\"; command.ExecuteNonQuery(); // Run an EF Core command in the transaction var options = new DbContextOptionsBuilder() .UseSqlServer(connection) .Options; using (var context = new BloggingContext(options)) { context.Database.UseTransaction(transaction); context.Blogs.Add(new Blog { Url = \"http://blogs.msdn.com/dotnet\" }); context.SaveChanges(); } // Commit transaction if all commands succeed, transaction will auto-rollback // when disposed if either commands fails transaction.Commit(); } catch (Exception) { // TODO: Handle failure } *分布式事务 如果需要跨大作用域进行协调，则可以使用分布式事务（跨库事务）TransactionScope，它可协调跨多个资源管理器的事务。存在于ADO.NET 中的System.Transactions命令空间。 using (var scope = new TransactionScope( TransactionScopeOption.Required, new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted })) { using var connection = new SqlConnection(connectionString); connection.Open(); try { // Run raw ADO.NET command in the transaction var command = connection.CreateCommand(); command.CommandText = \"DELETE FROM dbo.Blogs\"; command.ExecuteNonQuery(); // Run an EF Core command in the transaction var options = new DbContextOptionsBuilder() .UseSqlServer(connection) .Options; using (var context = new BloggingContext(options)) { context.Blogs.Add(new Blog { Url = \"http://blogs.msdn.com/dotnet\" }); context.SaveChanges(); } // Commit transaction if all commands succeed, transaction will auto-rollback // when disposed if either commands fails scope.Complete(); } catch (Exception) { // TODO: Handle failure } } 可以执行显示分布式事务 using (var transaction = new CommittableTransaction( new TransactionOptions { IsolationLevel = IsolationLevel.ReadCommitted })) { var connection = new SqlConnection(connectionString); try { var options = new DbContextOptionsBuilder() .UseSqlServer(connection) .Options; using (var context = new BloggingContext(options)) { context.Database.OpenConnection(); context.Database.EnlistTransaction(transaction); // Run raw ADO.NET command in the transaction var command = connection.CreateCommand(); command.CommandText = \"DELETE FROM dbo.Blogs\"; command.ExecuteNonQuery(); // Run an EF Core command in the transaction context.Blogs.Add(new Blog { Url = \"http://blogs.msdn.com/dotnet\" }); context.SaveChanges(); context.Database.CloseConnection(); } // Commit transaction if all commands succeed, transaction will auto-rollback // when disposed if either commands fails transaction.Commit(); } catch (Exception) { // TODO: Handle failure } } *事务隔离级别(IsolationLevel) https://www.cnblogs.com/wms01/p/6183241.html 隔离级别与并发性是互为矛盾的：隔离程度越高，数据库的并发性越差；隔离程度越低，数据库的并发性越好. 1、ReadUncommitted 未提交读。当事务A更新某条数据的时候，不容许其他事务来更新该数据，但可以进行读取操作 2、ReadCommitted 提交读。当事务A更新数据时，不容许其他事务进行任何的操作包括读取，但事务A读取时，其他事务可以进行读取、更新 3、RepeatableRead 重复读。当事务A更新数据时，不容许其他事务进行任何的操作，但是当事务A进行读取的时候，其他事务只能读取，不能更新 4、Serializable 序列化。最严格的隔离级别，当然并发性也是最差的，事务必须依次进行。 11>设置SQL Server IDENTITY列中的显式值 大多数情况是由数据库生成自增长ID. 如果要需要显式值插入IDENTITY列, 需要在调用SaveChanges()之前, 手动启用IDENTITY_INSERT. using (var context = new EmployeeContext()) { context.Employees.Add(new Employee { EmployeeId = 100, Name = \"John Doe\" }); context.Employees.Add(new Employee { EmployeeId = 101, Name = \"Jane Doe\" }); context.Database.OpenConnection(); try { context.Database.ExecuteSqlInterpolated(\"SET IDENTITY_INSERT dbo.Employees ON\"); context.SaveChanges(); context.Database.ExecuteSqlInterpolated(\"SET IDENTITY_INSERT dbo.Employees OFF\"); } finally { context.Database.CloseConnection(); } } 12>集成Dapper, 用于复杂查询 https://www.cnblogs.com/flywong/p/9666963.html https://www.cnblogs.com/zhangnever/p/11926045.html 添加Dapper包, Dapper通过拓展DbConnection实现ADO操作, 在EF中混合使用Dapper, 可以从上下文获取DbConnection, 以及根据情况是否使用事务. //5>使用dapper处理复杂语句 DbConnection dbConnection = EFDbContext.Database.GetDbConnection(); DbTransaction dbTransaction = default; if (EFDbContext.Database.CurrentTransaction != default) { dbTransaction = EFDbContext.Database.CurrentTransaction.GetDbTransaction(); } var schema = EFDbContext.Schema; var dynamicParameters = new DynamicParameters(); dynamicParameters.Add(\"@Extension\", \"%_122\"); var resultList = await dbConnection.QueryAsync(string.Format(@\"select T_Author.Id as AuthorId, T_Author.Name as AuthorName, T_Blog.Url as BlogUrl, T_Blog.OpenDate as BlogOpenDate from {0}.T_Author as T_Author inner join {0}.T_Blog as T_Blog on T_Blog.AuthorId = T_Author.Id where T_Author.Name not like @Extension and not exists ( select T_PostCollectCatgory.Id from {0}.T_PostCollectCatgory as T_PostCollectCatgory where T_PostCollectCatgory.AuthorId = T_Author.Id )\", schema), dynamicParameters, dbTransaction); //将dynamic列表转成IDictionary列表 var dicList = resultList.Cast>().ToList(); return Json(dicList); } catch (Exception ex) { return Json(new { ErrorMsg = ex.GetInnerExceptionMsg() }); } 13>雪花ID https://www.cnblogs.com/zxtceq/articles/15029054.html https://zhuanlan.zhihu.com/p/374667160 https://www.cnblogs.com/dunitian/p/6130543.html 分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。而twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。 雪花算法的原始版本是 Scala 版，用于生成分布式ID（纯数字，时间顺序）,订单编号等。 自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。大部分数据库会自动将主键设置为聚集索引，严重影响CUD操作, 需要将GUID的主键设置为非聚集索引.(MySQL5.x主键无法改成非聚集索引, 这是个大坑). *HILO: 高低位算法, 需要自己实现算法, 也是个不错的选择. 13-1>算法描述 最高位是符号位，始终为0，不可用。 41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。 10位的机器标识，10位的长度最多支持部署1024个节点。 12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。 13-2>Net Core中使用 *主键字段设置为bigint/vachar(50)类型 PS: 做过数量批量插入的测试, 设置为bigint类型, 执行速度会比varchar(50)快 //BaseLogicEntity.cs /// /// 逻辑基类 /// public abstract class BaseLogicEntity : BaseEntity { /// /// Id /// [Key] //主键 [DatabaseGenerated(DatabaseGeneratedOption.None)] //数据库不生成 //[Column(TypeName = \"varchar(50)\")] [Column(TypeName = \"bigint\")] [Comment(\"Id\")] [Required] //public virtual string Id { get; set; } = SnowflakeID.GetInstance().GetNextID(); public virtual long Id { get; set; } = SnowflakeID.GetInstance().GetNextID(); /// /// 创建时间 /// [Column(TypeName = \"datetimeoffset(7)\")] [Comment(\"创建时间\")] [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public virtual DateTimeOffset? AddTime { get; set; } = DateTimeOffset.UtcNow; /// /// 创建者Id /// [Comment(\"创建者Id\")] [Column(TypeName = \"varchar(50)\")] public virtual string AddUserId { get; set; } /// /// 创建者IP /// [Column(TypeName = \"varchar(130)\")] [Comment(\"创建者IP\")] public virtual string AddIP { get; set; } /// /// 修改时间 /// [Column(TypeName = \"datetimeoffset(7)\")] [Comment(\"修改时间\")] //[DatabaseGenerated(DatabaseGeneratedOption.Computed)] public virtual DateTimeOffset? LastUpdateTime { get; set; } = DateTimeOffset.UtcNow; /// /// 修改者Id /// [Column(TypeName = \"varchar(50)\")] [Comment(\"修改者Id\")] public virtual string LastUpdateUserId { get; set; } /// /// 修改IP /// [Column(TypeName = \"varchar(130)\")] [Comment(\"创建者IP\")] public virtual string LastUpdateIP { get; set; } /// /// 并发令牌 /// [Timestamp] [Comment(\"并发令牌\")] public virtual byte[] Token { get; set; } /// /// 获取当前实体的哈希值 /// /// public override int GetHashCode() { if (this == null) { return this.GetHashCode(); } return this.Id.ToString().GetHashCode(); } /// /// 实体是否一直 /// /// /// public override bool Equals(object obj) { if (obj == null || this == null) { return false; } BaseLogicEntity baseLogicEntity = obj as BaseLogicEntity; if (baseLogicEntity == null) { return false; } return baseLogicEntity.Id.ToString() == this.Id.ToString(); } /// /// 格式化当前实体 /// /// 执行结果 public override string ToString() { return base.ToString(); } } //SnowflakeID.cs /// /// 雪花ID生成器 /// /// /// IdWorker应该以单例模式运行, 否则会出现重复Id. /// /// /// https://www.cnblogs.com/zxtceq/articles/15029054.html /// https://www.cnblogs.com/dunitian/p/6130543.html#top /// public class SnowflakeID { /// /// 实例锁 /// private static readonly object InstanceLocker = new(); /// /// 私有实例 /// private static SnowflakeID _instance = null; /// /// 雪花ID生成器 /// private IdWorker _idWorker = null; /// /// workerId /// private long _workerId => 1; /// /// datacenterId /// private long _datacenterId => 1; /// /// 私有构造函数 /// private SnowflakeID() { if (_idWorker == null) { _idWorker = new IdWorker(_workerId, _datacenterId); } } /// /// 静态构造函数 /// static SnowflakeID() { } /// /// 获取全局唯一实例 /// /// public static SnowflakeID GetInstance() { if (_instance == null) { lock (InstanceLocker) { if (_instance == null) { _instance = new SnowflakeID(); } } } return _instance; } /// /// 获取下一个雪花ID /// /// 默认生成的Id是long类型 /// T /// public T GetNextID() => FramePublicFun.ConvertType(_idWorker.NextId()); /// /// 异步获取下一个雪花ID /// /// T /// public Task GetNextIDAsync() { return Task.Run(() => { return FramePublicFun.ConvertType(_idWorker.NextId()); }); } } 14>主键的设计 表的主键除了使用自增ID, GUID, HILO，雪花ID, 还可以将使用两个主键(不是复合主键). 主键使用自增ID, 再新增一个GUID列, 自增ID只是为了充当聚集索引, 加快查询速度, 而GUID才是充当实际业务上的外键使用, 这样的搭配方式可以有效的利用两种ID的优点. 不过在一般情况下, 雪花ID可以满足分布式应用(高并发场景), 其索引的连续性, 在作为聚集索引的情况下, 索引速度也很快. 15>读写分离 如何删除分发服务器脚本 SQLServer复制需要有实际的服务器名称才能连接到服务器,请指定实际的服务器名 最简单的SQLserver，发布订阅教程，保证一次就成功 由于出现操作系统错误 3，进程无法读取文件D:\\XXXX\\X.pre (源: MSSQL_REPL，错误号: MSSQL_REPL20024) 15-1>SQL读写分离(主从复制) - 实际配的过程, 使用了2台服务器, 1台作为发送服务器, 2台作为订阅服务器, 因为使用请求订阅一直配置失败, 后面改成了发送订阅, 并关闭了发件服务器的防火墙, 才配置成功. 另, SQL Server的从库同步主库, 最小频率只能是10S, 因此在实际工作中不会采用SQL Server作为生产工具. 15-1-1>校验服务器的名称和实际计算机的名称是否一致 use master go select @@servername; select serverproperty('servername') --若不一致,则使用如下语句, 再重启SQL SERVER服务 use master go sp_dropserver '旧服务器名称' --@@servername查询出来的名称 go sp_addserver '新服务器名称','local' --serverproperty('servername')查询出来的名称 go 15-1-2>修改本机host文件, 添加本地域名映射(发布服务器和订阅服务器都需要配置) 配置文件地址: C:\\Windows\\System32\\drivers\\etc\\hosts SC-202110141618是15-1-1的实际计算机名称 192.168.60.103 SC-202110141618 15-1-3>使用sql配置工具, 添加别名 15-1-4>使用别名登录SSMS, 删除发布和订阅的方法如下 USE master go --查看订阅信息 exec sp_helpsubscriberinfo ; go --删除订阅 exec sp_dropsubscriber 'SubscriberName'; go use master go --查看发布数据库 exec sp_helpdistpublisher; go --删除发布数据库 exec sp_dropdistributiondb @database = N'distribution' go use master; go --查看发布服务器 exec sp_helpdistributor go --删除发布服务器 exec sp_dropdistributor @no_checks = 1, @ignore_distributor = 1 go 15-1-5>创建发布服务器 15-1-6>在另一台服务器上创建订阅服务器(可以使用推送订阅或者请求订阅, 压力分别在发布服务器或订阅服务器上.) 15-2>MySQL读写分离 15-3>EF Core实现 /// /// 主从拦截器 /// /// 只支持1主N从 public class MasterSlaveInterceptor : DbCommandInterceptor { /// /// 系统配置快照 /// private readonly IOptionsSnapshot _systemConfigOption = null; /// /// 构造函数 /// /// 系统配置快照 public MasterSlaveInterceptor(IOptionsSnapshot systemConfigOption) { _systemConfigOption = systemConfigOption; } #region 公共方法 /// /// 是否需要设置主从 /// /// private bool IsNeed2SetMasterSlave() { var systemConfig = _systemConfigOption?.Value; if (systemConfig == default) { return false; } var connectionStrings = systemConfig.DBConnectionStrings ?? new List(); if (connectionStrings.Count c.MasterSlaveRole == EnumMasterSlaveRole.Master) >= 1; var hasSlave = connectionStrings.Count(c => c.MasterSlaveRole == EnumMasterSlaveRole.Slave) >= 1; return hasMaster && hasSlave; } /// /// 设置主从 /// /// 命令对象 /// 是否切换到Master库, 默认false private void SetMasterSlave(DbCommand command, bool isChange2Master = false) { if (command == default) { return; } //判断是否需要设置主从 if (!IsNeed2SetMasterSlave()) { return; } var systemConfig = _systemConfigOption?.Value; if (systemConfig == default) { return; } var masterConnStr = systemConfig.DBConnectionStrings.FirstOrDefault(c => c.MasterSlaveRole == EnumMasterSlaveRole.Master)?.ConnectionString ?? \"\"; //切到主库 if (isChange2Master && command.Connection.ConnectionString != masterConnStr) { if (command.Connection.State != System.Data.ConnectionState.Closed) { command.Connection.Close(); } command.Connection.ConnectionString = masterConnStr.DeepClone(); if (command.Connection.State != System.Data.ConnectionState.Open) { command.Connection.Open(); } return; } //切到从库 var commandText = command.CommandText.DeepClone(); //判断是否为插入语句(EF 插入语句会通过Reader执行并查询主键), 若是insert语句, 则将连接字符串改为主库 if (commandText.ToLower().StartsWith(\"insert\", StringComparison.InvariantCultureIgnoreCase)) { if (command.Connection.State != System.Data.ConnectionState.Closed) { command.Connection.Close(); } command.Connection.ConnectionString = masterConnStr.DeepClone(); if (command.Connection.State != System.Data.ConnectionState.Open) { command.Connection.Open(); } return; } //判断当前会话是否处于分布式事务中 bool isDistributedTran = Transaction.Current != default && Transaction.Current.TransactionInformation.Status != TransactionStatus.Committed; //判断该 dbcontext 是否处于普通数据库事务中 bool isDbTran = command.Transaction != default; if (isDistributedTran || isDbTran) { return; } var dbSlaveStrategy = systemConfig.DBSlaveStrategy; var slaveConnStrList = ( from connectionString in ( systemConfig.DBConnectionStrings.Where(c => c.MasterSlaveRole == EnumMasterSlaveRole.Slave).ToList() ?? new List() ) select connectionString.ConnectionString ).ToList(); //TODO 使用指定策略, 获取从库连接串 var slaveConnStr = GetSlaveConnStr(slaveConnStrList, dbSlaveStrategy) ?? \"\"; if (!FramePublicFun.IsGlobalLogNull) { FramePublicFun.Logger?.LogInformation($\"slaveConnStr:{slaveConnStr}\"); } if (string.IsNullOrEmpty(slaveConnStr)) { return; } //将连接字符串切换到从库 if (command.Connection.State != System.Data.ConnectionState.Closed) { command.Connection.Close(); } command.Connection.ConnectionString = slaveConnStr.DeepClone(); if (command.Connection.State != System.Data.ConnectionState.Open) { command.Connection.Open(); } } /// /// 获取从库连接串 /// /// 从库连接串链表 /// 从库连接串获取策略 /// private string GetSlaveConnStr(List slaveConnStrList, EnumDBSlaveStrategy slaveStrategy = EnumDBSlaveStrategy.Random) { slaveConnStrList ??= new List(); var slaveConnStr = \"\"; switch (slaveStrategy) { case EnumDBSlaveStrategy.Random: default: var startIndex = 0; var endIndex = slaveConnStrList.Count; slaveConnStr = slaveConnStrList[FramePublicFun.GetRandomByGuid(startIndex, endIndex)] ?? \"\"; break; case EnumDBSlaveStrategy.IP: throw new NotImplementedException(slaveStrategy.ToString()); case EnumDBSlaveStrategy.Balance: throw new NotImplementedException(slaveStrategy.ToString()); } return slaveConnStr; } #endregion //如果是写入,则正常执行 public override InterceptionResult NonQueryExecuting(DbCommand command, CommandEventData eventData, InterceptionResult result) { SetMasterSlave(command, isChange2Master: true); return base.NonQueryExecuting(command, eventData, result); } public override ValueTask> NonQueryExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult result, CancellationToken cancellationToken = default) { SetMasterSlave(command, isChange2Master: true); return base.NonQueryExecutingAsync(command, eventData, result, cancellationToken); } public override InterceptionResult ReaderExecuting(DbCommand command, CommandEventData eventData, InterceptionResult result) { SetMasterSlave(command); return base.ReaderExecuting(command, eventData, result); } public override ValueTask> ReaderExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult result, CancellationToken cancellationToken = default) { SetMasterSlave(command); return base.ReaderExecutingAsync(command, eventData, result, cancellationToken); } public override InterceptionResult ScalarExecuting(DbCommand command, CommandEventData eventData, InterceptionResult result) { SetMasterSlave(command); return base.ScalarExecuting(command, eventData, result); } public override ValueTask> ScalarExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult result, CancellationToken cancellationToken = default) { SetMasterSlave(command); return base.ScalarExecutingAsync(command, eventData, result, cancellationToken); } } //注册拦截器 optionsBuilder.AddInterceptors(new MasterSlaveInterceptor(systemConfigOption: _systemConfigOption)); 16>EF日志 16-1>使用net core的日志框架(注入log4net) public static IHostBuilder CreateHostBuilder(string[] args) => Host.CreateDefaultBuilder(args) .ConfigureHostConfiguration(configurationBuilder=> { //设置主机配置文件所在目录 configurationBuilder.SetBasePath(FramePublicFun.GetDllPath()); //添加环境变量 configurationBuilder.AddEnvironmentVariables(prefix: SysContant.Setting_Prefix); //添加命令行参数 configurationBuilder.AddCommandLine((args ?? new string[] { })); }) .ConfigureAppConfiguration((hostBuilderContext, configurationBuilder) => { //清除 CreateDefaultBuilder(String[]) 方法中默认添加的所有的配置提供程序。 configurationBuilder.Sources.Clear(); //设置配置文件所在目录 configurationBuilder.SetBasePath(FramePublicFun.GetDllPath()); //设置内存中的 .NET 对象,放在最前面 configurationBuilder.AddInMemoryCollection(arrayDict); configurationBuilder.AddJsonFile(SysContant.Appsettings_FileName, optional: false, reloadOnChange: true); var appsettingsFileNameArr = SysContant.Appsettings_FileName.Split(new[] { \".\" }, StringSplitOptions.RemoveEmptyEntries) ?? new string[] { }; var appsettingsFileNamePrefix = appsettingsFileNameArr.Length != 2 ? \"appsettings\" : appsettingsFileNameArr[0]; var appsettingsFileNameExtension = appsettingsFileNameArr.Length != 2 ? \"json\" : appsettingsFileNameArr[1]; configurationBuilder.AddJsonFile ( $\"{appsettingsFileNamePrefix}.{hostBuilderContext.HostingEnvironment.EnvironmentName}.{appsettingsFileNameExtension}\", optional: true, reloadOnChange: true ); //添加环境变量 configurationBuilder.AddEnvironmentVariables(prefix: SysContant.Setting_Prefix); //添加命令行参数 configurationBuilder.AddCommandLine(args); }) .ConfigureLogging((context, loggingBuilder) => { loggingBuilder.ClearProviders(); loggingBuilder.SetMinimumLevel(LogLevel.Warning); loggingBuilder.AddFilter(\"System\", LogLevel.Information); loggingBuilder.AddFilter(\"Microsoft\", LogLevel.Information); //添加控制台日志 loggingBuilder.AddConsole(); /*第二种，在ConfigureLogging配置log4net begin*/ var cfgFilePath = Path.Combine(FramePublicFun.GetDllPath(), SysContant.Log4Net_CfgFileName); loggingBuilder.AddLog4Net(cfgFilePath); /*第二种，在ConfigureLogging配置log4net end*/ }) .ConfigureWebHostDefaults(webBuilder => { webBuilder.ConfigureKestrel((webHostBuilderContext, kestrelServerOptions) => { //置为null时，最大请求正文大小不受限制。 kestrelServerOptions.Limits.MaxRequestBodySize = null; }).UseStartup();//将ConfigureServices和Configure独立到Startup类中进行配置 }) .UseServiceProviderFactory(new AutofacServiceProviderFactory());//为了让主机能在Startup中调用ConfigureContainer //log4net.config --> --> --> --> --> /// /// 配置上下文 /// /// protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder .UseQueryTrackingBehavior(QueryTrackingBehavior.TrackAll) //默认设置跟踪所有查询 .EnableSensitiveDataLogging(sensitiveDataLoggingEnabled: _hostingEnvironment != null && _hostingEnvironment.IsDevelopment()) //启用敏感数据日志记录 .UseLoggerFactory(LoggerFactory); //设置日志工厂 } 16-2>使用EF自带的简单日志模式 /// /// 配置上下文 /// /// protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { //记录日志，包含生成的sql optionsBuilder .LogTo(msg => { //调试 - 窗口消息 System.Diagnostics.Debug.WriteLine(msg); //输出 - 窗口消息 Console.WriteLine(msg); }); } 16-3>通过拦截器实现SQL日志记录 public class DBlogCommandInterceptor : DbCommandInterceptor { //创建一个队列记录SQL执行时间 static readonly ConcurrentDictionary MStartTime = new ConcurrentDictionary(); private ILogger _logger { get; set; } //通过构造函数注入日志 public DBlogCommandInterceptor(ILogger Logger) { _logger = Logger; } //记录SQL开始执行的时间 private void OnStart(DbCommand command) { MStartTime.TryAdd(command, DateTime.Now); } 　　　　//通过_logger输出日志 private void Log(DbCommand command) { DateTime startTime; TimeSpan duration; //得到此command的开始时间 MStartTime.TryRemove(command, out startTime); if (startTime != default(DateTime)) { duration = DateTime.Now - startTime; } else { duration = TimeSpan.Zero; } var parameters = new StringBuilder(); //循环获取执行语句的参数值 foreach (DbParameter param in command.Parameters) { parameters.AppendLine(param.ParameterName + \" \" + param.DbType + \" = \" + param.Value); } _logger.LogInformation(\"{starttime}开始执行SQL语句:{sql},参数:{canshu},执行时间{readtime}\", startTime.ToString(), command.CommandText, parameters.ToString(), duration.TotalSeconds); } public override InterceptionResult NonQueryExecuting(DbCommand command, CommandEventData eventData, InterceptionResult result) { OnStart(command); return base.NonQueryExecuting(command, eventData, result); } public override Task> NonQueryExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult result, CancellationToken cancellationToken = default) { OnStart(command); return base.NonQueryExecutingAsync(command, eventData, result, cancellationToken); } public override int NonQueryExecuted(DbCommand command, CommandExecutedEventData eventData, int result) { Log(command); return base.NonQueryExecuted(command, eventData, result); } public override Task NonQueryExecutedAsync(DbCommand command, CommandExecutedEventData eventData, int result, CancellationToken cancellationToken = default) { Log(command); return base.NonQueryExecutedAsync(command, eventData, result, cancellationToken); } public override InterceptionResult ScalarExecuting(DbCommand command, CommandEventData eventData, InterceptionResult result) { OnStart(command); return base.ScalarExecuting(command, eventData, result); } public override Task> ScalarExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult result, CancellationToken cancellationToken = default) { OnStart(command); return base.ScalarExecutingAsync(command, eventData, result, cancellationToken); } public override object ScalarExecuted(DbCommand command, CommandExecutedEventData eventData, object result) { Log(command); return base.ScalarExecuted(command, eventData, result); } public override Task ScalarExecutedAsync(DbCommand command, CommandExecutedEventData eventData, object result, CancellationToken cancellationToken = default) { Log(command); return base.ScalarExecutedAsync(command, eventData, result, cancellationToken); } public override InterceptionResult ReaderExecuting(DbCommand command, CommandEventData eventData, InterceptionResult result) { OnStart(command); return base.ReaderExecuting(command, eventData, result); } public override Task> ReaderExecutingAsync(DbCommand command, CommandEventData eventData, InterceptionResult result, CancellationToken cancellationToken = default) { OnStart(command); return base.ReaderExecutingAsync(command, eventData, result, cancellationToken); } public override Task ReaderExecutedAsync(DbCommand command, CommandExecutedEventData eventData, DbDataReader result, CancellationToken cancellationToken = default) { Log(command); return base.ReaderExecutedAsync(command, eventData, result, cancellationToken); } public override DbDataReader ReaderExecuted(DbCommand command, CommandExecutedEventData eventData, DbDataReader result) { Log(command); return base.ReaderExecuted(command, eventData, result); } } 17>批量处理 EF Core官方未提供批量操作的功能, 包括批量新增, 修改, 删除, 都是拆分成一条条的记录进行操作, 性能非常低. 官方的解释是执行批量操作后无法跟踪实体状态. 使用zack的批量操作组件, 要注意不要在执行批量操作前, 从数据库加载实体到dbcontext, 如果真的有这样的需求, 则需要在执行批量操作后, 重新reload一次dbcontext, 保证dbcontext中的实体状态是正确的. 17-1>使用Zack EF批处理组件 https://github.com/yangzhongke/Zack.EFCore.Batch/blob/main/README_CN.md 17-2>使用步骤 *安装 //对于.NET 5用户： Postgresql: Install-Package Zack.EFCore.Batch.Npgsql SQLServer: Install-Package Zack.EFCore.Batch.MSSQL MySQL: Install-Package Zack.EFCore.Batch.MySQL.Pomelo Sqlite: Install-Package Zack.EFCore.Batch.Sqlite Oracle：Install-Package Zack.EFCore.Batch.Oracle //对于.NET 6用户: Postgresql: Install-Package Zack.EFCore.Batch.MSSQL_NET6 SQLServer：Install-Package Zack.EFCore.Batch.MSSQL_NET6 MySQL: Install-Package Zack.EFCore.Batch.MySQL.Pomelo_NET6 Postgresql: Install-Package Zack.EFCore.Batch.Npgsql_NET6 Sqlite: Install-Package Zack.EFCore.Batch.Sqlite_NET6 Oracle：因为Oracle暂时没有官方EF Core 6 Provider，所以暂未支持 *注册到DbContextOptionsBuilder optionsBuilder.UseBatchEF_MSSQL();// MSSQL Server 用户用这个 optionsBuilder.UseBatchEF_Npgsql();//Postgresql 用户用这个 optionsBuilder.UseBatchEF_MySQLPomelo();//MySQL 用户用这个 optionsBuilder.UseBatchEF_Sqlite();//Sqlite 用户用这个 optionsBuilder.UseBatchEF_Oracle();//Oracle 用户用这个 17-3>批量新增 //批量保存 var from = 0; var to = 100000; ConcurrentBag companies = new(); Parallel.For(from, to, i => { companies.Add(new Company { Name = $\"Name_{i}\", Address = $\"Address_{i}\", }); }); Stopwatch stopWatch = new(); using (var autoWatch = new AutoWatch(stopWatch)) { //EF方式, 执行to次insert操作() //await EFDbContext.Companies.AddRangeAsync(companies); //await EFDbContext.SaveChangesAsync(); //秒速插入 await EFDbContext.BulkInsertAsync(companies, null, SqlBulkCopyOptions.Default, cancellationToken); } var useTimeStr = $\"共花费 {stopWatch.Elapsed.Hours}:{stopWatch.Elapsed.Minutes}:{stopWatch.Elapsed.Seconds}.{stopWatch.Elapsed.Milliseconds}\"; 17-4>批量更新 ////EF方式 //var companies = await EFDbContext.Companies.Where(c => c.Id > 1467738743896151189).ToListAsync(); //foreach (var c in companies) //{ // c.LastUpdateIP = c.AddIP = \"127.0.0.1\"; //} //Stopwatch stopWatch = new(); //using (var autoWatch = new AutoWatch(stopWatch)) //{ // await EFDbContext.SaveChangesAsync(); //} //var useTimeStr = $\"共花费 {stopWatch.Elapsed.Hours}:{stopWatch.Elapsed.Minutes}:{stopWatch.Elapsed.Seconds}.{stopWatch.Elapsed.Milliseconds}\"; //Zack批量修改 Stopwatch stopWatch = new(); using (var autoWatch = new AutoWatch(stopWatch)) { await EFDbContext.BatchUpdate() .Set(c => c.AddIP, c => \"127.0.0.1\") .Set(c => c.LastUpdateIP, c => \"127.0.0.1\") .Where(c => c.Id >= 1467738743782903808) .ExecuteAsync(); } 17-5>批量删除 //批量删除 //var companies = await EFDbContext.Companies.Where(c => c.Id >= 1467745513242759168).ToListAsync(); //Stopwatch stopWatch = new(); //using (var autoWatch = new AutoWatch(stopWatch)) //{ // EFDbContext.RemoveRange(companies); // await EFDbContext.SaveChangesAsync(); //} //Zack批量删除 Stopwatch stopWatch = new(); using (var autoWatch = new AutoWatch(stopWatch)) { await EFDbContext.DeleteRangeAsync(c => c.Id >= 1467746850261045248, true, cancellationToken); //下面这种也可以 //await EFDbContext.Companies.Where(c => c.Id >= 1467746850261045248).DeleteRangeAsync(EFDbContext); } var useTimeStr = $\"共花费 {stopWatch.Elapsed.Hours}:{stopWatch.Elapsed.Minutes}:{stopWatch.Elapsed.Seconds}.{stopWatch.Elapsed.Milliseconds}\"; 18>表达式树 https://www.cnblogs.com/snailblog/p/11521043.html https://www.cnblogs.com/cmliu/p/13246185.html https://masuit.com/1741 https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/ https://docs.microsoft.com/zh-cn/dotnet/csharp/expression-trees https://www.zhihu.com/question/392350352/answer/1200192977 18-1>使用场景 代理类方法的构造(如AOP，gRpc，WebService中)，通过表达式树，构造委托执行要代理的方法 EF，MongoDB，自定义ORM等数据访问层过滤使用的Expression，最典型的就是针对IQueryable类型分页，排序的动态扩展 常用的Linq中AND,OR等Predicate加强的一些扩展 数学表达式，伪SQL代码的执行解析器的构造（这个比较底层） 18-2>VS表达式树可视化工具安装(测试的时候使用vs2019, 工具版本:1.7.115.0, 不支持Net Core 3.1以上框架) *ExpressionTreeVisualizer *ExpressionTreeVisualizer安装方法 18-3>操作运算符 Add 加法运算，如 a + b, ，不进行溢出检查，针对数值操作数。 AddAssign 加法复合赋值运算，如 (a += b), ，不进行溢出检查，针对数值操作数。 AddAssignChecked 加法复合赋值运算，如 (a += b), ，进行溢出检查，针对数值操作数。 AddChecked 加法运算，如 (a + b), ，进行溢出检查，针对数值操作数。 And 按位或逻辑 AND 操作，如 (a & b) AndAlso 在条件 AND 仅当第一个操作数的计算结果为才计算第二个操作数的操作 true。 它对应于 (a && b) AndAssign 按位或逻辑 AND 复合赋值运算，如 (a &= b) ArrayIndex 索引操作在一维数组中，如 array[index] ArrayLength 获取一维数组的长度，如操作 array.Length。 Assign 赋值运算，如 (a = b)。 Block 表达式的块, 小括号 (若需要执行多个表达式, 可以使用block包起来) Call 某个方法调用，如在 obj.sampleMethod() 表达式。 Coalesce 一个表示空合并操作，如节点 (a ?? b) Conditional 条件运算，如 a > b ? a : b 在 C# Constant 常量的值。 Convert 强制转换或转换操作中，如 (SampleType)obj C# 中 ConvertChecked 强制转换或转换操作中，如 (SampleType)obj C# 中 DebugInfo 调试信息。 Decrement 一元递减操作，如 (a - 1) C# 和 Visual Basic 中。 该对象 a 不应就地修改。 Default 默认值。 Divide 除法运算，如 (a / b), ，针对数值操作数。 DivideAssign 除的复合赋值运算，如 (a /= b), ，针对数值操作数。 Dynamic 动态操作。 Equal 一个表示相等比较，如节点 (a == b) ExclusiveOr 按位或逻辑 XOR 操作，如 (a ^ b) ExclusiveOrAssign 按位或逻辑 XOR 复合赋值运算，如 (a ^= b) Extension 扩展表达式。 Goto 一个\"转到\"表达式，如 goto Label GreaterThan \"大于\"比较，如 (a > b)。 GreaterThanOrEquals \"大于或等于\"比较，如 (a >= b)。 Increment 一元递增操作，如 (a + 1) Index 索引操作或访问不采用参数的属性的操作。 Invoke 操作调用的委托或 lambda 表达式，如 sampleDelegate.Invoke()。 IsFalse 一个 false 条件值。 IsTrue 一个 true 条件值。 Label 标签。 Lambda Lambda 表达式，如 a => a + a LeftShift 按位左移运算，如 (a LeftShiftAssign 按位左移复合赋值运算，如 (a LessThan \"小于\"比较，如 (a LessThanOrEqual \"小于或等于\"比较，如 (a ListInit 创建一个新的操作的 IEnumerable 对象，并对其进行初始化从列表中的元素，如 new List(){ a, b, c } Loop 一个循环，如 for 或 while。 MemberAccess 从一个字段或属性，如读取操作 obj.SampleProperty。 MemberInit 运算，创建一个新的对象并初始化一个或多个成员，如 new Point { X = 1, Y = 2 } Modulo 算术余数运算，如 (a % b) ModuloAssign 算术余数复合赋值运算，如 (a %= b) C# 中。 Multiply 乘法运算，如 (a * b), ，不进行溢出检查，针对数值操作数。 MultiplyAssign 乘法复合赋值运算，如 (a *= b), ，不进行溢出检查，针对数值操作数。 MultiplyAssignChecked 乘法复合赋值运算，如 (a *= b), ，，进行溢出检查，针对数值操作数。 MultiplyChecked 乘法运算，如 (a * b), ，，进行溢出检查，针对数值操作数。 Negate 算术求反运算，如 (-a)。 该对象 a 不应就地修改。 NegateChecked 算术求反运算，如 (-a), 进行溢出检查。 该对象 a 不应就地修改。 New 调用构造函数以创建新的对象，如操作 new SampleType()。 NewArrayBounds 创建一个新数组，其中每个维度的下限指定，如操作 new SampleType[dim1, dim2] NewArrayInit 操作，创建一个新的一维数组并对其进行初始化从列表中的元素，如 new SampleType[]{a, b, c} Not 按位求补或逻辑求反运算。 在 C# 中，则等同于 (~a) 整型和 (!a) 布尔值。 NotEqual 不相等比较，如 (a != b) 在 C# OnesComplement 一个二进制反码运算，如 (~a) C# 中。 Or 按位或逻辑 OR 操作，如 (a | b) OrAssign 按位或逻辑 OR 复合赋值运算，如 (a |= b) C# 中。 OrElse 短路条件 OR 操作，如 (a || b) Parameter 对参数或变量的表达式的上下文中定义的引用。 有关更多信息，请参见ParameterExpression。 PostDecrementAssign 一元后缀递减，如 (a--)。 该对象 a 应就地修改。 PostIncrementAssign 一元后缀递增，如 (a++)。 该对象 a 应就地修改。 Power 如引发数字进行幂运算的数学运算 (a ^ b) 在 Visual Basic 中。 PowerAssign 如引发数字进行幂运算的复合赋值运算 (a ^= b) 在 Visual Basic 中。 PreDecrementAssign 一元前缀递减，如 (--a)。 该对象 a 应就地修改。 PreIncrementAssign 一元前缀递增，如 (++a)。 该对象 a 应就地修改。 Quote 具有类型的常量值的表达式 Expression。 一个 Quote 节点可以包含对它所代表的表达式的上下文中定义的参数的引用。 RightShift 按位右移运算，如 (a >> b)。 RightShiftAssign 按位右移复合赋值运算，如 (a >>= b)。 RuntimeVariables 运行时变量的列表。 有关详细信息，请参阅RuntimeVariablesExpression。 Subtract 减法运算，如 (a - b), ，不进行溢出检查，针对数值操作数。 SubtractAssign 减法复合赋值运算，如 (a -= b), ，不进行溢出检查，针对数值操作数。 SubtractAssignChecked 减法复合赋值运算，如 (a -= b), ，，进行溢出检查，针对数值操作数。 SubtractChecked 算术减法运算，如 (a - b), ，，进行溢出检查，针对数值操作数。 Switch 一个切换操作，如 switch Throw 引发异常，如操作 throw new Exception()。 Try 一个 try-catch 表达式。 TypeAs 显式引用或装箱转换在其中 null 如果转换失败，如提供 (obj as SampleType) 在 C# 或 TryCast(obj, SampleType) 在 Visual Basic 中。 TypeEqual 确切类型测试。 TypeIs 一种类型测试，如 obj is SampleType 在 C# 或 TypeOf obj is SampleType 在 Visual Basic 中。 UnaryPlus 一元正运算，如 (+a)。 预定义的一元正运算的结果是操作数的值，但用户定义的实现可能有不寻常的结果。 Unbox 取消装箱值类型的操作，如 unbox 和 unbox.any MSIL 中的说明。 18-4>范例 /// /// (a,b,c) => (b*b+4*a*c)²-b /// /// /// private static double TestExpression2(double a, double b, double c) { var paramA = Expression.Parameter(typeof(double), \"a\"); var paramB = Expression.Parameter(typeof(double), \"b\"); var paramC = Expression.Parameter(typeof(double), \"c\"); var const4 = Expression.Constant(4D, typeof(double)); var pow = typeof(Math).GetMethod(nameof(Math.Pow), new[] { typeof(double), typeof(double) }); var multiplBB = Expression.Multiply(paramB, paramB); var multipl4A = Expression.Multiply(const4, paramA); var multipl4AC = Expression.Multiply(multipl4A, paramC); var addBB4AC = Expression.Add(multiplBB, multipl4AC); var blockLeft = Expression.Block ( addBB4AC ); var sqrExp = Expression.Call(pow, new Expression[] { blockLeft, Expression.Constant(2D, typeof(double)) }); var subB = Expression.Subtract(sqrExp, paramB); var lamdaExp = Expression.Lambda>(subB, new[] { paramA, paramB, paramC }); var func = lamdaExp.Compile(); var result = func(a, b, c); return result; } /// /// 构造循环表达式树 /// /// /// private static int TestLoopAndReturn(int count) { /* Func exp = count => { var i = 0; while (i > ( Expression.Block ( new ParameterExpression[] { paramCurIndex }, //引入变量 new Expression[] { Expression.Assign(paramCurIndex, Expression.Constant(0, typeof(int))), //i=0 loopExp //进入循环操作 } ), new[] { paramCount } ); var func = lamdaExp.Compile(); var result = func(count); return result; } /// /// 构造try catch表达式树 /// private static void TestTryCatch() { var exParam = Expression.Parameter(typeof(Exception), \"ex\"); var writeLine = typeof(Console).GetMethod(nameof(Console.WriteLine), new[] { typeof(string) }); var const1 = Expression.Constant(1, typeof(int)); var const0 = Expression.Constant(0, typeof(int)); var stringConcat = typeof(string).GetMethod(nameof(string.Concat), new[] { typeof(string), typeof(string) }); //PS: try和catch的表达式主体最后返回的内容要一致, 不然会报错. 比如使用Expression.Constant(null) var tryCatchFinallyExp = Expression.TryCatchFinally ( Expression.Block ( Expression.Divide ( const1, const0 ), Expression.Constant(null) ), Expression.Block ( Expression.Call(writeLine, new Expression[] { Expression.Constant(\"执行 finally 操作.\", typeof(string)) }) ), Expression.Catch ( exParam, Expression.Block ( Expression.Call(writeLine, new Expression[] { Expression.Call(stringConcat,new Expression[] { Expression.Constant(\"error msg: \",typeof(string)), Expression.Property(exParam, \"Message\") }) }), Expression.Constant(null) ) ) ); var lamdaExp = Expression.Lambda(tryCatchFinallyExp); lamdaExp.Compile()(); } /// /// student => /// /// private static StudentCopy CopyInstance() { var inType = typeof(Student); var outType = typeof(StudentCopy); var outPropertyInfos = outType.GetProperties(); //创建 student => ... 中的student参数 var stuParam = Expression.Parameter(typeof(Student), \"student\"); //创建new StudentCopy表达式树 var createOutExp = Expression.New(outType); //创建成员赋值表达式树 var memberBindings = new List(); outPropertyInfos.ToList().ForEach(outPropertyInfo => { //构造student.pro var outPropertyExp = Expression.Property(stuParam, inType.GetProperty(outPropertyInfo.Name)); //构造studentCopy.pro = student.pro MemberBinding memberBinding = Expression.Bind(outPropertyInfo, outPropertyExp); memberBindings.Add(memberBinding); }); //使用成员赋值表达式列表实例化对象 var memberInitExpression = Expression.MemberInit(createOutExp, memberBindings); var lambdaExp = Expression.Lambda>(memberInitExpression, new[] { stuParam }); var func = lambdaExp.Compile(); var student = new Student() { Id = 1, UserName = \"dylanxu\", Active = true }; var studentCopy = func(student); return studentCopy; } /// /// 测试过滤条件 /// /// private static List TestFilter() { //构造源数据 var students = new List { new Student { Id = 1, UserName = \"dylanxu\", Active = true, }, new Student { Id = 2, UserName = \"alancheng\", Active = true, }, new Student { Id = 3, UserName = \"aoniruan\", Active = true, }, new Student { Id = 4, UserName = \"expectwua\", Active = true, }, new Student { Id = 5, UserName = \"jasonlin\", Active = true, }, new Student { Id = 6, UserName = \"dd\", Active = true, }, new Student { Id = 7, UserName = \"dd\", Active = false, }, }; //构造查询条件 var condictionJArray = new JArray { //new JObject //{ // { SysContant.Condition_Field,\"UserName\" }, // { SysContant.Condition_Type,\"string\" }, // { SysContant.Condition_Format,\"\" }, // { SysContant.Condition_Relation,\"and\" }, // { SysContant.Condition_Value,\"a\" }, // { SysContant.Condition_Comparison,\"like\" }, //}, //new JObject //{ // { SysContant.Condition_Field,\"Id\" }, // { SysContant.Condition_Type,\"int\" }, // { SysContant.Condition_Format,\"\" }, // { SysContant.Condition_Relation,\"and\" }, // { SysContant.Condition_Value,\"1\" }, // { SysContant.Condition_Comparison,\">\" }, //}, //new JObject //{ // { SysContant.Condition_Field,\"Id\" }, // { SysContant.Condition_Type,\"int\" }, // { SysContant.Condition_Format,\"\" }, // { SysContant.Condition_Relation,\"and\" }, // { SysContant.Condition_Value,\"5,3\" }, // { SysContant.Condition_Comparison,\"between\" }, //}, //new JObject //{ // { SysContant.Condition_Field,\"Id\" }, // { SysContant.Condition_Type,\"int\" }, // { SysContant.Condition_Format,\"\" }, // { SysContant.Condition_Relation,\"and\" }, // { SysContant.Condition_Value,\"3,4,5\" }, // { SysContant.Condition_Comparison,\"in\" }, //}, //new JObject //{ // { SysContant.Condition_Field,\"Id\" }, // { SysContant.Condition_Type,\"int\" }, // { SysContant.Condition_Format,\"\" }, // { SysContant.Condition_Relation,\"and\" }, // { SysContant.Condition_Value,\"5\" }, // { SysContant.Condition_Comparison,\"not in\" }, //}, new JObject { { SysContant.Condition_Field,\"Id\" }, { SysContant.Condition_Type,\"int\" }, { SysContant.Condition_Format,\"\" }, { SysContant.Condition_Relation,\"and\" }, { SysContant.Condition_Value,\"1\" }, { SysContant.Condition_Comparison,\">\" }, }, //new JObject //{ // { SysContant.Condition_Field,\"Active\" }, // { SysContant.Condition_Type,\"bool\" }, // { SysContant.Condition_Format,\"\" }, // { SysContant.Condition_Relation,\"and\" }, // { SysContant.Condition_Value,\"true\" }, // { SysContant.Condition_Comparison,\"=\" }, //}, //new JObject //{ // { SysContant.Condition_Field,\"Active\" }, // { SysContant.Condition_Type,\"bool\" }, // { SysContant.Condition_Format,\"\" }, // { SysContant.Condition_Relation,\"or\" }, // { SysContant.Condition_Value,\"false\" }, // { SysContant.Condition_Comparison,\"=\" }, //}, }; var queryable = students.AsQueryable().Where(t => t.Id > 1); var queryableNew = CreateFilter(queryable, condictionJArray); //排序 var sortJArray = new JArray { new JObject { { SysContant.Condition_Field, \"UserName\" }, { SysContant.Sort_Direction, SysContant.Sort_Direction_asc }, }, new JObject { { SysContant.Condition_Field, \"Active\" }, { SysContant.Sort_Direction, SysContant.Sort_Direction_desc }, } }; queryableNew = CreateSort(queryableNew, sortJArray); var resultList = queryableNew.ToList(); return resultList; } /// /// 构造过滤条件 /// /// 实体类型 /// queryable /// ///[ /// { /// \"Field\": \"UserName\", /// \"Type\": \"string\", /// \"Format\": \"\", /// \"Relation\": \"and\", /// \"Value\": \"an\", /// \"Comparison\": \"like\" /// } ///] /// /// /// 不支持源字段是子查询/复杂查询的情况 /// /// private static IQueryable CreateFilter(IQueryable queryable, JArray condictionJArray) { if (queryable == default) { return queryable; } condictionJArray ??= new JArray(); if (condictionJArray.Count (JObject jObject, Expression finalExpression) { Expression expression = default; jObject ??= new JObject(); if (jObject.Count (SysContant.Condition_Field).TrimAll() ?? \"\"; var relation = jObject.GetVal(SysContant.Condition_Relation).TrimAll().ToLower() ?? \"\"; if (string.IsNullOrEmpty(relation)) { relation = \"and\"; } var comparison = jObject.GetVal(SysContant.Condition_Comparison).TrimAll().ToLower() ?? \"\"; var propertyInfo = instType.GetProperty(field); if (propertyInfo == default) { throw new ArgumentNullException(nameof(propertyInfo)); } //获取底层类型 var propertyUnderType = propertyInfo.PropertyType.GetUnderType(); //构造表达式 Expression proExp = proExp = Expression.Property(tParam, propertyInfo); //获取属性值 object value = jObject.GetVal(\"Value\"); //值不能为空 if (value == default) { throw new ArgumentNullException(nameof(value)); } Expression valParam = null; if (comparison != \"between\" && comparison != \"in\" && comparison != \"not in\") { //强制类型转换 value = FramePublicFun.ConvertType(value, propertyUnderType); valParam = Expression.Constant(value, propertyUnderType); } //若属性的类型不一致, 则说明属性的类型拥有底层类型 //拥有底层类型的属性, 需要通过GetValueOrDefault来获取实际值 if (propertyUnderType != propertyInfo.PropertyType) { //调用静态方法 var getValueOrDefaultMethod = propertyInfo.PropertyType.GetMethod(\"GetValueOrDefault\", new Type[] { }); proExp = Expression.Call(proExp, getValueOrDefaultMethod, new Expression[] { }); } //静态方法可以用这种表示 //若是字符串类型字段, 则提前构造Contains方法 //MethodInfo containsMethod = null; //Expression stringComparisonConst = null; //if (propertyUnderType == typeof(string)) //{ // containsMethod = propertyUnderType.GetMethod(\"Contains\", new[] { typeof(string), typeof(StringComparison) }); // stringComparisonConst = Expression.Constant(StringComparison.OrdinalIgnoreCase, typeof(StringComparison)); //} //静态方法也可以用这种表示 MethodInfo containsMethod = typeof(string).GetMethod(\"Contains\", new[] { typeof(string), typeof(StringComparison) }); Expression stringComparisonConst = Expression.Constant(StringComparison.OrdinalIgnoreCase, typeof(StringComparison)); switch (comparison) { case \"=\": case \"==\": case \"equal\": expression = Expression.Equal(proExp, valParam); break; case \"<>\": case \"!=\": case \"not equal\": expression = Expression.NotEqual(proExp, valParam); break; case \">\": case \"gt\": expression = Expression.GreaterThan(proExp, valParam); break; case \">=\": case \"ge\": expression = Expression.GreaterThanOrEqual(proExp, valParam); break; case \" DateTime.Parse(val)).ToArray(); Array.Sort(dateTimeValArr); val1 = dateTimeValArr[0]; val2 = dateTimeValArr[1]; } else { var decimalValArr = valueArr.Select(val => decimal.Parse(val)).ToArray(); Array.Sort(decimalValArr); //表达式树对类型非常敏感, 源字段类型是什么, 待比较的值就需要强制转成该类型 var realValArr = decimalValArr.Select(val => FramePublicFun.ConvertType(val.ToString(), propertyUnderType)).ToArray(); val1 = realValArr[0]; val2 = realValArr[1]; } expression = Expression.AndAlso ( Expression.GreaterThanOrEqual(proExp, Expression.Constant(val1, propertyUnderType)), Expression.LessThanOrEqual(proExp, Expression.Constant(val2, propertyUnderType)) ); } break; case \"in\": { value.ToString().Split(new[] { \",\" }, StringSplitOptions.RemoveEmptyEntries) .Select(val => FramePublicFun.ConvertType(val, propertyUnderType)) .ToList() .ForEach(valObj => { if (expression == null) { expression = Expression.Equal ( proExp, Expression.Constant(valObj, propertyUnderType) ); } else { expression = Expression.OrElse ( expression, Expression.Equal ( proExp, Expression.Constant(valObj, propertyUnderType) ) ); } }); //用括号包起来(经测试, 用不用Block, 结果都正确) expression = Expression.Block(expression); } break; case \"not in\": { value.ToString().Split(new[] { \",\" }, StringSplitOptions.RemoveEmptyEntries) .Select(val => FramePublicFun.ConvertType(val, propertyUnderType)) .ToList() .ForEach(valObj => { if (expression == null) { expression = Expression.NotEqual ( proExp, Expression.Constant(valObj, propertyUnderType) ); } else { expression = Expression.AndAlso ( expression, Expression.NotEqual ( proExp, Expression.Constant(valObj, propertyUnderType) ) ); } }); //用括号包起来(经测试, 用不用Block, 结果都正确) expression = Expression.Block(expression); } break; default: throw new ArgumentOutOfRangeException(nameof(comparison)); } //合并查询条件 if (finalExpression == default) { finalExpression = expression; } else { if (relation == \"and\") { finalExpression = Expression.AndAlso(finalExpression, expression); } else if (relation == \"or\") { finalExpression = Expression.OrElse(finalExpression, expression); } else { throw new ArgumentOutOfRangeException(nameof(relation)); } } return finalExpression; } #endregion //循环构造过滤条件 Expression finalExpression = default; condictionJArray.Cast().ToList().ForEach(jObject => { finalExpression = CreateFilterInner(jObject, finalExpression); }); var lambdaExp = Expression.Lambda>(finalExpression, new[] { tParam }); //下面这种方式会覆盖原来queryable的where, 不建议用 //可以直接使用queryable.Where拼接构造好的过滤条件, 生成新的Queryable //var returnQueryable = queryable.Where(lambdaExp); //下面这种方式, 会在之前的过滤条件上再加上新的where进行过滤 //CreateQuery需要使用Queryable.Where,Queryable.Select,Queryable.OrderBy等诸如此类的表达树对象, 否则会报错 var whereExp = Expression.Call ( typeof(Queryable), nameof(Queryable.Where), new[] { instType }, new Expression[] { queryable.Expression, lambdaExp //lambdaExp写也可以这样写, 不知道Expression.Quote有什么用 //Expression.Quote(lambdaExp) } ); var returnQueryable = queryable.Provider.CreateQuery(whereExp); return returnQueryable; } /// /// 构造Order By /// /// 实体类型 /// queryable /// ///[ /// { /// \"Field\": \"UserName\", /// \"Direction\": \"asc/desc\" /// } ///] /// /// /// 支持多字段同时排序, 按照orderbyJArry顺序, 第一个字段执行Queryable.OrderBy/Queryable.OrderByDescending, 后续字段执行Queryable.ThenBy/Queryable.ThenByDescending. /// /// private static IQueryable CreateSort(IQueryable queryable, JArray orderbyJArry) { if (queryable == default) { return queryable; } orderbyJArry ??= new JArray(); if (orderbyJArry.Count CreateSortInner(IQueryable queryable, JObject jObject, bool isFirst = false) { if (queryable == default) { return queryable; } jObject ??= new JObject(); if (jObject.Count (SysContant.Condition_Field) ?? \"\").TrimAll(); if (string.IsNullOrEmpty(field)) { throw new ArgumentNullException(nameof(field)); } var direction = jObject.GetVal(SysContant.Sort_Direction) ?? \"\"; direction = (string.IsNullOrEmpty(direction) ? \"asc\" : direction).TrimAll().ToLower(); var instType = typeof(T); var tParam = Expression.Parameter(instType, \"t\"); //构造参数 t=>t.Name var propertyInfo = instType.GetProperty(field); if (propertyInfo == default) { throw new ArgumentNullException(\"propertyInfo\"); } var proertyType = propertyInfo.PropertyType; //获取底层类型 var propertyUnderType = proertyType.GetUnderType(); //构造t.pro Expression proExp = Expression.Property(tParam, propertyInfo); //若属性的类型与底层类型不一致, 则说明属性类型为Nullable if (proertyType != propertyUnderType) { var getValueOrDefaultMethod = proertyType.GetMethod(\"GetValueOrDefault\", new Type[] { }); proExp = Expression.Call(proExp, getValueOrDefaultMethod, new Expression[] { }); } //构造lamda表达式 var lambdaExp = Expression.Lambda(proExp, new[] { tParam }); var methodName = \"\"; if (isFirst) { if (direction == SysContant.Sort_Direction_asc) { methodName = \"OrderBy\"; } else { methodName = \"OrderByDescending\"; } } else { if (direction == SysContant.Sort_Direction_asc) { methodName = \"ThenBy\"; } else { methodName = \"ThenByDescending\"; } } var orderbyExp = Expression.Call ( typeof(Queryable), methodName, new Type[] { typeof(T), propertyUnderType }, new Expression[] { queryable.Expression, lambdaExp } ); var returnQueryable = queryable.Provider.CreateQuery(orderbyExp); return returnQueryable; } #endregion var jObjectList = orderbyJArry.Cast().ToList(); for (var i = 0; i 18-5>表达式树拓展方法 18-5-1> 拓展多表达式合并 (TODO 还没看懂) public static class LambdaExtension { public static Expression> True() { return param => true; } public static Expression> False() { return param => false; } public static Expression> And(this Expression> first, Expression> second) { return first.Compose(second, Expression.AndAlso); } public static Expression> Or(this Expression> first, Expression> second) { return first.Compose(second, Expression.OrElse); } private static Expression Compose(this Expression first, Expression second, Func merge) { var map = first.Parameters .Select((f, i) => new { f, s = second.Parameters[i] }) .ToDictionary(p => p.s, p => p.f); var secondBody = PFTParameterExtension.ReplaceParameters(map, second.Body); return Expression.Lambda(merge(first.Body, secondBody), first.Parameters); } private class PFTParameterExtension : ExpressionVisitor { private readonly Dictionary map; public PFTParameterExtension() { } public PFTParameterExtension(Dictionary map) { this.map = map ?? new Dictionary(); } /// /// 替换参数 /// /// The map. /// The exp. /// Expression public static Expression ReplaceParameters(Dictionary map, Expression exp) { return new PFTParameterExtension(map).Visit(exp); } protected override Expression VisitParameter(ParameterExpression p) { ParameterExpression replacement; if (map != null && map.Count > 0 && map.TryGetValue(p, out replacement)) { p = replacement; } return base.VisitParameter(p); } } } 18-5-2>通过Expression表达式树，为EF Core找回AddOrUpdate方法 19>Mapster Mapster-docs (github文档) Mapster (C# 对象映射器) 19-1>拓展插件 Mapster.Async: 异步支持 Mapster.EFCore: EF Core支持 Mapster.DependencyInjection: 依赖注入支持 19-2>基本用法 //1>直接映射, 使用的全局配置TypeAdapterConfig.GlobalSettings //默认情况下，无需任何配置，Mapster会根据两个实体字段名称相同进行匹配。 var userDTO = user.Adapt(); //2>通过已存在的dto对象映射 UserDTO userDTO = new() { UserSex = \"Male\" }; userDTO = user.Adapt(userDTO); 19-3>配置 19-3-1>全部配置-TypeAdapterConfig.GlobalSettings, 作用于Adapt方法, 一般用于配置基类的映射以及公共的属性映射. NewConfig: 将会覆盖已存在的类型映射配置 ForType: 如果指定类型映射配置不存在，那它将创建一个新的映射，如果指定类型的映射配置已存在，那么它将会扩展已有的映射配置，而不是删除或替换已有的映射配置 TypeAdapterConfig.GlobalSettings .ForType() //.NewConfig() .NameMatchingStrategy(NameMatchingStrategy.IgnoreCase) //忽略属性名称的大小写 .IgnoreNullValues(true) //如果是属性是空值就排除属性映射 .Map(t => t.UserAge, t => t.Age, t => t.Age t.UserSex, t => t.Sex) //属性映射 .Ignore(t=>t.UserAge, t=>t.like) //忽略属性 //.IgnoreIf((src, desc) => src.Age == 18, desc => desc.Age)//如果年龄等于18岁就排除Age属性映射 //.IgnoreIf((src, desc) => src.Age == 18, \"Name\", \"Age\");//如果年龄等于18岁就排除Name、Age属性映射 //.IgnoreAttribute(typeof(ExcludeAttribute));//排除标记了ExcludeAttribute的属性映射 //.IgnoreNonMapped(true);//只映射Map指定的属性，其他属性都排除 .BeforeMapping(async (source, dest) => { await Console.Out.WriteLineAsync(\"BeforeMapping\"); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(source)); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(dest)); }) //映射前处理 .AfterMapping(async (source, dest) => { await Console.Out.WriteLineAsync(\"AfterMapping\"); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(source)); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(dest)); }); //映射后处理 var userDTO = user.Adapt(); 19-3-2>映射配置继承 TypeAdapterConfig.GlobalSettings.AllowImplicitSourceInheritance = false; //Mapster 默认会把 源类型的 映射配置 应用到 源类型的子类。 TypeAdapterConfig.GlobalSettings.AllowImplicitDestinationInheritance = true; //Mapster 默认不会把 目标类型的 映射配置 应用到 目标类型的子类。 //通过代码显示继承 //子类继承父类配置 TypeAdapterConfig .NewConfig() .Inherits(); //父类下发配置到子类 TypeAdapterConfig .NewConfig() .Include(); 19-3-3>配置实例 //1>直接new一个TypeAdapterConfig实例 var typeAdapterConfig = new TypeAdapterConfig(); typeAdapterConfig.Default .NameMatchingStrategy(NameMatchingStrategy.IgnoreCase) //忽略属性名称的大小写 .IgnoreNullValues(true) //如果是属性是空值就排除属性映射 .EnumMappingStrategy(EnumMappingStrategy.ByValue) //枚举属性映射策略 .PreserveReference(true); //2>从全局TypeAdapterConfig深度赋值一个新的配置实例 var typeAdapterConfig = TypeAdapterConfig.GlobalSettings.Clone(); typeAdapterConfig .ForType() .Map(t => t.UserSex, t => t.Sex) .Map(t => t.UserAge, t => t.Age); //3>上面的方式等同于下面的方法 var typeAdapterConfig = TypeAdapterConfig.GlobalSettings.Fork(config => { config .ForType() .Map(t => t.UserSex, t => t.Sex) .Map(t => t.UserAge, t => t.Age); }); //非常重要: 2>和3>都是深度复制, 不会影响到原有的配置, 只对当前作用域有效 19-4>映射器(Mapper) IMapper mapper = new Mapper(); var result = mapper.Map(source); //很多重构, 可以选择需要的 19-5>构建器(Builder) - 基本用不到 var dto = poco.BuildAdapter() .AddParameters(\"user\", this.User.Identity.Name) .AdaptToType(); var dto = mapper.From(poco) .AddParameters(\"user\", this.User.Identity.Name) .AdaptToType(); 19-6>Scan, Apply 映射配置应该只初始化并且只进行一次配置, 所以, 在编写代码时应该将映射配置和映射调用分开, 将映射配置放到程序的入口(Main, StartUp). public class MyRegister : IRegister { public void Register(TypeAdapterConfig config) { config.NewConfig(); //OR to create or enhance an existing configuration config.ForType(); } } //1>自动扫描程序集中继承了IRegister接口的类, 并将注入类中的配置 TypeAdapterConfig.GlobalSettings.Scan(assembly1, assembly2, assemblyN) 2>将获取到的IRegister对象注入到配置 var registers = container.GetExports(); config.Apply(registers); 19-7>Compile(配置编译) Mapster将在第一次调用映射时自动编译TypeAdapterConfig, 推荐在程序添加映射配置完成后调用一次 Compile方法, 可以快速验证映射配置中是否存在错误. 调用 Compile 方法前应该完成所有的映射配置，调用 Compile 方法之后配置实例就不允许添加/修改其它映射配置！ 19-8>属性成员映射例子 TypeAdapterConfig .NewConfig() .Map(dest => dest.FullName, src => string.Format(\"{0} {1}\", src.FirstName, src.LastName)); TypeAdapterConfig .NewConfig() .Map(dest => dest.Gender, // dest.Gender： Genders.Male 或 Genders.Female 枚举类型 src => src.GenderString); // src.GenderString： \"Male\" 或 \"Female\" 字符串类型 TypeAdapterConfig .NewConfig() .Map(dest => dest.FullName, src => \"Sig. \" + src.FullName, srcCond => srcCond.Country == \"Italy\") .Map(dest => dest.FullName, src => \"Sr. \" + src.FullName, srcCond => srcCond.Country == \"Spain\") .Map(dest => dest.FullName, src => \"Mr. \" + src.FullName); //非常重要: 可以针对属性类型进行配置, 这里会受到TwoWays的影响, 导致逻辑执行2次 TypeAdapterConfig.NewConfig() .AddDestinationTransform((string x) => x.Trim()); //映射私有成员 TypeAdapterConfig .NewConfig() .Map(\"PrivateDestName\", \"PrivateSrcName\"); //目标多级属性映射 TypeAdapterConfig.NewConfig() .Map(dest => dest.Child.Name, src => src.Name); //映射两个类型到一个类型 TypeAdapterConfig.NewConfig() .Map(dest => dest, src => src.Item1) .Map(dest => dest, src => src.Item2); //映射一个类型到两个类型 //https://github.com/rivenfx/Mapster-docs/blob/master/cn/Custom-mapping.md TypeAdapterConfig.NewConfig() .Map(poco => poco, dto => dto.SubDto); 19-9>属性命名约定 //1>设置源属性的名称 TypeAdapterConfig.NewConfig() .NameMatchingStrategy(NameMatchingStrategy.ConvertSourceMemberName(name => \"m_\" + name)); //2>设置目标属性的名称 TypeAdapterConfig.NewConfig() .NameMatchingStrategy(NameMatchingStrategy.ConvertDestinationMemberName(name => name.Replace(\"m_\", \"\"))); 19-10>映射双向绑定 如果需要 源到目标 和 目标到源 只进行一次配置, 那么可以使用 ToWays 方法。 TwoWays方法必须在配置映射之前进行调用, 否则在调用TwoWays方法之前的配置为单向映射配置, 之后的配置为双向映射配置. 19-11>构造函数映射 19-12>映射前处理&映射后处理 .BeforeMapping(async (source, dest) => { await Console.Out.WriteLineAsync(\"BeforeMapping\"); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(source)); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(dest)); }) //映射前处理 .AfterMapping(async (source, dest) => { await Console.Out.WriteLineAsync(\"AfterMapping\"); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(source)); await Console.Out.WriteLineAsync(FrameWork.Json.NewtonsoftSerializer.SerializeObject(dest)); }) //映射后处理 .PreserveReference(true); //允许映射循环引用 19-13>自定义类型的映射 var typeAdapterConfig = TypeAdapterConfig.GlobalSettings.Fork(config => { config .ForType() .TwoWays() .Map(t => t.UserSex, t => t.Sex) .Map(t => t.UserAge, t => t.Age); config .ForType, JObject>() .MapWith(dic => dic.Dic2JObject(), applySettings: true); }); 19-14>异步支持 //Mapster.Async config.NewConfig() .AfterMappingAsync(async (poco, dto) => { var userManager = MapContext.Current.GetService(); var user = await userManager.FindByIdAsync(poco.UserId); dto.UserName = user.Name; }); var dto = await poco.BuildAdapter() .AdaptToTypeAsync(); var dto = await _mapper.From(poco) .AdaptToTypeAsync(); 19-15>与EF Core集成 //Mapster.EFCore var destinations = context.Sources.ProjectToType().ToList(); var query = myDbContext.Customers.Where(...); _mapper.From(query) .ProjectToType(); 19-16>注意事项 *Mapster不能用于配置接口, 抽象类! 19-17>封装 /// /// 配置 POCO]]>DTO /// /// 使用Mapster实现 /// 服务集合 /// public static IServiceCollection AddTypeAdapterConfig(this IServiceCollection serviceCollection) { if (serviceCollection == default) { throw new ArgumentNullException(nameof(serviceCollection)); } //1>设置全局配置 TypeAdapterConfig.GlobalSettings.AllowImplicitSourceInheritance = true; //允许原类型子类使用父类映射配置 TypeAdapterConfig.GlobalSettings.AllowImplicitDestinationInheritance = true; //允许目标类型子类使用父类映射配置 //设置基类映射 TypeAdapterConfig.GlobalSettings .ForType() .TwoWays() .NameMatchingStrategy(NameMatchingStrategy.IgnoreCase) //忽略属性名称的大小写 .IgnoreNullValues(true) //如果是属性是空值就排除属性映射 .EnumMappingStrategy(EnumMappingStrategy.ByValue) //枚举属性映射策略 .AddDestinationTransform(DestinationTransform.EmptyCollectionIfNull) //若集合为null则返回空集合 .PreserveReference(true); //允许映射循环引用 //2>配置常用的额外类型 TypeAdapterConfig.GlobalSettings .ForType, JObject>() .MapWith(dic => dic.Dic2JObject()); TypeAdapterConfig.GlobalSettings .ForType>() .MapWith(jObject => jObject.JObject2Dic()); //TODO 后续有别的特殊类型映射在这里添加 //3>扫描程序集并注入配置(定位程序集中继承了IRegister的配置) TypeAdapterConfig.GlobalSettings.Scan(FramePublicFun.GetAssemblies(EnumDllType.Project).ToArray()); //4>全局配置直接编译配置, 编译后, 全局配置将无法再修改配置 TypeAdapterConfig.GlobalSettings.Compile(); return serviceCollection; } /// /// Register /// /// public void Register(TypeAdapterConfig config) { config .ForType() .TwoWays() .Map(t => t.money, t => t.Price); } //若有新的配置, 可以使用fork var typeAdapterConfig = TypeAdapterConfig.GlobalSettings.Fork(config => { config .ForType() //.Map(t => t.Price, t => t.money / 100) .Map(t => t.MSN, t => t.msn + \"_dylanxu\") .AfterMapping((source, dest) => { dest.Price = dest.Price / 10000; }); }); var carEntity = entity.Adapt(typeAdapterConfig); 20>仓储封装 Wei.Repository:基于EFCore3.0+Dapper 封装Repository, 实现UnitOfWork, 提供基本的CURD操作, 可直接注入泛型Repository, 也可以继承Repository, 重写CURD操作 封装后的组件: Dylan.DatabaseAccessor: 集成ShardingCore(分片), Dapper(处理复杂逻辑), Zack.EFCore.Batch.MSSQL(MSSQL的批处理), TSQL.Parser(解析TSQL), 后期还需要集成 Zack.EFCore.Batch.MySQL Dylan.DataBaseMigration: 用于数据库迁移动作 Dylan.BussinessLogicServices: 业务逻辑层封装, 集成了Mapster(Entity和DTO相互转换) 21>分表分库组件 - ShardingCore ShardingCore官方文档 sharding-core 博客园文章列表 sharding-core (github) 21-1>分表 分表流程(code first模式) 21-1-1>创建业务实体 namespace Dylan.ShardingTableTest.Entity { /// /// 订单 /// public class Order : BaseEntity { /// /// 订单编号 /// public virtual string Code { get; set; } = \"\"; ///// ///// 付款用户名称 ///// //public virtual string Payer { get; set; } /// /// 订单金额 /// public virtual decimal Money { get; set; } /// /// 订单状态 /// public virtual OrderStatusEnum OrderStatus { get; set; } = OrderStatusEnum.NoPay; /// /// 是否已删除 /// public virtual bool IsDelete { get; set; } = false; /// /// 顾客Id /// public virtual long CustomerId { get; set; } /// /// 客户 /// //public virtual Customer Customer { get; set; } } /// /// 订单状态 /// public enum OrderStatusEnum { NoPay = 1, Paying = 2, Payed = 3, PayFail = 4 } } namespace Dylan.ShardingTableTest.Entity { /// /// 顾客 /// public class Customer : BaseEntity { /// /// 名称 /// public string Name { get; set; } /// /// 区域 /// public string Area { get; set; } /// /// 是否已删除 /// public virtual bool IsDelete { get; set; } = false; /// /// 订单列表 /// //public virtual List Orders { get; set; } = new List { }; } } 21-1-2>创建实体配置对象 namespace Dylan.ShardingTableTest.EntityConfiguration { /// /// OrderConfig /// public class OrderConfig : IEntityTypeConfiguration { /// /// Configure /// /// public void Configure(EntityTypeBuilder builder) { //builder.ToTable(\"T_Order\");//.HasComment(\"订单表\"); builder.ToTable($\"{SysContant.DB_Table_Prefix}{nameof(Order)}\"); builder.HasIndex(t => t.Code).IsUnique(unique: true); builder.HasQueryFilter(t => !t.IsDelete); builder.Property(t => t.Code).HasColumnType(\"nvarchar(80)\").IsRequired(required: true);//.HasComment(\"编号\"); builder.Property(t => t.Money).HasColumnType(\"decimal(19,4)\").IsRequired(required: true);//.HasComment(\"金额\"); builder.Property(t => t.OrderStatus).HasColumnType(\"int\").IsRequired(required: true);//.HasComment(\"状态\"); //builder.Property(t => t.Payer).HasColumnType(\"nvarchar(50)\").IsRequired(required: true);//.HasComment(\"客户名称\"); builder.Property(t => t.IsDelete).HasColumnType(\"bit\").IsRequired(required: true);//.HasComment(\"是否已删除\"); builder.Property(t => t.CustomerId).HasColumnType(\"bigint\").IsRequired(required: true);//.HasComment(\"顾客Id\"); //builder // .HasOne(t => t.Customer) // .WithMany(t => t.Orders) // .HasForeignKey(t => t.CustomerId) // .OnDelete(DeleteBehavior.Cascade); } } } namespace Dylan.ShardingTableTest.EntityConfiguration { /// /// CustomerConfig /// public class CustomerConfig : IEntityTypeConfiguration { /// /// Configure /// /// public void Configure(EntityTypeBuilder builder) { //builder.ToTable(\"T_Customer\");//.HasComment(\"顾客表\"); builder.ToTable($\"{SysContant.DB_Table_Prefix}{nameof(Customer)}\"); builder.HasIndex(t => t.Name).IsUnique(unique: true); builder.HasQueryFilter(t => !t.IsDelete); builder.Property(t => t.Name).HasColumnType(\"nvarchar(50)\").IsRequired(required: true);//.HasComment(\"名称\"); builder.Property(t => t.Area).HasColumnType(\"nvarchar(50)\").IsRequired(required: true);//.HasComment(\"区域\"); builder.Property(t => t.IsDelete).HasColumnType(\"bit\").IsRequired(required: true);//.HasComment(\"是否已删除\"); } } } 21-1-3>创建分表的虚拟路由 *框架提供的默认路由没有int64类型的主键取模路由, 因此参考int32类型的主键取模, 创建一个int64类型的虚拟路由 using ShardingCore.Core.EntityMetadatas; using ShardingCore.Core.VirtualRoutes; using ShardingCore.Core.VirtualRoutes.TableRoutes.Abstractions; using System; using System.Collections.Generic; using System.Linq; using System.Linq.Expressions; namespace Dylan.ShardingTableTest.TableRoute { /// /// 分表字段为long的取模分表 /// /// public abstract class AbstractSimpleShardingModKeyLongVirtualTableRoute : AbstractShardingOperatorVirtualTableRoute where TEntity : class { /// /// 取模的值 /// protected readonly int Mod; /// /// 尾缀长度 /// protected readonly int TailLength; /// /// 填充的字符 /// protected readonly char PaddingChar; /// /// 构造函数 /// /// 尾缀长度 /// 取模的值 /// 填充的字符 /// protected AbstractSimpleShardingModKeyLongVirtualTableRoute(int tailLength, int mod, char paddingChar = '0') { if (tailLength /// 获取key值对应的尾缀 /// /// /// public override string ShardingKeyToTail(object shardingKey) { var shardingKeyLong = Convert.ToInt64(shardingKey); return Math.Abs(shardingKeyLong % Mod).ToString().PadLeft(TailLength, PaddingChar); } /// /// 获取所有尾缀 /// /// public override List GetAllTails() { return Enumerable.Range(0, Mod).Select(o => o.ToString().PadLeft(TailLength, PaddingChar)).ToList(); } /// /// 根据key值获取尾缀后, 再构造表达式 /// /// key值 /// 比较符 /// public override Expression> GetRouteToFilter(long shardingKey, ShardingOperatorEnum shardingOperator) { var t = ShardingKeyToTail(shardingKey); switch (shardingOperator) { case ShardingOperatorEnum.Equal: return tail => tail == t; default: { #if DEBUG Console.WriteLine($\"shardingOperator is not equal scan all table tail\"); #endif return tail => true; } } } } } using Dylan.ShardingTableTest.Entity; using ShardingCore.Core.EntityMetadatas; using ShardingCore.VirtualRoutes.Days; using ShardingCore.VirtualRoutes.Mods; using ShardingCore.VirtualRoutes.Months; using System; namespace Dylan.ShardingTableTest.TableRoute { /// /// 订单虚拟表路由 /// public class OrderVirtualTableRoute : AbstractSimpleShardingDayKeyDateTimeVirtualTableRoute { /// /// 是否按照时间自动创建分表 /// /// public override bool AutoCreateTableByTime() { return true; } /// /// 获取分表开始日期 /// /// /// public override DateTime GetBeginTime() { return new DateTime(2021, 12, 28); } /// /// 配置分表 /// /// /// public override void Configure(EntityMetadataTableBuilder builder) { builder .ShardingProperty(t => t.AddTime) //分表字段 .AutoCreateTable(autoCreate: false) //启动后是否自动创建表, 默认false .TableSeparator(\"_\"); //尾缀分隔符 } } /// /// 顾客虚拟路由 /// public class CustomerVirtualTableRoute : AbstractSimpleShardingModKeyLongVirtualTableRoute { /// /// 构造函数 /// public CustomerVirtualTableRoute() : base(2, 3) { } /// /// Configure /// /// builder /// public override void Configure(EntityMetadataTableBuilder builder) { builder .ShardingProperty(t => t.Id) //分表字段 .AutoCreateTable(autoCreate: false) //启动后是否自动创建表, 默认false .TableSeparator(\"_\"); //尾缀分隔符 } } } 21-1-4>创建DbContext using Dylan.FrameWork.SysAttribute; using Dylan.FrameWork.Utility; using Dylan.ShardingCoreTest.Entity; using Dylan.ShardingTableTest.Entity; using Microsoft.AspNetCore.Http; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.ChangeTracking; using ShardingCore.Core.VirtualRoutes.TableRoutes.RouteTails.Abstractions; using ShardingCore.Extensions; using ShardingCore.Sharding; using ShardingCore.Sharding.Abstractions; using System; using System.Collections.Generic; using System.Linq; using System.Net; using System.Net.NetworkInformation; using System.Net.Sockets; using System.Threading; using System.Threading.Tasks; namespace Dylan.ShardingTableTest.Repository { /// /// SysDbContext /// [DbInfo(schema:SysContant.DB_Schema_DBO)] public class CalcDbContext : AbstractShardingDbContext, IShardingTableDbContext { #region 属性 /// /// 请求上下文 /// private readonly IHttpContextAccessor _httpContextAccessor = null; /// /// RouteTail /// public IRouteTail RouteTail { get; set; } public virtual DbSet Orders { get; set; } public virtual DbSet Customers { get; set; } public virtual DbSet Persons { get; set; } public virtual DbSet Cars { get; set; } #endregion #region 构造函数 /// /// 构造函数 /// /// public CalcDbContext(DbContextOptions options) : base(options) { } #endregion #region OnConfiguring /// /// 配置上下文 /// /// protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { base.OnConfiguring(optionsBuilder); //注册批量操作组件(一定要在这里注册，不然zack组件抛异常) optionsBuilder.UseBatchEF_MSSQL(); } #endregion #region OnModelCreating /// /// OnModelCreating /// /// protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.ApplyConfigurationsFromAssembly(typeof(BaseEntity).Assembly); } #endregion #region 重写基类方法 /// /// Saves all changes made in this context to the database. /// This method will automatically call Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.DetectChanges /// to discover any changes to entity instances before saving to the underlying database. /// This can be disabled via Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.AutoDetectChangesEnabled. /// /// The number of state entries written to the database. public override int SaveChanges() { //设置基类通用字段值 SetBaseEntityFields(base.ChangeTracker); return base.SaveChanges(); } /// /// Saves all changes made in this context to the database. /// This method will automatically call Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.DetectChanges /// to discover any changes to entity instances before saving to the underlying database. /// This can be disabled via Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.AutoDetectChangesEnabled. /// Multiple active operations on the same context instance are not supported. Use /// 'await' to ensure that any asynchronous operations have completed before calling /// another method on this context. /// /// A System.Threading.CancellationToken to observe while waiting for the task to complete. /// A task that represents the asynchronous save operation. The task result contains the number of state entries written to the database. public override Task SaveChangesAsync(CancellationToken cancellationToken = default) { //设置基类通用字段值 SetBaseEntityFields(); //SetBaseEntityFields(base.ChangeTracker); return base.SaveChangesAsync(cancellationToken); } #endregion #region 方法 /// /// 设置基类通用字段值 /// private void SetBaseEntityFields() { if (this.ShardingDbContextExecutor == default) { return; } //分库dic var dataSourceDbContextDic = this.ShardingDbContextExecutor.GetCurrentDbContexts(); if (dataSourceDbContextDic == default) { return; } dataSourceDbContextDic.ToList().ForEach(kvPair => { //分表dic var dbContextDic = kvPair.Value.GetCurrentContexts(); if (dbContextDic == default) { return; } dbContextDic.ToList().ForEach(seperateTableContextKV => { SetBaseEntityFields(seperateTableContextKV.Value.ChangeTracker); }); }); } /// /// 设置基类通用字段值 /// /// 实体状态 /// private void SetBaseEntityFields(ChangeTracker changeTracker) { var baseEntity = typeof(BaseEntity); foreach (var entry in changeTracker.Entries()) { //若entry的基类不是BaseLogicEntity, 则pass if (!baseEntity.IsAssignableFrom(entry.Entity.GetType())) { continue; } SetBaseEntityFields(entry); } } /// /// 设置基类通用字段值 /// /// 实体状态 /// private void SetBaseEntityFields(EntityEntry entityEntry) { var now = DateTime.Now; var userId = 1470214131637424134L; var ip = GetIP(); var entityState = entityEntry.State; var propertyValues = entityEntry.CurrentValues; if (propertyValues == default) { return; } //设置属性值 void SetPropertyValues(PropertyValues propertyValues, Dictionary dic) { dic.ToList().ForEach(kvPair => { propertyValues[kvPair.Key] = kvPair.Value; }); } Dictionary dic = new() { { SysContant.Entity_Property_LastUpdateTime, now }, { SysContant.Entity_Property_LastUpdateUserId, userId }, { SysContant.Entity_Property_LastUpdateIP, ip }, }; if (entityState == EntityState.Added) { dic.Add(SysContant.Entity_Property_AddTime, now); dic.Add(SysContant.Entity_Property_AddUserId, userId); dic.Add(SysContant.Entity_Property_AddIP, ip); SetPropertyValues(propertyValues, dic); } else if (entityState == EntityState.Modified) { SetPropertyValues(propertyValues, dic); } else { //其他情况不处理 return; } } /// /// 获取IP地址 /// /// private string GetIP() { //获取本地IP string GetLocalIP() { return NetworkInterface .GetAllNetworkInterfaces() .Where(netWork => netWork.OperationalStatus == OperationalStatus.Up) .Select(netWork => netWork.GetIPProperties()) .OrderByDescending(pro => pro.GatewayAddresses.Count) .SelectMany(pro => pro.UnicastAddresses) .FirstOrDefault(ip => !IPAddress.IsLoopback(ip.Address) && (ip.Address.AddressFamily == AddressFamily.InterNetwork || ip.Address.AddressFamily == AddressFamily.InterNetworkV6)) ?.Address.ToString() ?? \"\"; } //获取客户端IP string GetRemoteIP() { return _httpContextAccessor.HttpContext.Connection.RemoteIpAddress?.ToString() ?? _httpContextAccessor.HttpContext.Request.Headers[\"X-Real-IP\"].FirstOrDefault() ?? \"\"; } var needHandleIPs = new[] { \"::1\" }; var ip = \"\"; bool isGetLocalIP; if (_httpContextAccessor == default) { ip = GetLocalIP(); isGetLocalIP = true; } else { ip = GetRemoteIP(); isGetLocalIP = false; } //获取的IP是否需要二次处理 if (needHandleIPs.Contains(ip)) { ip = isGetLocalIP ? GetRemoteIP() : GetLocalIP(); } return ip; } #endregion } } 21-1-5>注册和开启分表服务的类 using Castle.Core.Logging; using Dylan.FrameWork.Entity.SysConfig; using Dylan.FrameWork.SysAttribute; using Dylan.FrameWork.Utility; using Dylan.ShardingTableTest.TableRoute; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Diagnostics; using Microsoft.EntityFrameworkCore.Migrations; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; using Microsoft.Extensions.Options; using ShardingCore; using ShardingCore.Sharding; using ShardingCore.Sharding.Abstractions; using System; using System.Reflection; using Dylan.FrameWork.Extension; using System.Linq; using System.Collections.Generic; using ShardingCore.Sharding.ReadWriteConfigurations; using Microsoft.AspNetCore.Builder; using ShardingCore.Bootstrapers; using ShardingCore.TableExists; namespace Dylan.ShardingTableTest.Repository { /// /// 拓展分片 /// public static class ShardingCoreExtesion { #region 私有方法 /// /// 获取ConnectionString /// /// /// /// private static DBConnectionString GetConnStr(IServiceCollection services) where TDbContext : DbContext, IShardingDbContext { if (services == default) { throw new ArgumentNullException(\"services\"); } var serviceProvider = services.BuildServiceProvider(); var systemConfigOption = serviceProvider.GetService>() ?? throw new ArgumentNullException(\"IOptionsSnapshot\"); var systemConfig = systemConfigOption.Value ?? throw new ArgumentNullException(\"systemConfigOption.Value\"); var dbInfo = typeof(TDbContext).GetCustomAttribute(); var schema = (dbInfo == default ? SysContant.DB_Schema_DBO : dbInfo.Schema).TrimAll().ToLower(); var dbConnStr = systemConfig.DBConnectionStrings.FirstOrDefault(conn => conn.Schema.TrimAll().ToLower() == schema) ?? throw new Exception($\"Fail to find {schema} from {SysContant.Appsettings_FileName}.\"); return dbConnStr; } #endregion /// /// 注册分片服务 /// /// 服务集合 /// public static IServiceCollection AddShardingCore ( this IServiceCollection services ) where TDbContext: DbContext, IShardingDbContext { //获取数据库配置 var dbConnStr = GetConnStr(services); var dbName = dbConnStr.Name ?? \"DB0\"; var connectionString = dbConnStr.ConnectionString ?? throw new ArgumentNullException(\"dbConnStr.ConnectionString\"); var readDBs = dbConnStr.ReadDBs ?? new HashSet(); var builder = services.AddShardingDbContext ( (conn, optionsBuilder) => optionsBuilder.UseSqlServer(conn, optionsBuilder => { optionsBuilder .UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery) .MigrationsHistoryTable(tableName: $\"__{SysContant.DB_Table_Prefix}DBMigrationsHistory\"); }) .UseQueryTrackingBehavior(QueryTrackingBehavior.TrackAll) .UseLoggerFactory(FramePublicFun.LoggerFactory) //.LogTo(msg => //{ // //调试 - 窗口消息 // System.Diagnostics.Debug.WriteLine(msg); // //输出 - 窗口消息 // Console.WriteLine(msg); //}, LogLevel.Information, DbContextLoggerOptions.DefaultWithLocalTime) .ReplaceService>() .ReplaceService() //需要将zack组件注册到OnConfiguring里, 原因不明 //注册批量操作组件 //.UseBatchEF_MSSQL() ) .Begin(shardingCoreBeginOptions => { //是否需要在启动的时候创建分表了的表, 如果用code first, 可是将此设置为false shardingCoreBeginOptions.CreateShardingTableOnStart = true; //是否需要在启动的时候创建普通表(非分表的可以是分库的表但不能是分表的表), 只有当数据库是空的前提下或者没有数据库的前提下会自动创建数据库和普通表, 如果用code first, 可是将此设置为false shardingCoreBeginOptions.EnsureCreatedWithOutShardingTable = false; //是否自动跟踪实体, 结合UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery)一起用 //shardingCoreBeginOptions.AutoTrackEntity = true; //单次查询sharding-core允许使用的dbconnection数, 默认会加上1, 默认是cpu线程数 shardingCoreBeginOptions.MaxQueryConnectionsLimit = Environment.ProcessorCount; }) .AddShardingTransaction ( (connection, builder) => builder .UseSqlServer(connection) .UseLoggerFactory(FramePublicFun.LoggerFactory) .UseQueryTrackingBehavior(QueryTrackingBehavior.TrackAll) ) .AddDefaultDataSource ( dbName, connectionString ) .AddShardingTableRoute(shardingTableOptions => { shardingTableOptions.AddShardingTableRoute(); shardingTableOptions.AddShardingTableRoute(); }) .AddTableEnsureManager(sp => new SqlServerTableEnsureManager()); //若读库不为空, 则配置读写分离 if (readDBs.Count new Dictionary> { { dbName, readDBs } }, ReadStrategyEnum.Loop, defaultEnable: true, defaultPriority: 10, ReadConnStringGetStrategyEnum.LatestFirstTime).End(); } return services; } /// /// 启动分片服务 /// /// applicationBuilder /// public static IApplicationBuilder UseShardingCore(this IApplicationBuilder applicationBuilder) { if (applicationBuilder == default) { throw new ArgumentNullException(\"applicationBuilder\"); } applicationBuilder.ApplicationServices.GetRequiredService().Start(); return applicationBuilder; } } } 21-1-6>分表服务注册及启动 public void ConfigureServices(IServiceCollection services) { //... //注册分片服务(如果ef tools的migration使用当前项目来迁移的话,执行迁移的时候, 需要注释掉services.AddShardingCore和app.UseShardingCore(), 迁移完成后再放开. 建议另外建一个控制台程序专门用于migration操作.) services.AddShardingCore(); } public void Configure ( IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory, IHostApplicationLifetime appLifetime ) { //... app .UseShardingCore() //启动分片服务 } 21-1-7>Code First的其他类 using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Metadata; using Microsoft.EntityFrameworkCore.Migrations; using Microsoft.EntityFrameworkCore.Migrations.Operations; using ShardingCore.Helpers; using ShardingCore.Sharding.Abstractions; using System.Linq; namespace Dylan.ShardingTableTest.Repository { public class ShardingSqlServerMigrationsSqlGenerator : SqlServerMigrationsSqlGenerator where TShardingDbContext : DbContext, IShardingDbContext { public ShardingSqlServerMigrationsSqlGenerator(MigrationsSqlGeneratorDependencies dependencies, IRelationalAnnotationProvider migrationsAnnotations) : base(dependencies, migrationsAnnotations) { } protected override void Generate( MigrationOperation operation, IModel model, MigrationCommandListBuilder builder) { var oldCmds = builder.GetCommandList().ToList(); base.Generate(operation, model, builder); var newCmds = builder.GetCommandList().ToList(); var addCmds = newCmds.Where(x => !oldCmds.Contains(x)).ToList(); MigrationHelper.Generate(operation, builder, Dependencies.SqlGenerationHelper, addCmds); } } } using System; using System.Collections.Generic; using System.Diagnostics; using System.Diagnostics.CodeAnalysis; using System.Linq; using Dylan.FrameWork.Utility; using Microsoft.EntityFrameworkCore.ChangeTracking.Internal; using Microsoft.EntityFrameworkCore.Metadata; using Microsoft.EntityFrameworkCore.Migrations; using Microsoft.EntityFrameworkCore.Migrations.Internal; using Microsoft.EntityFrameworkCore.Migrations.Operations; using Microsoft.EntityFrameworkCore.Storage; using Microsoft.EntityFrameworkCore.Update; using Microsoft.EntityFrameworkCore.Update.Internal; using ShardingCore; using ShardingCore.Core.VirtualDatabase.VirtualTables; using ShardingCore.Core.VirtualRoutes.TableRoutes; namespace Dylan.ShardingTableTest.Repository { /// /// 处理生成脚本的外键约束错误 /// public class RemoveForeignKeyMigrationsModelDiffer : MigrationsModelDiffer { /// /// /// /// /// /// /// /// public RemoveForeignKeyMigrationsModelDiffer ( IRelationalTypeMappingSource typeMappingSource, IMigrationsAnnotationProvider migrationsAnnotations, IChangeDetector changeDetector, IUpdateAdapterFactory updateAdapterFactory, CommandBatchPreparerDependencies commandBatchPreparerDependencies ) : base(typeMappingSource, migrationsAnnotations, changeDetector, updateAdapterFactory, commandBatchPreparerDependencies) { } /// /// 移除虚拟表的外键 /// /// /// /// public override IReadOnlyList GetDifferences(IRelationalModel source, IRelationalModel target) { var sourceOperations = base.GetDifferences(source, target).ToList(); //sourceOperations.RemoveAll(x => x is AddForeignKeyOperation || x is DropForeignKeyOperation); var virtualTables = GetVirtualTablesViaDI();//GetVirtualTables(); //移除走虚拟路由的表的外键相关操作 sourceOperations.RemoveAll(t => { var isForeignKeyOperation = t is AddForeignKeyOperation || t is DropForeignKeyOperation; if (!isForeignKeyOperation) { return false; } var op = t as ITableMigrationOperation; if (op == default) { return false; } return virtualTables.Contains(op.Table); }); //移除 创建表操作中的 走虚拟表路由的表的 外键 foreach (var operation in sourceOperations.OfType()) { if (virtualTables.Contains(operation.Name)) { Console.WriteLine(operation.Name); operation.ForeignKeys?.Clear(); } } return sourceOperations; } /// /// 获取虚拟表名称 /// /// private List GetVirtualTables() { List virtualTableNames = new(); var assembly = this.GetType().Assembly; if (assembly == default) { return virtualTableNames; } var allTypeArr = assembly.GetTypes() ?? new Type[] { }; if (allTypeArr.Length { var result = typeof(IVirtualTableRoute).IsAssignableFrom(t); if (!result) { return result; } var baseType = t.BaseType; if (!baseType.IsGenericType) { return false; } var argArr = baseType.GetGenericArguments() ?? new Type[] { }; if (argArr == default || argArr.Length $\"{SysContant.DB_Table_Prefix}{t.BaseType.GetGenericArguments()[0].Name}\") .ToList() ?? new(); return virtualTableNames; } /// /// 通过依赖注入获取虚拟表 /// /// private List GetVirtualTablesViaDI() { List virtualTableNames = new(); try { //获取分表管理器 var virtualTableManager = ShardingContainer.GetService>(); if (virtualTableManager == default) { return virtualTableNames; } var virtualTables = virtualTableManager.GetAllVirtualTables(); if (virtualTableManager == default || virtualTables.Count vt.GetVirtualTableName()).ToList(); return virtualTableNames; } catch { return virtualTableNames; } } } } using Dylan.FrameWork.Utility; using Dylan.ShardingTableTest.TableRoute; using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Design; using Microsoft.EntityFrameworkCore.Diagnostics; using Microsoft.EntityFrameworkCore.Migrations; using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Logging; using ShardingCore; using ShardingCore.Bootstrapers; using System; using System.IO; using Dylan.FrameWork.Extension; using ShardingCore.TableExists; namespace Dylan.ShardingTableTest.Repository { /// /// 此类仅仅是为了给EF Core Tools做migration使用 /// public class ShardingDesignTimeDbContextFactory: IDesignTimeDbContextFactory { /// /// LoggerFactory /// public static readonly ILoggerFactory loggerFactory = LoggerFactory.Create(builder => { builder.AddFilter((category, level) => category == DbLoggerCategory.Database.Command.Name && level == LogLevel.Information).AddConsole(); }); /// /// 静态构造函数 /// static ShardingDesignTimeDbContextFactory() { var dbName = \"DB_MALL\"; var connectionString = \"Data Source=192.168.60.103,1433;Initial Catalog=Mall;Persist Security Info=True;User ID=sa;Password=sa,./0sa;MultipleActiveResultSets=true;\"; var services = new ServiceCollection(); services.AddShardingDbContext ( (conn, optionsBuilder) => optionsBuilder.UseSqlServer(conn, optionsBuilder => { optionsBuilder .UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery) .MigrationsHistoryTable(tableName: $\"__{SysContant.DB_Table_Prefix}DBMigrationsHistory\"); }) .UseQueryTrackingBehavior(QueryTrackingBehavior.TrackAll) .UseLoggerFactory(loggerFactory) .LogTo(msg => { //调试 - 窗口消息 System.Diagnostics.Debug.WriteLine(msg); //输出 - 窗口消息 Console.WriteLine(msg); }, LogLevel.Information, DbContextLoggerOptions.DefaultWithLocalTime) .ReplaceService>() .ReplaceService() //需要将zack组件注册到OnConfiguring里, 原因不明 //注册批量操作组件 //.UseBatchEF_MSSQL() ) .Begin(shardingCoreBeginOptions => { //是否需要在启动的时候创建分表了的表, 如果用code first, 可将此设置为false shardingCoreBeginOptions.CreateShardingTableOnStart = false; //是否需要在启动的时候创建普通表(非分表的可以是分库的表但不能是分表的表), 只有当数据库是空的前提下或者没有数据库的前提下会自动创建数据库和普通表, 如果用code first, 可是将此设置为false shardingCoreBeginOptions.EnsureCreatedWithOutShardingTable = false; //是否自动跟踪实体, 结合UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery)一起用 //shardingCoreBeginOptions.AutoTrackEntity = true; //单次查询sharding-core允许使用的dbconnection数, 默认会加上1, 默认是cpu线程数 shardingCoreBeginOptions.MaxQueryConnectionsLimit = Environment.ProcessorCount; }) .AddShardingTransaction ( (connection, builder) => builder .UseSqlServer(connection) .UseLoggerFactory(loggerFactory) .UseQueryTrackingBehavior(QueryTrackingBehavior.TrackAll) ) .AddDefaultDataSource ( dbName, connectionString ) .AddShardingTableRoute(shardingTableOptions => { shardingTableOptions.AddShardingTableRoute(); shardingTableOptions.AddShardingTableRoute(); }) .AddTableEnsureManager(sp => new SqlServerTableEnsureManager()) .End(); var cfgFilePath = Path.Combine(FramePublicFun.GetDllPath(), SysContant.Log4Net_CfgFileName); services.AddLogging(c => c.AddLog4Net(cfgFilePath, watch: true)); var buildServiceProvider = services.BuildServiceProvider(); ShardingContainer.SetServices(buildServiceProvider); buildServiceProvider.RegisterGlobalServiceProvider(); ShardingContainer.GetService().Start(); } /// /// CreateDbContext /// /// /// /// public CalcDbContext CreateDbContext(string[] args) { return ShardingContainer.GetService(); } } } 21-1-8>其他注意点 *ShardingCore支持分片动作(分表[单字段分表及多字段分表], 分库)及读写分离 *新的分表路由可以参考默认虚拟路由来修改，如分表字段Id(long)的虚拟路由 *分表不要使用属性导航/列表导航(查询就不用include), 可以设置外键属性, 在查询的时候, 自己关联查询分表(inner join/left join) *ShardingCore支持所有的第三方批处理组件, 可是执行非查询操作的时候, 需要通过 dbcontext.BulkShardingTableEnumerable / dbcontext.BulkShardingTableExpression 来获取实际的dbcontext, 再执行批处理动作 *ShardingCore执行普通表的操作, 会使用ef core原生方法, 对于分片表, 会使用自己的解析器 *ShardingCore的Code first模式, 针对于web项目, 建议独立创建一个console项目, 专门用于执行migration命令 *ShardingCore目前不支持事务的保存点, 以后会支持, 其他事务特性可以支持 *若是执行批量操作, 不管是不是分片的表, 都需要先获取实际的dbcontext, 再执行批量操作 21-1-9>例子 [HttpGet(\"CreateCustomerOrders/{count}\")] public async Task CreateCustomerOrders([FromRoute] int count, CancellationToken cancellationToken) { try { if (count 先删除数据 if (await _calcDbContext.Orders.AnyAsync()) { var orderCount = await _calcDbContext.Orders.CountAsync(cancellationToken); var allOrders = await _calcDbContext.Orders.ToListAsync(cancellationToken); //获取实际dbcontext Expression> func = t => true; var dbContexts = _calcDbContext.BulkShardingTableExpression(func); if (dbContexts.Any()) { dbContexts.ToList().ForEach(async dbContext => { await dbContext.DeleteRangeAsync(t => true, false, cancellationToken); //await dbContext.DeleteRangeAsync(); }); } } if (await _calcDbContext.Customers.AnyAsync()) { var customerCount = await _calcDbContext.Customers.CountAsync(cancellationToken); var allCustomers = await _calcDbContext.Customers.ToListAsync(cancellationToken); //获取实际dbcontext Expression> func = t => true; var dbContexts = _calcDbContext.BulkShardingTableExpression(func); if (dbContexts.Any()) { dbContexts.ToList().ForEach(async dbContext => { await dbContext.DeleteRangeAsync(t => true, false, cancellationToken); //await dbContext.DeleteRangeAsync(); }); } } //2>批量创建 ConcurrentBag customers = new(); ConcurrentBag orders = new(); Parallel.For(0, count, i => { var tuple = CreateCustomerOrder(FramePublicFun.GetRandomByGuid(1, 5)); customers.Add(tuple.Item1); tuple.Item2.ToList().ForEach(orders.Add); }); //仅分表 //批量插入customers var dbContextCustomerDic = _calcDbContext.BulkShardingTableEnumerable(customers); foreach (var kvPair in dbContextCustomerDic) { await kvPair.Key.BulkInsertAsync(kvPair.Value.ToList(), null, SqlBulkCopyOptions.Default, cancellationToken); } //批量插入orders var dbContextOrderDic = _calcDbContext.BulkShardingTableEnumerable(orders); foreach (var kvPair in dbContextOrderDic) { await kvPair.Key.BulkInsertAsync(kvPair.Value.ToList(), null, SqlBulkCopyOptions.Default, cancellationToken); } return Ok(new { Result = true }); } catch (Exception ex) { var errorMsg = ex.GetInnerExceptionMsg(); return Ok(new { errorMsg }); } } /// /// 批量修改 /// /// /// [HttpGet(\"BatchUpdate\")] public async Task BatchUpdate(CancellationToken cancellationToken) { try { //1>批量修改分片表 //1-1>Order var dbContexts = _calcDbContext.BulkShardingTableExpression(t => string.IsNullOrEmpty(t.AddIP)); dbContexts.ToList().ForEach(async dbContext => { await dbContext .BatchUpdate() .Set(t => t.AddIP, \"192.168.60.103\") .Set(t => t.LastUpdateIP, \"192.168.60.103\") .Where(t => string.IsNullOrEmpty(t.AddIP)) .ExecuteAsync(ignoreQueryFilters: false, cancellationToken: cancellationToken); }); //1-2>Customer dbContexts = _calcDbContext.BulkShardingTableExpression(t => string.IsNullOrEmpty(t.AddIP)); dbContexts.ToList().ForEach(async dbContext => { await dbContext .BatchUpdate() .Set(t => t.AddIP, \"192.168.60.103\") .Set(t => t.LastUpdateIP, \"192.168.60.103\") .Where(t => string.IsNullOrEmpty(t.AddIP)) .ExecuteAsync(ignoreQueryFilters: false, cancellationToken: cancellationToken); }); //2>批量修改非分片表 //Person dbContexts = _calcDbContext.BulkShardingTableExpression(t => string.IsNullOrEmpty(t.AddIP)); dbContexts.ToList().ForEach(async dbContext => { await dbContext .BatchUpdate() .Set(t => t.AddIP, \"192.168.60.103\") .Set(t => t.LastUpdateIP, \"192.168.60.103\") .Where(t => string.IsNullOrEmpty(t.AddIP)) .ExecuteAsync(ignoreQueryFilters: false, cancellationToken: cancellationToken); }); //Car dbContexts = _calcDbContext.BulkShardingTableExpression(t => string.IsNullOrEmpty(t.AddIP)); dbContexts.ToList().ForEach(async dbContext => { await dbContext .BatchUpdate() .Set(t => t.AddIP, \"192.168.60.103\") .Set(t => t.LastUpdateIP, \"192.168.60.103\") .Where(t => string.IsNullOrEmpty(t.AddIP)) .ExecuteAsync(ignoreQueryFilters: false, cancellationToken: cancellationToken); }); await Console.Out.WriteLineAsync(\"done\"); return Ok(new { Success = true }); } catch (Exception ex) { var errorMsg = ex.GetInnerExceptionMsg(); return Ok(new { errorMsg }); } } /// /// 处理非批量操作 /// [HttpGet(\"HandleNonBatchOperation\")] public async Task HandleNonBatchOperation(CancellationToken cancellationToken) { try { //1>分片对象 var customerOrder = CreateCustomerOrder(FramePublicFun.GetRandomByGuid(1, 10)); await _calcDbContext.AddAsync(customerOrder.Item1, cancellationToken); await _calcDbContext.AddRangeAsync(customerOrder.Item2, cancellationToken); //2>非分片对象 var personCar = CreatePersonCar(FramePublicFun.GetRandomByGuid(1, 4)); await _calcDbContext.AddAsync(personCar.Item1, cancellationToken); await _calcDbContext.AddRangeAsync(personCar.Item2, cancellationToken); var affectCount = await _calcDbContext.SaveChangesAsync(cancellationToken); return Ok(new { affectCount }); } catch (Exception ex) { var errorMsg = ex.GetInnerExceptionMsg(); return Ok(new { errorMsg }); } } /// /// 分片查询 /// /// cancellationToken /// [HttpGet(\"ShardingQuery\")] public async Task ShardingQuery(CancellationToken cancellationToken) { try { var cusId = 1476442124126917054L; ////1>两个分表inner join //var queryable = // _calcDbContext.Customers.AsNoTracking().TagWith(\"test sql c\") // .Where(c => c.Id >= cusId) // .Join // ( // _calcDbContext.Orders.AsNoTracking().TagWith(\"test sql o\"), // c => c.Id, // o => o.CustomerId, // (c, o) => new // { // CustomerId = c.Id, // c.Name, // c.Area, // OrderId = o.Id, // o.Code, // o.Money // } // ); //var resultlist = await queryable.Take(30).ToListAsync(); //2>两个分表left join //var queryable = // _calcDbContext // .Customers // .GroupJoin // ( // _calcDbContext.Orders, // c => c.Id, // o => o.CustomerId, // (c, os) => new { Customer = c, Orders = os } // ) // .SelectMany // ( // combination => combination.Orders.DefaultIfEmpty(), // (c, o) => // new // { // CustomerId = c.Customer.Id, // c.Customer.Name, // c.Customer.Area, // OrderId = o.Id, // o.Code, // o.Money // } // ) // .TagWith(\"my sql\"); //var resultlist = await queryable.OrderByDescending(obj => obj.CustomerId).Take(3).ToListAsync(); //var queryable = // from lc in _calcDbContext.Customers // join o in _calcDbContext.Orders // on lc.Id equals o.CustomerId into og // from ro in og.DefaultIfEmpty() // orderby lc.Id descending, ro.Id ascending // select new // { // CustomerId = lc.Id, // lc.Name, // lc.Area, // OrderId = ro.Id, // ro.Code, // ro.Money // }; //var queryable = // from lc in _calcDbContext.Persons // join o in _calcDbContext.Cars // on lc.Id equals o.PersonId into og // from ro in og.DefaultIfEmpty() // orderby lc.Id descending, ro.Id ascending // select new // { // PersonId = lc.Id, // lc.Name, // CarId = ro.Id, // MSN = ro.MSN, // ro.Price, // }; var queryable = _calcDbContext .Persons .GroupJoin ( _calcDbContext.Cars, c => c.Id, o => o.PersonId, (c, os) => new { Person = c, Cars = os } ) .SelectMany ( combination => combination.Cars.DefaultIfEmpty(), (c, o) => new { CustomerId = c.Person.Id, c.Person.Name, CarId = o.Id, MSN = o.MSN, o.Price, } ) .OrderByDescending(o => o.CustomerId).ThenBy(o => o.CarId) .TagWith(\"my sql\"); var resultList = await queryable.TagWith(\"test sql\").Take(3).ToListAsync(); return Ok(resultList); } catch (Exception ex) { var errorMsg = ex.GetInnerExceptionMsg(); return Ok(new { errorMsg }); } } /// /// 事务操作(分表) /// /// [HttpPost(\"TransactionOperationShardingTable\")] public async Task TransactionOperationShardingTable(CancellationToken cancellationToken) { using var transaction = _calcDbContext.Database.BeginTransaction(); try { //1>创建实体 var customerOrder = CreateCustomerOrder(1); var customer = customerOrder.Item1; await _calcDbContext.AddAsync(customer, cancellationToken); var affectCount = await _calcDbContext.SaveChangesAsync(cancellationToken); //设置回滚用的保存点 //await transaction.CreateSavepointAsync(\"SaveCustomer\", cancellationToken); //transaction.CreateSavepoint(\"SaveCustomer\"); //清空code, 确保order保存失败 var orders = customerOrder.Item2; foreach (var order in orders) { order.Code = null; } await _calcDbContext.AddRangeAsync(orders, cancellationToken); affectCount = await _calcDbContext.SaveChangesAsync(cancellationToken); transaction.Commit(); return Ok(new { affectCount }); } catch (Exception ex) { //await transaction.RollbackToSavepointAsync(\"SaveCustomer\",cancellationToken); //transaction.Commit(); var errorMsg = ex.GetInnerExceptionMsg(); return Ok(new { errorMsg }); } } 21-2>分库 21-3>分表分库 21-4>读写分离(参考21-1>) 22>EF监听器 23>性能专题 23-1>性能诊断 I>通过日志查看sql执行时间 Executed DbCommand (158ms) [Parameters=[@p1='?' (DbType = Int64), @p0='?' (Size = 30), @p2='?' (Size = 8) (DbType = Binary)], CommandType='Text', CommandTimeout='30'] SET NOCOUNT ON; UPDATE [CALC].[T_People] SET [Name] = @p0 WHERE [Id] = @p1 AND [Token] = @p2; SELECT [Token] FROM [CALC].[T_People] WHERE @@ROWCOUNT = 1 AND [Id] = @p1; II>将I>查询慢的语句, 拿到具体数据库的MSSM工具里, 用查询分析器查看执行计划, 实际问题实际处理, 如加(复合)索引等 III>通过事件计数器查看EF的相关数据 23-2>高效查询 I>合理使用索引: 若出现了慢速查询, 先用查询分析器查看执行计划, 若使用了全表扫描, 则创建索引解决. II>只投影需要的属性: 查询结果尽可能select需要用到的列. III>限制查询结果的数量: 各种查询条件 + 分页. IV>尽可能预先加载相关实体： //下面这种查询, 在每次循环blog.Posts, 都会执行sql查询post数据, 建议使用预加载 foreach (var blog in context.Blogs.ToList()) { foreach (var post in blog.Posts) { Console.WriteLine($\"Blog {blog.Url}, Post: {post.Title}\"); } } foreach (var blog in context.Blogs.Select(b => new { b.Url, b.Posts }).ToList()) { foreach (var post in blog.Posts) { Console.WriteLine($\"Blog {blog.Url}, Post: {post.Title}\"); } } V>对于不需要跟踪的实体的查询, 使用AsNoTracking/AsNoTrackingWithIdentityResolution. VI>对于非常复杂/影响性能的查询, 可以使用原生SQL查询. VII>能使用EF的异步方法, 尽量使用异步方法, 提供应用并发性. 23-3>高效更新 请参考17>批处理 24>其他知识/注意点 *SQL Server中的内置函数 (超详细讲解) *GUID主键注意点 *如何选择双向导航和单向导航 如果一张基础表(如T_User)被多次引用, 则可以只在多端配置引用导航, 在一端不用配置列表导航, 否则一端会有很多的列表导航. 其他形如订单主表, 订单从表这样的结构, 都可以使用双向导航. *配置1:N的套路 为了防止后续将双向导航改成单向导航, 请在在多端配置 HasOne().WithMany(). *IQueryable知识点 *可以通过IQueryable.ToQueryString()获取SQL var query = EFDbContext.Authors.OrderBy(a => a.Name).Take(2).Select(a => new { Name = EF.Functions.SQLServerStuff(a.Name, 1, 4, \"dylan\"), a.Code }); var sql = query.ToQueryString(); var resultList = await query.ToListAsync(); *不要在OnModelCreating配置实体关系, 将每个实体的配置独立成一个配置文件 //独立实体的配置文件 /// /// AuthorConfig /// public class AuthorConfig : IEntityTypeConfiguration { /// /// Configure /// /// public void Configure(EntityTypeBuilder modelBuilderEntity) { modelBuilderEntity.ToTable(\"T_Author\").HasComment(\"博主表\");//.HasKey(t => t.Id); modelBuilderEntity.HasIndex(t => t.Name).IsUnique(unique: true); modelBuilderEntity.HasIndex(t => t.Email); modelBuilderEntity.Property(t => t.Name).HasColumnType(\"nvarchar(80)\").HasComment(\"博主昵称\").IsRequired(required: true); modelBuilderEntity.Property(t => t.Code).HasColumnType(\"bigint\").HasMaxLength(80).HasComment(\"博主代号\").IsRequired(required: true); modelBuilderEntity.Property(t => t.BirthDate).HasColumnType(\"datetimeoffset(7)\").HasComment(\"出生日期\"); modelBuilderEntity.Property(t => t.Email).HasColumnType(\"varchar(100)\").HasComment(\"邮箱地址\"); modelBuilderEntity.Property(t => t.Tel).HasColumnType(\"varchar(50)\").HasComment(\"手机号\"); modelBuilderEntity.Property(t => t.CompanyName).HasColumnType(\"nvarchar(80)\").HasComment(\"公司\"); modelBuilderEntity.Property(t => t.Title).HasColumnType(\"nvarchar(50)\").HasComment(\"职位\"); modelBuilderEntity.Property(t => t.Hometown).HasColumnType(\"nvarchar(200)\").HasComment(\"家乡\"); modelBuilderEntity.Property(t => t.Address).HasColumnType(\"nvarchar(200)\").HasComment(\"家庭住址\"); modelBuilderEntity.Property(t => t.IsDeleted).HasColumnType(\"bit\").HasComment(\"是否被删除\").HasDefaultValue(false).IsRequired(required: true); modelBuilderEntity.HasQueryFilter(t => !t.IsDeleted); //配置假删除过滤条件 } } //dbcontext的OnModelCreating配置如下 /// /// 实体配置 /// /// protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); //设置上限文默认架构 if (!string.IsNullOrEmpty(Schema)) { modelBuilder.HasDefaultSchema(Schema); } //从程序集中加载配置 modelBuilder.ApplyConfigurationsFromAssembly(typeof(BaseLogicEntity).Assembly); } *N:N的两种配置方式 I>使用中间实体关联两个实体 /// /// 帖子表 /// public class Post : BaseLogicEntity { public Post() { } public virtual string Title { get; set; } public virtual string Content { get; set; } public virtual DateTimeOffset? ReleaseTime { get; set; } public virtual EnumPostStatus PostStatus { get; set; } = EnumPostStatus.Draft; public virtual bool? IsDelete { get; set; } = false; public virtual Guid BlogId { get; set; } public virtual Blog Blog { get; set; } } /// /// 帖子标签 /// public class Tag: BaseLogicEntity { public Tag() { } public virtual Guid AuthorId { get; set; } public virtual Author Author { get; set; } public virtual string Name { get; set; } } /// /// 帖子标签 /// public class PostTags : BaseLogicEntity { public PostTags() { } public virtual Guid PostId { get; set; } public virtual Guid TagId { get; set; } public virtual Post Post { get; set; } public virtual Tag Tag { get; set; } } /// /// Configure /// /// public void Configure(EntityTypeBuilder modelBuilderEntity) { modelBuilderEntity.ToTable(\"T_Post\").HasComment(\"帖子表\"); modelBuilderEntity.HasIndex(t => new { t.Title, t.ReleaseTime }); modelBuilderEntity.Property(t => t.Title).HasColumnType(\"nvarchar(100)\").HasComment(\"标题\").IsRequired(required: true); modelBuilderEntity.Property(t => t.Content).HasColumnType(\"nvarchar(max)\").HasComment(\"内容\"); modelBuilderEntity.Property(t => t.ReleaseTime).HasColumnType(\"datetimeoffset(7)\").HasComment(\"发布时间\"); modelBuilderEntity.Property(t => t.PostStatus).HasColumnType(\"int\").HasMaxLength(5).HasComment(\"帖子状态\").IsRequired(required: true); modelBuilderEntity.Property(t => t.IsDelete).HasColumnType(\"bit\").HasComment(\"是否删除(置于回收站)\").IsRequired(required: true); modelBuilderEntity.Property(t => t.BlogId).HasComment(\"博客Id\"); modelBuilderEntity.HasQueryFilter(t => !t.Blog.Author.IsDeleted); //配置Blog:Post(1:N) modelBuilderEntity .HasOne(t => t.Blog) .WithMany(t => t.Posts) .HasForeignKey(t => t.BlogId).IsRequired() .OnDelete(DeleteBehavior.Cascade); } /// /// Configure /// /// public void Configure(EntityTypeBuilder modelBuilderEntity) { modelBuilderEntity.ToTable(\"T_Tag\").HasComment(\"帖子标签\"); modelBuilderEntity.HasIndex(t => new { t.Name, t.AuthorId }).IsUnique(unique: true); modelBuilderEntity.Property(t => t.Name).HasColumnType(\"nvarchar(80)\").HasComment(\"名称\").IsRequired(required: true); modelBuilderEntity.Property(t => t.AuthorId).HasComment(\"博主Id\"); modelBuilderEntity.HasQueryFilter(t => !t.Author.IsDeleted); modelBuilderEntity .HasOne(t => t.Author) .WithMany() .HasForeignKey(t => t.AuthorId).IsRequired() .OnDelete(DeleteBehavior.NoAction); } /// /// Configure /// /// public void Configure(EntityTypeBuilder modelBuilderEntity) { modelBuilderEntity.ToTable(\"T_PostTags\").HasComment(\"帖子标签\").Ignore(t => t.Token); modelBuilderEntity.HasIndex(t => new { t.PostId, t.TagId }).IsUnique(unique: true); modelBuilderEntity.Property(t => t.PostId).HasComment(\"帖子Id\"); modelBuilderEntity.Property(t => t.TagId).HasComment(\"标签Id\"); modelBuilderEntity.HasQueryFilter(t => !t.Post.Blog.Author.IsDeleted); modelBuilderEntity.HasQueryFilter(t => !t.Tag.Author.IsDeleted); modelBuilderEntity .HasOne(t => t.Post) .WithMany() .HasForeignKey(t => t.PostId).IsRequired(required: true) .OnDelete(DeleteBehavior.Cascade); modelBuilderEntity .HasOne(t => t.Tag) .WithMany() .HasForeignKey(t => t.TagId).IsRequired(required: true) .OnDelete(DeleteBehavior.Cascade); } II>两个主表实体添加对方的List属性, 然后关系配置在任何一端都可以 public class Company : BaseLogicEntity { public Company() { } public virtual string Name { get; set; } public virtual string Address { get; set; } public virtual List Employees { get; set; } = new List(); } public class Employee : BaseLogicEntity { public Employee() { } public virtual string FullName { get; set; } public virtual string FamilyName { get; set; } public virtual string GivenName { get; set; } public virtual string Code { get; set; } public virtual List Companies { get; set; } = new List(); } /// /// CompanyConfig /// public class CompanyConfig : IEntityTypeConfiguration { /// /// Configure /// /// public void Configure(EntityTypeBuilder modelBuilderEntity) { modelBuilderEntity.ToTable(\"T_Company\").HasComment(\"公司表\"); modelBuilderEntity.HasIndex(t => t.Name).IsUnique(unique: true); modelBuilderEntity.Property(t => t.Name).HasColumnType(\"nvarchar(100)\").HasComment(\"名称\").IsRequired(required: true); modelBuilderEntity.Property(t => t.Address).HasColumnType(\"nvarchar(200)\").HasComment(\"地址\").IsRequired(required: false); } } /// /// EmployeeConfig /// public class EmployeeConfig : IEntityTypeConfiguration { /// /// Configure /// /// public void Configure(EntityTypeBuilder modelBuilderEntity) { modelBuilderEntity.ToTable(\"T_Employee\").HasComment(\"员工表\"); modelBuilderEntity.HasIndex(t => t.Code).IsUnique(unique: true); modelBuilderEntity.Property(t => t.FamilyName).HasColumnType(\"nvarchar(50)\").HasComment(\"姓\").IsRequired(required: true); modelBuilderEntity.Property(t => t.GivenName).HasColumnType(\"nvarchar(50)\").HasComment(\"名\").IsRequired(required: true); modelBuilderEntity.Property(t => t.FullName).HasComputedColumnSql(\"[FamilyName] + ' ' + [GivenName]\", stored: false); modelBuilderEntity.Property(t => t.Code).HasColumnType(\"nvarchar(30)\").HasComment(\"编号\").IsRequired(required: true); modelBuilderEntity.HasMany(t => t.Companies).WithMany(t => t.Employees).UsingEntity(j => j.ToTable(\"T_CompanyEmployees\")); } } *配置自引用关系(1:N) public class Company : BaseLogicEntity { public Company() { } public virtual string Name { get; set; } public virtual string Address { get; set; } #region //配置自引用 //public virtual string ParentId{get;set;} public virtual long? ParentId { get; set; } public virtual Company Parent { get; set; } public virtual List Children { get; set; } #endregion public virtual List Employees { get; set; } = new List(); } /// /// CompanyConfig /// public class CompanyConfig : IEntityTypeConfiguration { /// /// Configure /// /// public void Configure(EntityTypeBuilder modelBuilderEntity) { modelBuilderEntity.ToTable(\"T_Company\").HasComment(\"公司表\"); modelBuilderEntity.HasIndex(t => t.Name).IsUnique(unique: true); modelBuilderEntity.Property(t => t.Name).HasColumnType(\"nvarchar(100)\").HasComment(\"名称\").IsRequired(required: true); modelBuilderEntity.Property(t => t.Address).HasColumnType(\"nvarchar(200)\").HasComment(\"地址\").IsRequired(required: false); #region 配置自引用 //modelBuilderEntity.Property(t => t.ParentId).HasColumnType(\"varchar(50)\").IsRequired(required: false); modelBuilderEntity.Property(t => t.ParentId).HasColumnType(\"bigint\").IsRequired(required: false); modelBuilderEntity.HasOne(t => t.Parent).WithMany(t => t.Children).HasForeignKey(t => t.ParentId).OnDelete(DeleteBehavior.NoAction); #endregion } } *1:1, 1:N(自引用), N:N 的保存动作, 最稳妥的方式是将所有的实体都加到DbContext.XXX.Add(), 不过也可以通过一端, 将所有数据关联到一起后, 再Add到一端, EF也会将需要保存的其他实体一起insert到data base. var node1 = await EFDbContext.Companies.FirstOrDefaultAsync(c => c.Name == \"中机租投资咨询有限公司\"); if (node1 == null) { node1 ??= new Company { Name = \"中机租投资咨询有限公司\", Address = \"深圳\" }; } var rootNode = new Company { Name = \"中国飞机租赁\", Address = \"香港\", }; var node2 = new Company { Name = \"ARI\", Address = \"天津\", }; var node3 = new Company { Name = \"中龙飞机拆解\", Address = \"哈尔滨\", Employees = new List { new Employee { FamilyName = \"Martin\", GivenName = \"Qin\", Code = \"5\" }, new Employee { FamilyName = \"Amy\", GivenName = \"Song\", Code = \"6\" }, } }; //只保存根节点, EF会自动解析其他节点实体 rootNode.Children.AddRange(new Company[] { node1, node2, node3 }); await EFDbContext.Companies.AddAsync(rootNode, cancellationToken); var result = await EFDbContext.SaveChangesAsync(cancellationToken); *上下文实体状态 Detached(已分离): DbContext未跟踪该实体. Added(已添加): DbContext正在追踪此实体, 但数据库中尚未存在该实体. Unchanged(未改变): DbContext正在跟踪该实体, 该实体存在于数据库中, 其属性值和从数据库中读取到的值一致, 未发生改变. Modified(已修改): DbContext正在跟踪该实体, 该实体存在于数据库中, 并且其部分或全部属性值已修改. Deleted(已删除): DbContext正在跟踪该实体, 该实体存在于数据库中,, 但在下次调用SaveChanges时要从数据库中删除对应数据. var company = new Company { Name = \"中机租投资咨询有限公司\", Address = \"深圳\", }; var employees = new List { new Employee { FamilyName = \"许\", GivenName = \"少峰\", Code = \"1\" }, new Employee { FamilyName = \"吴\", GivenName = \"彪\", Code = \"2\" }, new Employee { FamilyName = \"成\", GivenName = \"庚能\", Code = \"3\" }, new Employee { FamilyName = \"阮\", GivenName = \"毅文\", Code = \"4\" }, }; company.Employees = employees; //add到上下文前查看状态 - detached var entry = EFDbContext.Entry(company); var state = entry.State; var longView = entry.DebugView.LongView; EFDbContext.Companies.Add(company); //add到上下文后查看状态 - added state = entry.State; longView = entry.DebugView.LongView; var result = await EFDbContext.SaveChangesAsync(cancellationToken); //save到database后查看状态 - unchanged state = entry.State; longView = entry.DebugView.LongView; *不需要执行查询, 直接删除/修改记录的方法 EF常规的更新/删除操作, 都需要先查询实体后, 再进行相应的动作, 下面演示一个可以绕过查询的方法(实际工作如非必要, 千万不要使用此方法, 不然会导致上下文实体状态跟踪紊乱). PS: 如果使用了并发令牌, 则这个方式就更不适用了. /* //常规修改方式 //var rootCompany = await EFDbContext.Companies.Include(c => c.Children).FirstOrDefaultAsync(c => c.Parent == null); //rootCompany.Name += \"集团\"; //var result = await EFDbContext.SaveChangesAsync(cancellationToken); */ //另类修改方式 (因为实体使用了并发令牌, 所以手动赋值Token, 正常需求不会这么搞的) var rootNode = new Company { Id = 1467677806254231552, Name = \"中国飞机租赁 ltd\", Address = \"HK\", Token = new byte[8] { 0, 0, 0, 0, 0, 1, 195, 199 } }; //更新所有字段(除了导航属性, 并发令牌等) var entry = EFDbContext.Entry(rootNode); entry.State = EntityState.Modified; _ = entry.DebugView.LongView; //查看生成的SQL会发现, EF Core只生成了一条update的SQL语句 var result = await EFDbContext.SaveChangesAsync(); //还可以指定修改的列 var entry = EFDbContext.Entry(rootNode); entry.Property(\"Name\").IsModified = true; entry.Property(\"Address\").IsModified = true; var result = await EFDbContext.SaveChangesAsync(); /* //常规删除方式 var node = await EFDbContext.Companies .Include(c => c.Parent) .Include(c => c.Children) .FirstOrDefaultAsync(c => c.Name == \"中龙飞机拆解\"); EFDbContext.Companies.Remove(node); var result = await EFDbContext.SaveChangesAsync(cancellationToken); */ //另类删除方式 var rootNode = new Company { Id = 1467677806254231552, Name = \"中国飞机租赁 ltd\", Address = \"HK\", Token = new byte[8] { 0, 0, 0, 0, 0, 1, 195, 200 } }; //只生成Delete语句 var entry = EFDbContext.Entry(rootNode); entry.State = EntityState.Deleted; _ = entry.DebugView.LongView; var result = await EFDbContext.SaveChangesAsync(); *IQueryable可以叠加复用 这个特点可以实现设置根查询后, 根据外部传入的不同参数, 可以构造不同的查询结果. var query = EFDbContext.Companies.Where(c => !string.IsNullOrEmpty(c.Name)); var query2 = query.Where(c => c.Id > 1467750884044838340); var list = await query2.ToListAsync(cancellationToken); *IQueryable内部调用的DataReader读取数据 优点: 节省客户端内存. 缺点: 如果每条记录的处理时间比较长, 会长时间占用链接. *IQueryable的ToArray(), ToList()等 可以将数据一次性加载到内存. *何时需要一次性加载数据到内存 遍历IQueryable并且每条记录的处理时间比较长; 如果方法需要返回执行结果, 并且在方法里销毁了dbcontext, 需要一次性加载查询结果; 多个IQueryable的嵌套使用, 实质是多个DataReader同时执行, 很多数据库是不支持的, 只有SQL支持(连接字符串加入 MultipleActiveResultSets=true); *动态判断需要执行Add或者Update /// /// 判断当前实体执行add或者update /// /// /// 情景1: 由一个dbcontext查询的实体, 在另一个dbcontext里执行修改操作, 就需要用此方法判断, 上下文无法跟踪 /// 情景2: 没有用dbcontext查询实体, 自己new出来的, 也需要用此方法判断. /// /// /// /// /// /// public async Task AddOrUpdateAsync(T entity, CALCDbContext dbContext, CancellationToken cancellationToken = default) { if (entity == null) { throw new ArgumentNullException(\"entity\"); } if (dbContext == default) { throw new ArgumentNullException(\"dbContext\"); } var entityType = typeof(T); var id = FramePublicFun.GetPropertyValue(entity, SysContant.Entity_Property_Id); var dbEntity = dbContext.Find(entityType, new object[] { id }); var isExistInDB = dbEntity != null; EntityEntry entityEntry = null; if (isExistInDB) { entityEntry = dbContext.Entry(dbEntity); entityEntry.CurrentValues.SetValues(entity); } else { entityEntry = await dbContext.AddAsync(entity, cancellationToken); } return entityEntry; } //处理主从记录(硬编码) public static void InsertOrUpdateGraph(BloggingContext context, Blog blog) { var existingBlog = context.Blogs .Include(b => b.Posts) .FirstOrDefault(b => b.BlogId == blog.BlogId); if (existingBlog == null) { context.Add(blog); } else { context.Entry(existingBlog).CurrentValues.SetValues(blog); foreach (var post in blog.Posts) { var existingPost = existingBlog.Posts .FirstOrDefault(p => p.PostId == post.PostId); if (existingPost == null) { existingBlog.Posts.Add(post); } else { context.Entry(existingPost).CurrentValues.SetValues(post); } } } context.SaveChanges(); } //非硬编码, 可是功能有bug /// /// 执行add或者update, 级联操作列表导航属性. 约定实体继承于BaseLogicEntity, 实体的主键统一为Id, 列表导航属性类型为List<> /// (此功能有bug, 以后再修复) /// /// /// 情景1: 由一个dbcontext查询的实体, 在另一个dbcontext里执行修改操作, 就需要用此方法判断, 上下文无法跟踪 /// 情景2: 没有用dbcontext查询实体, 自己new出来的, 也需要用此方法判断. /// /// 待保存的(主表)实体 /// (主表)实体 /// db上下文 /// cancellationToken /// 是否自动执行SaveChangesAsync, 默认true /// public async Task AddOrUpdateAsync ( object entity, Type entityType, CALCDbContext dbContext, CancellationToken cancellationToken = default, bool isExecuteSaveChanges = true ) { if (entity == null) { throw new ArgumentNullException(\"entity\"); } if (dbContext == default) { throw new ArgumentNullException(\"dbContext\"); } //判断DB是否存在当前实体 var id = FramePublicFun.GetPropertyValue(entity, SysContant.Entity_Property_Id); var dbEntity = dbContext.Find(entityType, new object[] { id }); var isExistInDB = dbEntity != null; EntityEntry entityEntry = null; if (isExistInDB) { //若存在, 则用 entityEntry = dbContext.Entry(dbEntity); entityEntry.CurrentValues.SetValues(entity); } else { //若是新增, 即使有列表导航属性也不用处理 entityEntry = await dbContext.AddAsync(entity, cancellationToken); //return; } //获取当前实体所有列表导航属性 //泛型, 基类型继承于IEnumerable<> //T类型只有1个, 且继承于BaseLogicEntity var pType = typeof(IEnumerable<>); var baseType = typeof(BaseLogicEntity); var navigateProList = (entityType.GetProperties() ?? new PropertyInfo[] { }).Where(p => { var proType = p.PropertyType; var result = pType.IsAssignableFromGeneric(proType); if (!result) { return false; } var genericArguments = proType.GetGenericArguments() ?? new Type[] { }; if (genericArguments.Length != 1) { return false; } var tType = genericArguments.Single(); return baseType.IsAssignableFrom(tType); }).ToList() ?? new List(); if (navigateProList.Count ; var subEntitiesInFront = pro.GetValue(entity, null) as IEnumerable; var subEntities = CombineEntities(subEntitiesInFront, subEntitiesInDB); foreach (var subEntity in subEntities) { var subEntityType = subEntity.GetType(); await AddOrUpdateAsync(subEntity, subEntityType, dbContext, cancellationToken, isExecuteSaveChanges); } } if (isExecuteSaveChanges) { await dbContext.SaveChangesAsync(cancellationToken); //重新载入当前实体的db值 await entityEntry.ReloadAsync(cancellationToken); //EFDbContext.ChangeTracker.DetectChanges(); } } /// /// 合并前后端实体 /// /// 前端实体集合 /// DB实体集合 /// private IEnumerable CombineEntities(IEnumerable frontEntities, IEnumerable dbEntities) { IEnumerable entities = null; if (frontEntities == default && dbEntities == default) { return entities; } if (frontEntities == default) { entities = dbEntities; } else if (dbEntities == default) { entities = frontEntities; } else { //根据Id判断实体是否相同 //front有, db没有 var onlyFrontEntities = frontEntities.Where(frontE => dbEntities.All(dbE => !dbE.Equals(frontE))).AsEnumerable(); //db有, front没有 var onlyDbEntities = dbEntities.Where(dbE => frontEntities.All(frontE => !frontE.Equals(dbE))).AsEnumerable(); //front有, db也有 var bothEntities = frontEntities.Where(frontE => dbEntities.Any(dbE => dbE.Equals(frontE))).AsEnumerable(); //合并集合 entities = onlyFrontEntities.Union(onlyDbEntities).Union(bothEntities).AsEnumerable(); } return entities; } *设置基类的公共字段值 实现逻辑: 在继承了DbContext的类中, 重写SaveChanges, SaveChangesAsync. #region 重写基类方法 /// /// Saves all changes made in this context to the database. /// This method will automatically call Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.DetectChanges /// to discover any changes to entity instances before saving to the underlying database. /// This can be disabled via Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.AutoDetectChangesEnabled. /// /// The number of state entries written to the database. public override int SaveChanges() { //设置基类通用字段值 SetBaseEntityFields(base.ChangeTracker); return base.SaveChanges(); } /// /// Saves all changes made in this context to the database. /// This method will automatically call Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.DetectChanges /// to discover any changes to entity instances before saving to the underlying database. /// This can be disabled via Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.AutoDetectChangesEnabled. /// Multiple active operations on the same context instance are not supported. Use /// 'await' to ensure that any asynchronous operations have completed before calling /// another method on this context. /// /// A System.Threading.CancellationToken to observe while waiting for the task to complete. /// A task that represents the asynchronous save operation. The task result contains the number of state entries written to the database. public override Task SaveChangesAsync(CancellationToken cancellationToken = default) { //设置基类通用字段值 SetBaseEntityFields(base.ChangeTracker); return base.SaveChangesAsync(cancellationToken); } #endregion #region 方法 /// /// 设置基类通用字段值 /// /// 实体状态 /// private void SetBaseEntityFields(ChangeTracker changeTracker) { var baseLogicEntityType = typeof(BaseLogicEntity); foreach (var entry in changeTracker.Entries()) { //若entry的基类不是BaseLogicEntity, 则pass if (!baseLogicEntityType.IsAssignableFrom(entry.Entity.GetType())) { continue; } SetBaseEntityFields(entry); } } /// /// 设置基类通用字段值 /// /// 实体状态 /// private void SetBaseEntityFields(EntityEntry entityEntry) { var now = DateTimeOffset.UtcNow; var userId = 1470214131637424134L; var ip = GetIP(); var entityState = entityEntry.State; var propertyValues = entityEntry.CurrentValues; if (propertyValues == default) { return; } //设置属性值 void SetPropertyValues(PropertyValues propertyValues, Dictionary dic) { dic.ToList().ForEach(kvPair => { propertyValues[kvPair.Key] = kvPair.Value; }); } Dictionary dic = new() { { SysContant.Entity_Property_LastUpdateTime, now }, { SysContant.Entity_Property_LastUpdateUserId, userId }, { SysContant.Entity_Property_LastUpdateIP, ip }, }; if (entityState == EntityState.Added) { dic.Add(SysContant.Entity_Property_AddTime, now); dic.Add(SysContant.Entity_Property_AddUserId, userId); dic.Add(SysContant.Entity_Property_AddIP, ip); SetPropertyValues(propertyValues, dic); } else if (entityState == EntityState.Modified) { SetPropertyValues(propertyValues, dic); } else { //其他情况不处理 return; } } /// /// 获取IP地址 /// /// private string GetIP() { //获取本地IP string GetLocalIP() { return NetworkInterface .GetAllNetworkInterfaces() .Where(netWork => netWork.OperationalStatus == OperationalStatus.Up) .Select(netWork => netWork.GetIPProperties()) .OrderByDescending(pro => pro.GatewayAddresses.Count) .SelectMany(pro => pro.UnicastAddresses) .FirstOrDefault(ip => !IPAddress.IsLoopback(ip.Address) && (ip.Address.AddressFamily == AddressFamily.InterNetwork || ip.Address.AddressFamily == AddressFamily.InterNetworkV6)) ?.Address.ToString() ?? \"\"; } //获取客户端IP string GetRemoteIP() { return _httpContextAccessor.HttpContext.Connection.RemoteIpAddress?.ToString() ?? _httpContextAccessor.HttpContext.Request.Headers[\"X-Real-IP\"].FirstOrDefault() ?? \"\"; } var needHandleIPs = new[] { \"::1\" }; var ip = \"\"; bool isGetLocalIP; if (_httpContextAccessor == default) { ip = GetLocalIP(); isGetLocalIP = true; } else { ip = GetRemoteIP(); isGetLocalIP = false; } //获取的IP是否需要二次处理 if (needHandleIPs.Contains(ip)) { ip = isGetLocalIP ? GetRemoteIP() : GetLocalIP(); } return ip; } #endregion 另一种实现逻辑: 可以注册DbContext.SavingChanges事件, 实现公共字段的修改 public interface IHasTimestamps { DateTime? Added { get; set; } DateTime? Deleted { get; set; } DateTime? Modified { get; set; } } private static void UpdateTimestamps(object sender, EntityEntryEventArgs e) { if (e.Entry.Entity is IHasTimestamps entityWithTimestamps) { switch (e.Entry.State) { case EntityState.Deleted: entityWithTimestamps.Deleted = DateTime.UtcNow; Console.WriteLine($\"Stamped for delete: {e.Entry.Entity}\"); break; case EntityState.Modified: entityWithTimestamps.Modified = DateTime.UtcNow; Console.WriteLine($\"Stamped for update: {e.Entry.Entity}\"); break; case EntityState.Added: entityWithTimestamps.Added = DateTime.UtcNow; Console.WriteLine($\"Stamped for insert: {e.Entry.Entity}\"); break; } } } public BlogsContext() { ChangeTracker.StateChanged += UpdateTimestamps; ChangeTracker.Tracked += UpdateTimestamps; } Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/Identify_Server_4.html":{"url":"NetCore/Identify_Server_4.html","title":"Identify_Server_4","keywords":"","body":"Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/JWT.html":{"url":"NetCore/JWT.html","title":"JWT","keywords":"","body":"1>相关文章 1-1>JWT在线解码工具 https://jwt.io/ 1-2>asp.net core 集成JWT asp.net core 集成JWT（一） asp.net core 集成JWT（二）token的强制失效，基于策略模式细化api权限 1-3>ASP.NET Core Web Api之JWT ASP.NET Core Web Api之JWT(一) ASP.NET Core Web Api之JWT VS Session VS Cookie(二) ASP.NET Core Web Api之JWT刷新Token(三) ASP.NET Core Identity自定义数据库结构和完全使用Dapper而非EntityFramework Core 1-4>ASP.NET Core 实战：基于 Jwt Token 的权限控制全揭露 https://www.cnblogs.com/danvic712/p/10331976.html 1-5>用JWT来保护我们的ASP.NET Core Web API https://www.cnblogs.com/catcher1994/p/6057484.html 1-6>用Middleware给ASP.NET Core Web API添加自己的授权验证 https://www.cnblogs.com/catcher1994/p/6021046.html 1-7>ASP.NET Core 认证与授权[4]:JwtBearer认证 https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html 1-8>jwt策略参数 https://www.cnblogs.com/fger/p/12202362.html 1-9>Authentication跟Authorization的区别 https://blog.csdn.net/linshunhuang1/article/details/108798219 1-10>使用Swagger为.NET Core 3.0应用添加JWT授权说明文档 https://blog.csdn.net/weixin_33008495/article/details/102811347 https://www.cnblogs.com/nwdnote/p/13554202.html 1-11>Asp Net Core 5 REST API 使用 RefreshToken 刷新 JWT - Step by Step（三） https://mp.weixin.qq.com/s?__biz=MzA5NjQ1Njc3Ng==&mid=2247484402&idx=1&sn=264b5235d944f47b250ed478300fcff9 2>JWT令牌结构 *JWT由三部分构成: Base64编码的Header(头), Base64编码的Payload(有效载荷), Signature(签名) 三部分通过点隔开. *第一部分以Base64编码的Header主要包括Token的类型和所使用的算法: { \"alg\": \"HS265\", //签名算法 \"typ\": \"JWT\" //令牌的类型 } *第二部分以Base64编码的Payload主要包含的是声明(Claims): 7个官方字段: iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 可以在这个部分定义私有字段: { \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true } *第三部分则是将Key通过对应的加密算法生成签名, 最终三部分以点隔开: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiSmVmZmNreSIsImVtYWlsIjoiMjc1MjE1NDg0NEBxcS5jb20iLCJleHAiOjE1NjU2MTUzOTgsIm5iZiI6MTU2MzE5NjE5OCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAwIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAxIn0. OJjlGJOnCCbpok05gOIgu5bwY8QYKfE2pOArtaZJbyI 3>基础概念 Claim（每一项的证件信息）=》ClaimsIdentity（证件）=》ClaimsPrincipal（证件持有者） 4>NET Core中使用JWT 4-1>结合JWT认证对用户进行API授权 自定义鉴权策略逻辑: 策略(PolicyRequirement)保存角色与权限的关系列表, 在PolicyHandler里获取用户当前访问的api路径, 再根据用户所具备的角色, 判断用户是否可以访问当前api. /// /// PolicyRequirement /// public sealed class PolicyRequirement : IAuthorizationRequirement { /// /// 角色api权限集合 /// public List RoleApiPermissions { get; private set; } = new(); /// /// 构造函数 /// public PolicyRequirement() { //初始化角色api权限集合 RoleApiPermissions = new List { new RoleApiPermission { Name=\"SystenAdmin\", Urls = new HashSet { \"/calc/TestJWT/Action3\", }, }, }; } } /// /// RoleApiPermission /// public sealed class RoleApiPermission : RoleApiPermission { /// /// /// public RoleApiPermission() : base() { } } /// /// RoleApiPermission /// /// public class RoleApiPermission { /// /// Id /// public virtual TKey Id { get; set; } = SnowflakeID.GetInstance().GetNextID(); /// /// 名称 /// public virtual string Name { get; set; } /// /// 请求Url /// public virtual HashSet Urls { get; set; } = new(); } /// /// 策略处理 /// public class PolicyHandler : AuthorizationHandler { /// /// 处理鉴权策略 /// /// AuthorizationHandlerContext /// PolicyRequirement /// protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, PolicyRequirement requirement) { if (context.Resource == default) { throw new ArgumentNullException(nameof(context.Resource)); } //获取HttpContext var httpContext = (context.Resource as Microsoft.AspNetCore.Http.DefaultHttpContext); if (httpContext == default) { throw new ArgumentNullException(nameof(httpContext)); } //请求Url var questUrl = httpContext.Request?.Path.Value?.ToLower().TrimAll() ?? \"\"; if (questUrl == default) { throw new ArgumentNullException(nameof(questUrl)); } //是否经过验证 var isAuthenticated = httpContext.User?.Identity?.IsAuthenticated ?? false; if (!isAuthenticated) { return Task.CompletedTask; } //获取当前用户的角色列表 var roleStr = httpContext.User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Role)?.Value ?? \"\"; if (string.IsNullOrEmpty(roleStr)) { throw new InvalidOperationException(\"Role of user is null!\"); } if (!roleStr.TryJArrayParse(out JArray roles)) { throw new InvalidCastException(\"Format of role is error!\"); } if (roles.Count roles.Any(jToken => jToken.ToString().TrimAll().ToLower() == r.Name.TrimAll().ToLower())).ToList() .SelectMany(r => r.Urls).ToList() ?? new List() ).Distinct().ToList() .Any(url => url.TrimAll().ToLower() == questUrl) ) { context.Succeed(requirement); return Task.CompletedTask; } //重定向到无权限页面 //httpContext.Response.Redirect(requirement.NoPermissionAction); //返回无权限的响应结果 httpContext.Response.Headers.Add ( SysContant.JWT_ResponseHeader_ActualReason, SysContant.ResultMsg_NoPermission ); httpContext.Response.StatusCode = (int)HttpStatusCode.Forbidden; context.Fail(); return Task.CompletedTask; } } //Startup.ConfigureServices //添加策略模式的配置 .AddAuthorization(authorizationOptions => { authorizationOptions.AddPolicy(\"CustomAuthorization\", policy => { policy.AddRequirements(new PolicyRequirement()); }); }) .AddSingleton() 4-2>一个用户同时只能拥有一个有效的Access Token 实现逻辑:在JWT验证里, 可以开启Issuer, Audience, Token(真实性跟有效性)验证, 因此可以让鉴权服务器生成动态的Audience, 保证每次生成Token的时候, 都加入一个唯一的Audience, 这样, 每个用户(每个AppID)同时只能拥有一个唯一有效的Access Token. /// /// Auth /// [Route(\"calc/[controller]\")] [ApiController] public class AuthController : ControllerBase { /// /// IMemoryCache /// private readonly IMemoryCache _memoryCache = default; /// /// ]]> /// private readonly IOptionsSnapshot _optionsSnapshot = default; /// /// 系统配置 /// private readonly SystemConfig _systemConfig = default; /// /// memoryCache /// /// memoryCache /// optionsSnapshot public AuthController(IMemoryCache memoryCache, IOptionsSnapshot optionsSnapshot) { _memoryCache = memoryCache ?? throw new ArgumentNullException(nameof(memoryCache)); _optionsSnapshot = optionsSnapshot ?? throw new ArgumentNullException(nameof(optionsSnapshot)); _systemConfig = _optionsSnapshot.Value ?? throw new ArgumentNullException(nameof(_optionsSnapshot.Value)); //设置全局的MemoryCache FramePublicFun.MemoryCacheGlobal = memoryCache; } /// /// 登录 /// /// 用户名 /// 密码 /// cancellationToken /// [HttpPost(\"Login\")] public async Task LoginSync(string userName, string passWord, CancellationToken cancellationToken=default) { try { userName = userName ?? \"\"; passWord = passWord ?? \"\"; //TODO 校验用户账号密码 if (userName != \"dylanxu\" || passWord != \"123456\") { return new FunResult ( SysContant.ResultCode_InvalidUserNameOrPassword, \"Fail\", null ); } //TODO 查询用户拥有的角色集合 var roles = new List { \"SystenAdmin\" }; var utcNow = DateTimeOffset.UtcNow; //创建声明集合 var claims = new[] { new Claim ( JwtRegisteredClaimNames.Nbf, $\"{utcNow.ToUnixTimeSeconds()}\" ) , new Claim ( JwtRegisteredClaimNames.Exp, $\"{utcNow.AddSeconds(_systemConfig.JWTSetting.Expiration_AccessToken.Value).ToUnixTimeSeconds()}\" ), new Claim ( ClaimTypes.Name, userName ), //new Claim //( // SysContant.ClaimTypes_PassWord, // passWord //), new Claim ( ClaimTypes.Role, NewtonsoftSerializer.SerializeObject(roles) ), }; //设置动态的audience, 加上SnowID, 保证每个用户, 每次登录后, audience都是唯一的 //TODO 后期改成用redis缓存 var cacheKey = $\"{SysContant.Cache_Key_Prefix_Audience}{userName}\"; var audience = FramePublicFun.MD5 ( $\"{userName}|^|{passWord}|^|{await SnowflakeID.GetInstance().GetNextIDAsync()}\", false, Encoding.UTF8 ); //每个用户的audience缓存失效期可以不设置 //服务器鉴权时, 先校验的audience, 再校验token是否失效 //audience的作用主要是为了验证用户是否重新登录了, 或者是否修改了密码, audience的失效期并不重要, //因为鉴权服务器会校验token的有效期 await _memoryCache.SetCacheAsync ( cacheKey, audience, TimeSpan.FromSeconds(int.MaxValue), default, default, cancellationToken ); var symmetricSecurityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_systemConfig.JWTSetting.SecurityKey)); var signingCredentials = new SigningCredentials(symmetricSecurityKey, SecurityAlgorithms.HmacSha256); var jwtSecurityToken = new JwtSecurityToken ( issuer: _systemConfig.JWTSetting.Issuer, audience: audience, claims: claims, expires: DateTime.UtcNow.AddSeconds(_systemConfig.JWTSetting.Expiration_AccessToken.Value), //控制jwtToken的有效时间 //expires: DateTime.Now.AddMinutes(1), //控制jwtToken的有效时间 signingCredentials: signingCredentials ); var jwtSecurityTokenHandler = new JwtSecurityTokenHandler(); var jwtToken = jwtSecurityTokenHandler.WriteToken(jwtSecurityToken); return await Task.FromResult(new FunResult ( SysContant.ResultCode_Success, \"Success\", jwtToken )); } catch (Exception ex) { return new FunResult ( SysContant.ResultCode_Fail, ex.GetInnerExceptionMsg(), null ); } } } //Startup.ConfigureServices //添加JWT验证 services //添加策略模式的配置 .AddAuthorization(authorizationOptions => { authorizationOptions.AddPolicy(\"CustomAuthorization\", policy => { policy.AddRequirements(new PolicyRequirement()); }); }) .AddSingleton() //.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddAuthentication(authenticationOptions => { //添加JWT Scheme authenticationOptions.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; authenticationOptions.DefaultScheme = JwtBearerDefaults.AuthenticationScheme; authenticationOptions.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; }) .AddJwtBearer(jwtBearerOptions => { jwtBearerOptions.Events = new JwtBearerEvents { //TokenValidated：在Token验证通过后调用。 //AuthenticationFailed: 认证失败时调用。 //Challenge: 未授权时调用。 //设置消息接收事件, 可以自定义Token的获取方式 OnMessageReceived = messageReceivedContext => { var access_token = messageReceivedContext.Request.Headers[SysContant.JWT_AccessToken].ToString(); if (string.IsNullOrEmpty(access_token)) { access_token = messageReceivedContext.Request.Query[SysContant.JWT_AccessToken].ToString(); } messageReceivedContext.Token = access_token; return Task.CompletedTask; }, OnAuthenticationFailed = authenticationFailedContext => { //若是token过期, 则在响应头上返回具体原因 if (authenticationFailedContext.Exception.GetType() == typeof(SecurityTokenExpiredException)) { authenticationFailedContext.Response.Headers.Add ( SysContant.JWT_ResponseHeader_ActualReason, SysContant.ResultMsg_TokenExpired ); } return Task.CompletedTask; }, }; //设置令牌校验参数 jwtBearerOptions.TokenValidationParameters = new TokenValidationParameters { ValidateIssuer = true, //是否验证Issuer ValidIssuer = Configuration[\"SystemConfig:JWTSetting:Issuer\"], //Issuer，这两项和前面签发jwt的设置一致 ValidateAudience = true, //是否验证Audience //ValidAudience = SysContant.JWT_Domain, //Audience AudienceValidator = (audiences, securityToken, validationParameters) => { var jwtSecurityToken = securityToken as JwtSecurityToken; if (jwtSecurityToken == default) { //throw new InvalidCastException(nameof(jwtSecurityToken)); return false; } var userName = jwtSecurityToken.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Name)?.Value ?? \"\"; if (string.IsNullOrEmpty(userName)) { //throw new ArgumentNullException(nameof(userName)); return false; } if (FramePublicFun.MemoryCacheGlobal == default) { return false; } //TODO 从redis中获取当前用户的audience var cacheKey = $\"{SysContant.Cache_Key_Prefix_Audience}{userName}\"; var (result, val) = FramePublicFun.MemoryCacheGlobal.TryGetVal(cacheKey); if (!result) { return result; } if (string.IsNullOrEmpty(val)) { return false; } //校验当前的audiences是否与缓存的相同 return audiences.Contains(val); }, ValidateLifetime = true, //是否验证Token有效期，使用当前时间与Token的Claims中的NotBefore和Expires对比 ClockSkew = TimeSpan.FromSeconds(double.Parse(Configuration[\"SystemConfig:JWTSetting:ClockSkew\"])), //允许的服务器时间偏移量 ValidateIssuerSigningKey = true, //是否验证SecurityKey IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[\"SystemConfig:JWTSetting:SecurityKey\"])) //拿到SecurityKey }; }); //Startup.Configure app.UseAuthentication()//启动JWT验证 .UseAuthorization(); 4-3>Swagger启用JWT //Startup.ConfigureServices //注册Swagger .AddSwaggerGen(swaggerGenOptions => { swaggerGenOptions //Swagger拓展配置 .ConfigExtension($\"{typeof(Startup).Namespace}.xml\") .SwaggerDoc ( \"v1\", new OpenApiInfo { Title = \"Dylan.DbContextApiDemo\", Version = \"v1\" } ); //Swagger开启JWT swaggerGenOptions.AddSecurityDefinition(JwtBearerDefaults.AuthenticationScheme, new OpenApiSecurityScheme { Name = \"Authorization\", In = ParameterLocation.Header, Type = SecuritySchemeType.ApiKey, BearerFormat = \"JWT\", Scheme = JwtBearerDefaults.AuthenticationScheme, Description = \"JWT Authorization header using the Bearer scheme. Example: \\\"Authorization: Bearer {token}\\\"\", }); swaggerGenOptions.AddSecurityRequirement(new OpenApiSecurityRequirement { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = JwtBearerDefaults.AuthenticationScheme } },new string[]{ } } }); }) /// /// Swagger拓展类 /// public static class SwaggerExtension { /// /// Swagger拓展配置 /// /// SwaggerGenOptions /// xml文件名 public static SwaggerGenOptions ConfigExtension(this SwaggerGenOptions opt, string xmlName) { if (opt == default) { throw new ArgumentNullException(nameof(opt)); } if (string.IsNullOrEmpty(xmlName)) { throw new ArgumentNullException(nameof(xmlName)); } var xmlPath = Path.Combine(FramePublicFun.GetDllPath(), xmlName); if (!File.Exists(xmlPath)) { throw new InvalidOperationException($\"Fail to locate file ({xmlPath})!\"); } opt.IncludeXmlComments(xmlPath); return opt; } } 4-4>通过RefreshToken刷新Token *基本概念:JWT Token有一个过期时间, 时间越短越安全. 过期后，有两种方法可以获取新的 access token: 客户端(前端)检测到access token失效后, 重定向到登录页面, 让用户重新登录. 使用Refresh Token自动重新验证用户, 并生成新的 access token. 4-5>封装 5>注意事项 *签名的SecurityKey长度至少要16位, 否则生成Token会报错. *使用自定义鉴权策略, 只有在class或者method上标识 Authorize(policy: \"自定义鉴权策略名称\"), 才会走自定义鉴权策略的逻辑. Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/MemoryCache_and_分布式Cache_Redis.html":{"url":"NetCore/MemoryCache_and_分布式Cache_Redis.html","title":"MemoryCacheand分布式Cache_Redis","keywords":"","body":"1>相关文章 1-1>.NET CORE 中的缓存使用 https://www.cnblogs.com/weihengblogs/p/11776497.html 1-2>拥抱.NET Core系列：MemoryCache 初识 拥抱.NET Core系列：MemoryCache 初识 拥抱.NET Core系列：MemoryCache 缓存过期 拥抱.NET Core系列：MemoryCache 缓存选项 拥抱.NET Core系列：MemoryCache 缓存域 1-3>C# Memory Cache 踩坑记录 https://www.cnblogs.com/CoderAyu/p/10242230.html 1-4>.NET Core MemoryCache缓存获取全部缓存键 https://www.cnblogs.com/leon-ytparty/articles/10831063.html 1-5>Redis缓存 https://www.cnblogs.com/taotaozhuanyong/p/11565527.html 2>IMemoryCache 2-1>简介 存储在 Web 服务器内存中的缓存, 支持 绝对过期支持 滑动过期支持（指定一个时间，TimeSpan，指定时间内有被Get缓存时间则顺延，否则过期） 过期回调 自定义过期 2-2>基本使用 *包: Microsoft.Extensions.Caching.Memory *依赖注入: public void ConfigureServices(IServiceCollection services) { services.AddMemoryCache(); } private IMemoryCache _cache; public LoginController(IMemoryCache memoryCache) { _cache = memoryCache; } //创建IMemoryCache using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); //设置缓存值 var cacheKey = \"stu1\"; Student student1 = new() { Id = await SnowflakeID.GetInstance().GetNextIDAsync(), Name = \"dylanxu\" }; memoryCache.Set(cacheKey, student1); //获取缓存值 var isExist = memoryCache.TryGetValue(cacheKey, out Student student2); 2-3>设置绝对到期时间（指定在一个固定的时间点到期） //设置绝对到期时间 using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var count = 0; var cacheKey = \"cacheKey\"; for (var i = 0; i { entry.SetAbsoluteExpiration(TimeSpan.FromSeconds(2)); count++; return Task.FromResult(count); }); await Console.Out.WriteLineAsync(resultInt.ToString()); await Task.Delay(TimeSpan.FromSeconds(1)); } //设置绝对到期时间 using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var cacheKey = \"cacheKey\"; var cacheVal = \"cacheVal\"; memoryCache.Set(cacheKey, cacheVal, TimeSpan.FromSeconds(2)); await Task.Delay(TimeSpan.FromSeconds(1)); var isExist = memoryCache.TryGetValue(cacheKey, out var val); await Console.Out.WriteLineAsync ( $\"After 1s, key({cacheKey}) is exist:{isExist}.\" ); await Task.Delay(TimeSpan.FromSeconds(2)); isExist = memoryCache.TryGetValue(cacheKey, out val); await Console.Out.WriteLineAsync ( $\"After 3s, key({cacheKey}) is exist:{isExist}.\" ); 2-4>滑动到期（在一个时间长度内没有被命中则过期） //4>设置滑动到期 using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var cacheKey = \"cacheKey\"; var cacheVal = \"cacheVal\"; using (var entry = memoryCache.CreateEntry(cacheKey)) { entry.SetValue(cacheVal); entry.SetSlidingExpiration(TimeSpan.FromSeconds(2)); } await Task.Delay(TimeSpan.FromSeconds(1)); var isExist = memoryCache.TryGetValue(cacheKey, out var val); await Console.Out.WriteLineAsync ( $\"After 1s, key({cacheKey}) is exist:{isExist}.\" ); await Task.Delay(TimeSpan.FromSeconds(1.8)); isExist = memoryCache.TryGetValue(cacheKey, out val); await Console.Out.WriteLineAsync ( $\"After 1.8s, key({cacheKey}) is exist:{isExist}.\" ); await Task.Delay(TimeSpan.FromSeconds(3)); isExist = memoryCache.TryGetValue(cacheKey, out val); await Console.Out.WriteLineAsync ( $\"After 3s, key({cacheKey}) is exist:{isExist}.\" ); 2-5>到期Token（自定义过期） IChangeToken HasChanged: 用来返回是否发生了变更，在MSCache中如果返回了true则缓存项将会失效。 ActiveChangeCallbacks: 该属性更多是一种描述，字面意思是该token是否会激活回调，取决于IChangeToken实现者的逻辑，如果这个值返回false则不要期望通过IChangeToken的RegisterChangeCallback来达到发生变更的时候有回调通知。 RegisterChangeCallback: 注册一个回调，当变更发生时执行，一般配合ActiveChangeCallbacks来达成。 MS其它组件实现的IChangeToken: CancellationChangeToken （一个对CancellationToken的包装） CompositeChangeToken （组合ChangeToken，可以将多个ChangeToken包装成一个Token） ConfigurationReloadToken （配置重新加载Token，来自MS.Configuration组件） PollingFileChangeToken （通过轮询来监控文件变更） PollingWildCardChangeToken （通过轮询来监控文件变更，这个是支持通配符的） //5>自定义过期Token using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var cacheKey = \"cacheKey\"; var cacheVal = \"cacheVal\"; var cancellationTokenSource = new CancellationTokenSource(); var cancellationChangeToken = new CancellationChangeToken(cancellationTokenSource.Token); memoryCache.Set(cacheKey, cacheVal, cancellationChangeToken); await Task.Delay(TimeSpan.FromSeconds(1)); var isExist = memoryCache.TryGetValue(cacheKey, out var val); await Console.Out.WriteLineAsync ( $\"After 1s, key({cacheKey}) is exist:{isExist}.\" ); //手动取消 cancellationTokenSource.Cancel(); isExist = memoryCache.TryGetValue(cacheKey, out val); await Console.Out.WriteLineAsync ( $\"After cancel by outer, key({cacheKey}) is exist:{isExist}.\" ); //非常重要: 需要重新定义CancellationTokenSource和CancellationChangeToken cancellationTokenSource = new CancellationTokenSource(); cancellationChangeToken = new CancellationChangeToken(cancellationTokenSource.Token); memoryCache.Set(cacheKey, cacheVal, cancellationChangeToken); await Task.Delay(TimeSpan.FromSeconds(1)); isExist = memoryCache.TryGetValue(cacheKey, out val); await Console.Out.WriteLineAsync ( $\"After 1s, key({cacheKey}) is exist:{isExist}.\" ); *自定义IChangeToken 2-6>过期策略可以组合使用 *过期策略是只要有一个策略命中, 那么这个缓存就无效了. //6>多个过期策略组合使用 using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var cacheKey = \"cacheKey\"; var cacheVal = \"cacheVal\"; using (var entry = memoryCache.CreateEntry(cacheKey)) { entry.SetValue(cacheVal); //1>设置绝对过期时间为10min entry.SetAbsoluteExpiration(TimeSpan.FromMinutes(10)); //2>设置滑动过期时间为3s entry.SetSlidingExpiration(TimeSpan.FromSeconds(3)); } var isExist = memoryCache.TryGetValue(cacheKey, out var val); var count = 0; while (isExist) { await Task.Delay(TimeSpan.FromSeconds(count++)); isExist = memoryCache.TryGetValue(cacheKey, out val); await Console.Out.WriteLineAsync ( $\"After {count}s, key({cacheKey}) is exist:{isExist}.\" ); } 2-7>缓存过期回调 *过期回调内的动作不要使用异步, 也不要访问reson, 否则程序逻辑会出现异常. *回调动作的触发的时机: 外部访问已经过期的缓存 //7>过期回调 using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var cacheKey = \"cacheKey\"; var cacheVal = \"cacheVal\"; using (var entry = memoryCache.CreateEntry(cacheKey)) { entry.SetValue(cacheVal); //1>设置绝对过期时间为2s entry.SetAbsoluteExpiration(TimeSpan.FromSeconds(2)); //2>注册过期回调动作 entry.RegisterPostEvictionCallback( (key, value, reason, state) => { try { var val = value == null ? \"\" : value.ToString(); //访问reason, 程序逻辑就异常 //Console.WriteLine(reason); //Console.WriteLine(state); Console.WriteLine($\"{key}(val:{val}).\"); //await Console.Out.WriteLineAsync(key.ToString()); //Console.WriteLine(key.ToString()); } catch (Exception ex) { Console.WriteLine(ex.GetInnerExceptionMsg()); } }); } var isExist = memoryCache.TryGetValue(cacheKey, out var val); await Console.Out.WriteLineAsync ( $\"key({cacheKey}) is exist:{isExist}.\" ); await Task.Delay(TimeSpan.FromSeconds(2.5)); isExist = memoryCache.TryGetValue(cacheKey, out val); await Console.Out.WriteLineAsync ( $\"key({cacheKey}) is exist:{isExist}.\" ); 2-8>GetOrCreate 获取或创建, 此方法的使用场景: 当缓存失效后, 可以使用预先定义好的策略重新获取并设置新的缓存. //8>GetOrCreate using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var cacheKey = \"stu_dylan\"; async Task CreateStuAsync() { return await memoryCache.GetOrCreate(cacheKey, async entry => { await Console.Out.WriteLineAsync($\"Create {entry.Key}\"); //设置2s后过期 entry.SetAbsoluteExpiration(TimeSpan.FromSeconds(2)); Student student = new() { Id = await SnowflakeID.GetInstance().GetNextIDAsync(), Name = \"dylanxu\", }; return student; }); } var stu = await CreateStuAsync(); await Console.Out.WriteLineAsync ( $\"key({cacheKey}) is exist:{stu != default}.\" ); await Task.Delay(TimeSpan.FromSeconds(2.1)); stu = await CreateStuAsync(); await Console.Out.WriteLineAsync ( $\"After 2.1s, key({cacheKey}) is exist:{stu != default}.\" ); 2-9>MemoryCacheOptions Clock: 用来提供时间的一个成员. ExpirationScanFrequency: 过期扫描频率 (默认为1分钟，可以理解为每过多久移除一次过期的缓存项). *什么时候会进行过期缓存清理: 添加新的 获取缓存项 删除缓存项目 当有缓存项过期（通过过期回调） SizeLimit: 缓存大小限制, 当所有缓存大小超过这个值的时候进行一次缓存压缩。 CompactionPercentage: 压缩率 (默认5%). 那么当缓存大小超过SizeLimit时，MSCache会 先清理Low优先级的缓存项（不管是否过期） 再清理Normal优先级的缓存项（不管是否过期） 继续清理High优先级的缓存项（不管是否过期） //9>MemoryCacheOptions var memoryCacheOptions = Options.Create(new MemoryCacheOptions()); memoryCacheOptions.Value.ExpirationScanFrequency = TimeSpan.FromSeconds(30); using IMemoryCache memoryCache = new MemoryCache(memoryCacheOptions); var cacheKey = \"stu_dylan\"; using (var entry = memoryCache.CreateEntry(cacheKey)) { //TODO } 2-10>缓存域(缓存级联失效) *在绝对过期时间及自定义IChangeToken的情况, 子类缓存过期了, 父类也会自动过期. *在相对过期时间的情况下, 子类缓存过期了, 父类也不会过期, 需要手动处理这种情况. 2-11>封装 参考 Dylan.FrameWork.Extension.MemoryCacheExtension.cs 2-12>注意事项 *存储在MemoryCache里的引用类型的数据, 获取出来的永远指向同一个对象, 所以要注意, 若对取出来的数据进行修改后, 不管调用 memoryCache.Set 与否, 都会改变cache里的值. using IMemoryCache memoryCache = new MemoryCache(Options.Create(new MemoryCacheOptions())); var cacheKey = \"stu1\"; Student student1 = new() { Id = await SnowflakeID.GetInstance().GetNextIDAsync(), Name = \"dylanxu\" }; memoryCache.Set(cacheKey, student1); var isExist = memoryCache.TryGetValue(cacheKey, out Student student2); await Console.Out.WriteLineAsync ($\"{cacheKey} is exist:{isExist}, student1({student1.GetHashCode()}) == student2({student2.GetHashCode()}):{object.ReferenceEquals(student1, student2)}.\"); //修改student2数据, 再重新获取一次cache数据, 查看是否原来的数据=>是 student2.Name = $\"{student2.Name}_111\"; isExist = memoryCache.TryGetValue(cacheKey, out Student student3); await Console.Out.WriteLineAsync ($\"{cacheKey} is exist:{isExist}, student3.Name:{student3.Name}, student2({student2.GetHashCode()}) == student3({student3.GetHashCode()}):{object.ReferenceEquals(student2, student3)}.\"); *MemoryCache是线程安全的, 缓存项目使用ConcurrentDictionary _entries. *过期回调内的动作不要使用异步, 也不要访问reson, 否则程序逻辑会出现异常. *若MemoryCache需要全局有效, 需要使用静态类的静态属性来装载IMemoryCache. //Dylan.FrameWork.Utility.FramePublicFun.cs /// /// MemoryCache /// public static IMemoryCache MemoryCacheGlobal { get; set; } = default; 3>Redis Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/MySQL.html":{"url":"NetCore/MySQL.html","title":"MySQL","keywords":"","body":"1>相关文章 *MySQL系列 mysql 基础篇系列(23) mysql 进阶篇系列(55) mysql 架构篇系列(3) *Mysql 允许IP地址访问 *mysql的备份表的几种方法 *MySQL日期格式化 *安装教程 mysql安装教程【安装版】 MySQL错误sql_mode=only_full_group_by完美解决方案 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-02-20 09:13:01 "},"NetCore/Net_Core_API.html":{"url":"NetCore/Net_Core_API.html","title":"Net_Core_API","keywords":"","body":"1>相关文章 1-1>ASP.NET Core WebApi使用Swagger生成api说明文档看这篇就够了 https://www.cnblogs.com/yilezhu/p/9241261.html 1-2>【WebAPI】从零开始学会使用.NET Core WebAPI https://www.cnblogs.com/yanbigfeg/p/9262623.html 1-3>.Net Core3.0 WebApi 目录 https://www.cnblogs.com/taotaozhuanyong/p/13792340.html 1-4>在 .NET Core 中构建 REST API https://mp.weixin.qq.com/s?__biz=MzA5NjQ1Njc3Ng==&mid=2247484333&idx=1&sn=ea8402f5f3cb6c34ee9552c9e5d89d9e 2> Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/Net_Core_MVC.html":{"url":"NetCore/Net_Core_MVC.html","title":"Net_Core_MVC","keywords":"","body":"1>.net core中的Session以及HttpContext对象使用小结 1-1>https://www.jianshu.com/p/0315aa029867 *在MVC Controller里使用HttpContext.Session HttpContext.Session.SetString(\"code\",\"123456\"); ViewBag.Code=HttpContext.Session.GetString(\"code\"); *如果不是在Controller里，你可以注入IHttpContextAccessor，有两种方式，一种是在类的构造函数里面注入，如下： public class SomeOtherClass { private readonly IHttpContextAccessor _httpContextAccessor; private ISession _session=> _httpContextAccessor.HttpContext.Session; public SomeOtherClass(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor=httpContextAccessor; } public void Set() { _session.SetString(\"code\",\"123456\"); } public void Get() { string code = _session.GetString(\"code\"); } } *另外一种是通过IServiceProvider，这时需要在startup中Configure中得到这个对象，然后通过 Microsoft.AspNetCore.Http.IHttpContextAccessor factory = app.ApplicationServices.GetService(); Microsoft.AspNetCore.Http.HttpContext context = factory.HttpContext; 或者 Microsoft.AspNetCore.Http.IHttpContextAccessor factory = app.ApplicationServices.GetService(typeof(Microsoft.AspNetCore.Http.IHttpContextAccessor)); Microsoft.AspNetCore.Http.HttpContext context = factory.HttpContext; 1-2>若出现Error unprotecting the session cookie.The payload was invalid，则参考下面文章，增加services.AddDataProtection()，然后重启浏览器。 https://www.cnblogs.com/vipsoft/p/13045581.html 1-3>若出现警告 No XML encryptor configured. Key may be persisted to storage in unencrypted form，则参考下面文章处理(没弄出来) https://www.cnblogs.com/dudu/p/9589012.html https://www.pianshen.com/article/14361061895 openssl req -x509 -newkey rsa:4096 -sha256 -nodes -keyout dylan.key -out dylan.crt -subj \"/CN=dylan.com\" -days 3650 openssl pkcs12 -export -out dylan.pfx -inkey dylan.key -in dylan.crt -certfile dylan.crt -passout pass: dylan.key 2>net core 注入log4net(可以在startup或者programme配置) *注意：DatePattern中的value，如果使用.log，因为是关键字，则需要配置成'.log' 2-1>相关知识站点 https://www.cnblogs.com/kevin860/p/13170107.html https://www.cnblogs.com/zxp6/p/12464559.html https://blog.csdn.net/MrLsss/article/details/109258064 https://blog.csdn.net/liangmengbk/article/details/107729402 2-2>log4net.config配置 https://www.cnblogs.com/kevin860/p/13170107.html https://www.cnblogs.com/changsen-wang/p/14275037.html .ConfigureLogging((context, loggingBuilder) => { loggingBuilder.SetMinimumLevel(LogLevel.Warning); loggingBuilder.AddFilter(\"System\", LogLevel.Information); loggingBuilder.AddFilter(\"Microsoft\", LogLevel.Information); /*第二种，在ConfigureLogging配置log4net begin*/ var cfgFilePath = Path.Combine(FramePublicFun.GetDllPath(), SysContant.Log4Net_CfgFileName); loggingBuilder.AddLog4Net(cfgFilePath); /*第二种，在ConfigureLogging配置log4net end*/ }) 在Configure将日志对象注册到全局静态变量 //注册系统中静态类的框架日志服务 loggerFactory.RegisterGlobaltLogger(); 2-3>内置日志记录提供程序 (1) 控制台 logging.AddConsole(); dotnet run 查看控制台日志记录输出。(2) 调试 logging.AddDebug(); 在 Linux 中，此提供程序将日志写入 /var/log/message。 (3) EventSource logging.AddEventSourceLogger(); 在 Windows 中，它使用 PerfView 实用工具收集和查看日志，但尚无支持 Linux 或 macOS 的事件集合和显示工具。 (4) EventLog logging.AddEventLog();向 Windows 事件日志发送日志输出。 (5) TraceSource logging.AddTraceSource(sourceSwitchName);应用必须在 .NET Framework（而非 .NET Core）上运行。 2-4>appsettings.json中日志配置的解读, 可参考官网 https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0 { \"Logging\": { \"LogLevel\": { // All providers, LogLevel applies to all the enabled providers. \"Default\": \"Error\", // Default logging, Error and higher. \"Microsoft\": \"Warning\" // All Microsoft* categories, Warning and higher. }, \"Debug\": { // Debug provider. \"LogLevel\": { \"Default\": \"Information\", // Overrides preceding LogLevel:Default setting. \"Microsoft.Hosting\": \"Trace\" // Debug:Microsoft.Hosting category. } }, \"EventSource\": { // EventSource provider \"LogLevel\": { \"Default\": \"Warning\" // All categories of EventSource provider. } } } } 3>net core 部署 IIS 3-1>使用vs部署文件系统 3-2>直接到发布文件夹，执行dotnet .dll --urls=\"http://\\:8099\"，既可使用kestrel服务器 3-3>IIS部署方式 用IIS部署网站后, 看看网站里的\"模块\", 是否有AspNetCoreModuleV2, 若没有, 则需要下载net core运行时(根据net core版本下载对应的运行时版本) https://www.cnblogs.com/zhangmm96/p/12102015.html https://blog.csdn.net/weixin_33770878/article/details/94745175 https://www.cnblogs.com/MrHSR/p/10276650.html *当发布后, 文件中有一个web.config. 在web.config中设置 ASPNETCORE_ENVIRONMENT 环境变量. 使用 web.config 设置 ASPNETCORE_ENVIRONMENT 环境变量后, 它的值会替代系统级设置. 4>ASP.Net Core解读launchSettings.json https://www.cnblogs.com/qtiger/p/12958493.html 通过配置ASPNETCORE_ENVIRONMENT来实现多环境切换, 系统内置3个环境名: Development（开发环境）, Staging（测试环境）, Production（生产环境）, 环境名也可以自定义. 如果发布项目未设置 ASPNETCORE_ENVIRONMENT，则默认为 Production. (本机vs中项目Properties\\launchSettings.json中environmentVariables默认设置的是Development, 如果禁用environmentVariables, 那默认则为Production). 多环境配置可参考官网 https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/environments?view=aspnetcore-3.1#environment-based-startup-class-and-methods https://www.cnblogs.com/MrHSR/p/10276650.html 在Startup里, Configure名字不是一定的, 如果环境是Development, 则Configure可以是ConfigureDevelopment, 如果没有ConfigureDevelopment, 也没有Configure, 则系统会报错. 当 ASP.NET Core 应用启动时, 会启动Startup类. 应用程序可以为不同的环境, 单独定义 Startup 类. 可以定义例如: StartupDevelopment, StartupProduction, Startup. 当程序运行时会选择相应的 Startup 类. 程序会优先考虑名称后缀与当前环境相匹配的类. 如果是Developmen环境则程序进入StartupDevelopment, 如果是Production环境则程序进入StartupProduction. 如果找不到匹配的 Startup{EnvironmentName}, 就会使用 Startup 类. 5>ASP.NET Core中间件(Startup.Configure) https://www.cnblogs.com/whuanle/p/10095209.html https://www.cnblogs.com/stulzq/p/7760648.html https://www.cnblogs.com/JNLightGade/p/5737485.html 5-1>常见中间件顺序 异常/错误处理 HTTP 严格传输安全协议 HTTPS 重定向 静态文件服务器 Cookie 策略实施 身份验证 会话 MVC 5-2>HTTP管道容器由三个扩展的方法来控制中间件的路由、挂载等等，分别是Run, Use, Map. 5-2-1>Run方法会使得可以使管道短路，顾名思义就是终结管道向下执行, 不会调用next()委托, 所以Run方法最好放在管道的最后来执行。 *处理Response.WriteAsync()中文乱码 https://blog.csdn.net/lovestj/article/details/98731058 5-2-2>Use不会主动短路整个HTTP管道，但是也不会主动调用下一个中间件，必须自行调用await next.Invoke(); 如果不使用这个方法去调用下一个中间件，那么Use此时的效果其实和Run是相同的。 UseWhen是Use的一个条件判断，当满足某个条件的时候，执行某个中间件。 5-2-3>Map可以根据提供的URL来路由中间件 MapWhen是Map的一个条件判断的扩展方法，可以通过它来判断某个条件适合的时候，执行某一个中间件(*通姑demo发现, usewhen和mapwhen的效果一样) 5-3>内置中间件 Authentication 提供身份验证支持 CORS 配置跨域资源共享 Response Caching 提供缓存响应支持 Response Compression 提供响应压缩支持 Routing 定义和约束请求路由 Session 提供用户会话管理 Static Files 为静态文件和目录浏览提供服务提供支持 URL Rewriting Middleware 用于重写 Url，并将请求重定向的支持 5-4>构建中间件的流程参考https://www.cnblogs.com/stulzq/p/7760648.html public class MyMiddleware { private readonly RequestDelegate _next; public MyMiddleware(RequestDelegate next) { _next = next; } public async Task Invoke(HttpContext httpContext) { await _next(httpContext); } } public static class MyMiddlewareExtensions { public static IApplicationBuilder UseRequestCulture( this IApplicationBuilder builder) { return builder.UseMiddleware(); } } 最后在Startup.Configure app.UseRequestCulture(); *5-5>因为中间件是在应用程序启动时构建的，而不是每个请求，所以在每个请求期间，中间件构造函数使用的作用域生命周期服务不会与其他依赖注入类型共享。 如果您必须在中间件和其他类型之间共享作用域服务，请将这些服务添加到Invoke方法的签名中。 Invoke方法可以接受由依赖注入填充的其他参数。 例如上面的Invoke，改成如下 public async Task Invoke(HttpContext httpContext, IMyScopedService svc) { svc.MyProperty = 1000; await _next(httpContext); } 或者 public class RequestLoggerMiddleware { private readonly RequestDelegate _next; private readonly ILogger _logger; public RequestLoggerMiddleware(RequestDelegate next, ILoggerFactory loggerFactory) { _next = next; _logger = loggerFactory.CreateLogger(); } public async Task Invoke(HttpContext context) { _logger.LogInformation(\"Handling request: \" + context.Request.Path); await _next.Invoke(context); _logger.LogInformation(\"Finished handling request.\"); } } public static class RequestLoggerExtensions { public static IApplicationBuilder UseRequestLogger(this IApplicationBuilder builder) { return builder.UseMiddleware(); } } 最后在Startup.Configure app.UseRequestLogger(); *5-6>若要在中间件内获取控制器名称和动作名等信息, 需要将自定义的中间件放在app.UseRouting()后, 可参考下面文章. https://q.cnblogs.com/q/116803/ *5-7>中间件的注册，还可以使用继承于IStartupFilter来实现，可参考https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/startup?view=aspnetcore-3.1 6>ASP.NET Core ConfigureServices https://www.cnblogs.com/artech/p/dependency-injection-in-asp-net-core.html https://www.cnblogs.com/dotNETCoreSG/p/aspnetcore-3_1-application-startup.html https://blog.csdn.net/weixin_30604651/article/details/98671957 6-1>拓展知识 ASP.NET Core中的依赖注入（1）：控制反转（IoC）(https://www.cnblogs.com/artech/p/asp-net-core-di-ioc.html) ASP.NET Core中的依赖注入（2）：依赖注入（DI）(https://www.cnblogs.com/artech/p/asp-net-core-di-di.html) ASP.NET Core中的依赖注入（3）: 服务的注册与提供(https://www.cnblogs.com/artech/p/asp-net-core-di-register.html) ASP.NET Core中的依赖注入（4）: 构造函数的选择与服务生命周期管理(https://www.cnblogs.com/artech/p/asp-net-core-di-life-time.html) ASP.NET Core中的依赖注入（5）：ServicePrvider实现揭秘【总体设计】(http://www.cnblogs.com/artech/p/asp-net-core-di-service-provider-1.html) ASP.NET Core中的依赖注入（5）：ServicePrvider实现揭秘【解读ServiceCallSite】(http://www.cnblogs.com/artech/p/asp-net-core-di-service-provider-2.html) ASP.NET Core中的依赖注入（5）：ServicePrvider实现揭秘【补充漏掉的细节】(http://www.cnblogs.com/artech/p/asp-net-core-di-service-provider-3.html) 6-2>ConfigureServices允许返回一个ServiceProvider，这个特性的重要意义在于它使我们可以实现与第三方DI框架（比如Unity、Castle、Ninject和AutoFac等）的集成。 *3.X 引入autofac第三方依赖注入框架 https://www.cnblogs.com/oec2003/p/13069058.html https://www.cnblogs.com/diwu0510/p/11562248.html https://www.cnblogs.com/ingstyle/p/11836157.html https://www.cnblogs.com/zxtceq/p/14156142.html 步骤： 6-2-1>引入Nuget包, Autofac, Autofac.Extensions.DependencyInjection, Autofac.Extras.DynamicProxy 6-2-2>修改Program.cs, 加入 .UseServiceProviderFactory(new AutofacServiceProviderFactory()) 6-2-3>修改Startup, 添加方法 ConfigureContainer public void ConfigureContainer(ContainerBuilder builder) { //注册依赖注入模块 builder.RegisterModule ( new AutofacModuleRegister ( FramePublicFun.GetDllPath(), new List { \"Dylan.FrameWork.dll\" }, true, typeof(Program) ) ); } 6-2-4>配置Controller全部由Autofac创建(若不配置，则Controller的依赖注入由原本的框架实现) 在Startup.ConfigureServices中配置 services.AddControllersWithViews().AddControllersAsServices(); 并在ConfigureContainer中添加如下代码，实现控制器的属性注入(也可以封装到批量注册的Load函数内) var controllerBaseType = typeof(ControllerBase); builder.RegisterAssemblyTypes(typeof(Program).Assembly) .Where(t => controllerBaseType.IsAssignableFrom(t) && t != controllerBaseType) .PropertiesAutowired(); 6-2-5>在控制器中使用Autofac依赖注入 可以在构造函数获取依赖注入的对象 在Action可以通过[FromServices]参数，来获取依赖注入的对象 *可以使用属性注入，属性一定要为public /// /// 属性注入 /// public ITestClass TestClassP { get; set; } 6-2-6>在其他类中使用依赖注入, 可是使用构造函数的依赖注入, 以及属性的依赖注入, 属性依赖注规则与控制器相同。 6-2-7>设置全局AutofacContainer https://blog.csdn.net/sammy520/article/details/114417763 6-2-8>面向AOP，就是使用接口拦截, 拦截器注册要在使用拦截器的接口和类型之前, 在接口上添加拦截器，当调用接口的方法时，都会进入拦截器。 *控制器慎用AOP，容易报错，更建议用框架自带的filter特性 6-2-9>IServiceProvider和IComponentContext获取到的服务实例与依赖注入的实例对象一致，可是使用全局的AutofacContainer获取到的服务实例与依赖注入的实例对象不一致，建议使用IServiceProvider和IComponentContext获取服务实例。 6-2-10>一个接口，多个实现的服务注册解决方案参考下面文章 https://www.cnblogs.com/netcs/p/12889834.html 6-2-11>Autofac依赖注入还可以使用json格式的配置文件实现，参考https://www.limitcode.com/detail/5f1406baed56b80fe4cc1d0a.html { \"defaultAssembly\": \"AspNetCore.Ioc.Interface\", //接口所在的程序集名称 \"components\": [ { \"type\": \"AspNetCore.Ioc.Service.UserService,AspNetCore.Ioc.Service\", //接口的实现 全名称 \"services\": [ { \"type\": \"AspNetCore.Ioc.Interface.IUserService\" // 接口的全名称 } ], \"instanceScope\": \"single-instance\", //单例生命周期 \"injectProperties\": true //是否支持属性注入 }, { \"type\": \"AspNetCore.Ioc.Service.ProductService,AspNetCore.Ioc.Service\", //接口的实现 全名称 \"services\": [ { \"type\": \"AspNetCore.Ioc.Interface.IProductService\" // 接口的全名称 } ], \"instanceScope\": \"single-instance\", //单例生命周期 \"injectProperties\": true //是否支持属性注入 } ] } protected override void Load(ContainerBuilder builder) { //Autofac 基于配置文件的服务注册 IConfigurationBuilder configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddJsonFile(\"Config/autofac.json\"); IConfigurationRoot root = configurationBuilder.Build(); //开始读取配置文件中的内容 ConfigurationModule module = new ConfigurationModule(root); //根据配置文件的内容注册服务 builder.RegisterModule(module); } 7>主机 7-1>通用主机(可在控制台等程序, 使用依赖注入, 配置, 日志等功能) 7-1-1>参考 https://www.cnblogs.com/hopesun/p/12247674.html https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.1 https://www.cnblogs.com/jionsoft/p/12154519.html https://www.cnblogs.com/jionsoft/p/12164480.html https://www.cnblogs.com/edison0621/p/11025310.html *https://www.cnblogs.com/MrHSR/p/10320694.html https://www.cnblogs.com/zuowj/p/11107243.html 7-1-2>.NetCore中的IHostedService https://www.cnblogs.com/uoyo/p/12377645.html https://www.cnblogs.com/catcher1994/p/9961228.html https://www.cnblogs.com/tianyamoon/p/10094802.html 7-1-3>以下demo实现了控制台的主机优雅写法，并实现了简单的定时功能。 /// /// 入口 /// /// 传入参数 /// public static async Task Main(string[] args) { await CreateHostBuilder(args).UseConsoleLifetime().Build().RunAsync(); //下面的方法等同于上面 //await CreateHostBuilder(args).RunConsoleAsync(); } /// /// 创建泛型主机 /// /// 传入参数 /// public static IHostBuilder CreateHostBuilder(string[] args) => Host.CreateDefaultBuilder(args) .ConfigureHostConfiguration(configurationBuilder => { configurationBuilder.SetBasePath(FramePublicFun.GetDllPath()); configurationBuilder.AddJsonFile(SysContant.Hostsettings_FileName, optional: true, reloadOnChange: true); configurationBuilder.AddEnvironmentVariables(prefix: SysContant.Setting_Prefix); configurationBuilder.AddCommandLine((args ?? new string[] { })); }) .ConfigureAppConfiguration((hostBuilderContext, configurationBuilder) => { Console.WriteLine($\"hostBuilderContext.HostingEnvironment.EnvironmentName:{hostBuilderContext.HostingEnvironment.EnvironmentName}\"); configurationBuilder.AddJsonFile(SysContant.Appsettings_FileName, optional: true, reloadOnChange: true); var appsettingsFileNameArr = SysContant.Appsettings_FileName.Split(new[] { \".\" }, StringSplitOptions.RemoveEmptyEntries) ?? new string[] { }; var appsettingsFileNamePrefix = appsettingsFileNameArr.Length != 2 ? \"appsettings\" : appsettingsFileNameArr[0]; var appsettingsFileNameExtension = appsettingsFileNameArr.Length != 2 ? \"json\" : appsettingsFileNameArr[1]; configurationBuilder.AddJsonFile ( $\"{appsettingsFileNamePrefix}.{hostBuilderContext.HostingEnvironment.EnvironmentName}.{appsettingsFileNameExtension}\", optional: true, reloadOnChange: true ); configurationBuilder.AddEnvironmentVariables(prefix: SysContant.Setting_Prefix); configurationBuilder.AddCommandLine(args); }) .ConfigureLogging((hostBuilderContext, loggingBuilder) => { loggingBuilder.AddFilter(\"System\", LogLevel.Warning); loggingBuilder.AddFilter(\"Microsoft\", LogLevel.Warning); var cfgFilePath = Path.Combine(FramePublicFun.GetDllPath(), SysContant.Log4Net_CfgFileName); loggingBuilder.AddLog4Net(cfgFilePath); }) //.ConfigureServices((hostBuilderContext, services) => //{ // services.AddHostedService(); // services.AddHostedService(); //}); .UseHostedService() .UseHostedService(); *个人对Task.CompletedTask/Task.FromResult 和 Task.Run 的理解 Task.CompletedTask/Task.FromResult是为了返回Task类型, 使用这两个的所在逻辑, 实际是同步执行的, 而Task.Run是确实单独开了一个线程, 异步执行逻辑. 因此, 比如某个接口定义了Task方法, 可是在实现类实现的时候, 发现方法的业务逻辑很简单, 就没必要使用Task.Run, 可以直接使用Task.CompletedTask/Task.FromResult. 7-2>Web主机(在3.x版本) 主机配置独立出了web主机配置, ConfigureWebHostDefaults, 跟web主机相关的配置, 如Configure. 7-2-1>Kestrel的配置, 可以在ConfigureWebHostDefaults内使用webBuilder.ConfigureKestrel配置, 也可以在ConfigureServices里加载配置文件. services.Configure(Configuration.GetSection(\"Kestrel\")) 7-2-2>kestrelServerOptions.Limits.MaxRequestBodySize = null; //这个配置用于设置请求正文允许请求的大小, null为不限制大小。也可以在控制器的Action上, 使用[RequestSizeLimit(100000000)]来为每个Action指定不同的允许请求大小. 7-2-3>Kestrel其他配置参考官网https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1#kestrel-options. 8>配置 & 选项 https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1 https://www.cnblogs.com/MrHSR/p/10281426.html https://www.cnblogs.com/MrHSR/p/10285906.html https://www.cnblogs.com/guzhanyu/p/9004063.html https://www.tnblog.net/aojiancc/article/details/3239 https://www.tnblog.net/%E7%A0%81%E5%86%9C%E6%80%9D%E7%91%9E%E4%B8%8D%E5%A7%93%E5%BC%A0/article/details/6243 8-1> 配置来源提供程序的顺序 文件 (appsettings.json, appsettings.{Environment}.json, 其中{Environment}是应用的当前托管环境) Azure 密钥保管库 用户机密(Secret Manager) (仅限开发环境中) 环境变量 命令行参数 通常的做法是将命令行配置提供程序置于一系列提供程序的末尾, 以允许命令行参数替代由其他提供程序设置的配置. 在使用 CreateDefaultBuilder 初始化新的 WebHostBuilder 时，将使用此提供程序序列. 8-2>配置约定 1) 配置来源中的键有以下约定: 键不区分大小写, 比如用GetSection读取时, 可以不管大小写; 配置来源中设置相同键的值, 则取配置来源中键上设置的最后一个值. 比如appsettings.json与appsettings.{Environment}.json多个配置来源文件; 分层键, 如在json文件中多个节点, 冒号分隔符(:)适用于所有平台. 而在环境变量的来源配置中, 所有平台均支持采用双下划线 (__); ConfigurationBinder 支持使用配置键中的数组索引将数组绑定到类对象; 2) 配置值采用以下约定： 值是字符串; NULL值不能存储在配置中或绑定到对象; 8-3>获取配置值的几种方式 (先通过依赖注入获取IConfiguration Configuration) 8-3-1>直接获取 var lifetime = Configuration[\"Logging:LogLevel:Microsoft.Hosting.Lifetime\"]; var dbType = Configuration.GetSection(\"DBConnectionInfo\").GetValue(\"DBType\", \"MySQL\"); var connStr = Configuration.GetValue(\"DBConnectionInfo:ConnStr\", \"EmptyConnStr\"); var noExistKey = Configuration.GetValue(\"DBConnectionInfo:NoKey\", \"DefaultValue\"); **一定要注意, 直接获取的方式只能获取到最底层key的值, 如果查询的key对应的值是object或者list, 那么返回值都是空!!! 8-3-2>实例化实体获取 /// /// 用于承载配置项 /// public class DBConnectionInfo { /// /// 必须有公开的无参构造函数 /// public DBConnectionInfo() { } /// /// 需要设置get;set; /// public string Version { get; set; } = \"5.3\"; public string DBType { get; set; } public string ConnStr { get; set; } } var dbConnectionInfo1 = new DBConnectionInfo(); Configuration.GetSection(\"DBConnectionInfo\").Bind(dbConnectionInfo1); //获取用Get<> var dbConnectionInfo2 = Configuration.GetSection(\"DBConnectionInfo\").Get(); 8-3-3>在ConfigureServices使用services.Configure(Configuration.GetSection(\"\"))来注册配置, 后续可使用IOptions options来获取依赖注入的配置对象, 可以将所有的配置抽到拓展方法类中统一管理. *比如在appsettings.{Environment}.json的根节点上设置设置一个key(SystemConfig), 将系统所有的参数配置在这个key底下, 然后通过依赖注入, 再后续的其他地方使用. 结合IOptionsSnapshot, 可以实现当配置文件修改后, 马上获取到新的值. 另外,需要修改后马上生效的文件,reloadOnChange一定要设置成true. /// /// ServiceCollection拓展 /// public static class ServiceCollectionExtension { /// /// 添加自定义配置 /// /// 服务集合 /// 配置对象 /// public static IServiceCollection AddCustomConfig(this IServiceCollection serviceCollection, IConfiguration configuration) { if (serviceCollection == null) { throw new ArgumentNullException(nameof(serviceCollection)); } if (configuration == null) { throw new ArgumentNullException(nameof(configuration)); } return serviceCollection.Configure(configuration.GetSection(nameof(SystemConfig))); //return serviceCollection.Configure(configuration.GetSection(SysContant.Configuration_Section_SystemConfig)); } } /// /// 系统配置 /// public IOptions SystemConfigOption { get; set; } public IOptionsSnapshot SystemConfigOption { get; set; } 获取对象配置对象值 SystemConfigOption.Value 8-3-4>IOptions, IOptionsSnapshot, IOptionsMonitor https://www.cnblogs.com/mq0036/p/14552315.html https://www.cnblogs.com/wenhx/p/ioptions-ioptionsmonitor-and-ioptionssnapshot.html https://blog.csdn.net/u011473324/article/details/108768675 IOptions<>是全局单例, 因此一旦生成了, 除非通过代码的方式更改, 否则它的值是不会更新的. IOptionsMonitor<>也是单例, 但是它通过IOptionsChangeTokenSource<> 能够和配置文件一起更新, 也能通过代码的方式更改值. IOptionsSnapshot<>是范围, 所以在配置文件更新的下一次访问, 它的值会更新, 但是它不能跨范围通过代码的方式更改值, 只能在当前范围（请求）内有效.(在web环境下,每次请求, 重新读取一次配置文件). 8-4>环境变量配置 通用主机变量：https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.1 Web主机变量: https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.1 8-5>命令行参数 8-5-1>配置自变量示例 dotnet run CommandLineKey1=value1 --CommandLineKey2=value2 /CommandLineKey3=value3 dotnet run --CommandLineKey1 value1 /CommandLineKey2 value2 dotnet run CommandLineKey1= CommandLineKey2=value2 8-5-2>key交换映射 交换映射字典键规则：(1)交换必须以单划线 (-) 或双划线 (--) 开头 。(2) 交换映射字典不得包含重复键。 public static readonly Dictionary _switchMappings = new Dictionary { { \"-CLKey1\", \"CommandLineKey1\" }, { \"-CLKey2\", \"CommandLineKey2\" } }; config.AddCommandLine(args, _switchMappings); 8-6>文件配置提供程序AddJsonFile(常用), AddIniFile, AddXmlFile 8-7>Key-per-file 配置提供程序 AddKeyPerFile(没用过), 需要可以参考: https://www.cnblogs.com/MrHSR/p/10285906.html 8-8>内存配置提供程序AddInMemoryCollection /// /// 构建内存对象的键值对 /// public static readonly Dictionary _dict = new Dictionary { {\"MemoryCollectionKey1\", \"value1\"}, {\"MemoryCollectionKey2\", \"value2\"} }; config.AddInMemoryCollection(_dict); 8-9>配置常用读取方法(GetValue、GetSection、GetChildren 和 Exists) 8-9-1>GetValue ConfigurationBinder.GetValue 从具有指定键的配置中提取一个值，并将其转换为指定类型。 如果未找到该键，则重载允许你提供默认值。 以下示例使用键 NumberKey 从配置中提取字符串值，键入该值作为 int，并将值存储在变量 intValue 中。 如果在配置键中找不到 NumberKey，则 intValue 会接收 99 的默认值。 var intValue = config.GetValue(\"NumberKey\", 99); 8-9-2>GetSection IConfiguration.GetSection 使用指定的子节键提取配置子节。GetSection 永远不会返回 null。 如果找不到匹配的节，则返回空 IConfigurationSection。 8-9-3>GetChildren { \"section0\": { \"key0\": \"value\", \"key1\": \"value\" }, \"section1\": { \"key0\": \"value\", \"key1\": \"value\" }, \"section2\": { \"subsection0\" : { \"key0\": \"value\", \"key1\": \"value\" }, \"subsection1\" : { \"key0\": \"value\", \"key1\": \"value\" } } } //在上面的json结构中，获取section2下面的子节点 var configSection = _config.GetSection(\"section2\"); var children = configSection.GetChildren(); 8-9-4>Exists //在上面的json结构中，确定配置节是否存在, 为false，是因为配置数据中没有 section2:subsection2 节点 var sectionExists = _config.GetSection(\"section2:subsection2\").Exists(); 8-10>自定义配置提供程序 用实体框架 (EF) 创建从数据库读取配置键值对的基本配置提供程序(参考官方例子) https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-5.0 9>路由 9-1>MVC框架路由 9-1-1>设置路由中间件 app.UseMvc(routes => { routes.MapRoute ( name: \"default\", template: \"{controller=Home}/{action=Index}/{id?}\" ); }); 等效于 app.UseMvcWithDefaultRoute(); 9-1-2>传统路由 *传统路由格式：{controller=Home}/{action=Index}/{id?} *可以添加多个路由映射, 系统按添加顺序进行处理, 因此在此示例中, 将先尝试 blog 路由, 再尝试 default 路由. app.UseMvc(routes => { routes.MapRoute ( \"blog\", \"blog/{*article}\", defaults: new { controller = \"Blog\", action = \"Article\" } ); routes.MapRoute(\"default\", \"{controller=Home}/{action=Index}/{id?}\"); }); *action操作的区分 在处理url请求时, 当通过路由匹配到一个控制器内两项相同的action名称时, mvc必须进行区分, 解决方案是将要提交的action加上 Http 谓词为 POST. 这样post过来时, 就会选择Edit(int, Product). public class ProductsController : Controller { public IActionResult Edit(int id) {} [HttpPost] public IActionResult Edit(int id, Product product) {} } 9-1-3>属性路由 [Route(\"\")] [Route(\"Blog\")] [Route(\"Blog/ArticleList\")] public IActionResult Article() { return View(); } *使用 Http[Verb] 属性的属性路由 HttpGet(\"/products\")] public IActionResult ListProducts(){} [HttpPost(\"/products\")] public IActionResult CreateProduct(){} *路由合并 若要使属性路由减少重复, 可将控制器Controller上的路由属性与各个操作Action上的路由属性合并. 控制器上定义的所有路由模板均作为操作上路由模板的前缀. 一旦在控制器上放置路由属性, 则控制器中的所有操作都需要使用属性路由. [Route(\"Home\")] public class HomeController : Controller { [Route(\"\")] // Combines to define the route template \"Home\" [Route(\"Index\")] // Combines to define the route template \"Home/Index\" [Route(\"/\")] // Doesn't combine, defines the route template \"\" public IActionResult Index() { } } *属性路由参数约束 [HttpGet(\"Blog/{id}\", Name = \"Blog_GetArticle\")] [HttpGet(\"Blog/GetArticle/{id:int}\")] public IActionResult GetArticle(int id) { return Json(new { Name = $\"Article:{id}\" }); } *自定义路由属性 public class MyApiControllerAttribute : Attribute, IRouteTemplateProvider { //实现接口的三个属性，这里的[controller]是一个标记替换。 public string Template => \"api/[controller]/{action}/{id?}\"; public int? Order { get; set; } public string Name { get; set; } } public class ProductsApiController : Controller { // GET api/values/5 // [HttpGet(\"{id}\")] [MyApiController()] public string Get(int id) { return \"value\"; } } 通过访问url: http://localhost:30081/api/ProductsApi/get/1 来调用get方法. 9-1-4>用代码的方式控制URL 9-1-4-1>传统路由下的url生成 Url.Action配合各种参数, 用于生成url. [Route(\"/\")] [HttpGet(\"Blog/TestUrlFunc\")] public IActionResult TestUrlFunc() { //var url = Url.Action(\"TestOptions\", \"Home\"); var url = Url.Action(\"GetArticle\", new { id = 10 }); return Json(new { Name = \"HttpGet TestUrlFunc\", url }); } *Redirect 和 RedirectToAction 用于跳转到页面. [HttpGet(\"Blog/Jump2Page\")] public IActionResult TestJump2OtherPage() { //return Redirect(\"/Home/TestConfig\"); return RedirectToAction(\"TestConfig\", \"Home\"); } 9-1-5>area 区域路由 app.UseEndpoints(endpointRouteBuilder => { //endpointRouteBuilder.MapControllerRoute //( // name: \"blog\", // pattern: \"blog/{*article}\", // defaults:new // { // controller = \"Blog\", // action = \"Article\" // } //); endpointRouteBuilder.MapAreaControllerRoute ( name: \"github_blog\", areaName: \"GithubBlog\", pattern: \"github/{controller}/{action}/{id?}\" ); endpointRouteBuilder.MapControllerRoute ( name: \"default\", pattern: \"{controller=Home}/{action=index}/{id?}\" //pattern: \"{controller}/{action}/{id?}\" ); }); [Area(\"GithubBlog\")] public class BlogController : BaseController { } 9-1-6>IActionConstraint 路由约束 在下面的示例中, 约束基于路由数据中的国家/地区代码选择操作, 开发人员负责实现Accept方法，当路由中id值为en-US时Accept方法返回true以表示该操作是匹配项, 一切按正常解析返回客户端. 如果Accept方法返回false将不执行IActionConstraint标记的action, 向客户端返回404错误. //定义ActionConstraint属性约束 public class CountrySpecificAttribute : Attribute, IActionConstraint { private readonly string _countryCode; public CountrySpecificAttribute(string countryCode) { _countryCode = countryCode; } public int Order { get { return 0; } } public bool Accept(ActionConstraintContext context) { return string.Equals( context.RouteContext.RouteData.Values[\"id\"].ToString(), _countryCode, StringComparison.OrdinalIgnoreCase); } } //应用路由的action约束，并且路由中id值为en-US [CountrySpecific(\"en-US\")] public IActionResult Privacy(string countryCode) { return View(); } 9-2>Razor框架路由(基本做的项目是前后端分离, 想了解的可以参考 https://www.cnblogs.com/MrHSR/p/10265458.html) 10>错误处理 10-1>配置开发环境异常页 if (env.IsDevelopment()) { //注意: 调用该方法，要放在对其捕获异常的任何中间件前面 app.UseDeveloperExceptionPage(); } 10-2>配置自定义异常处理页 配置自定义异常处理页,用于非 Development 环境下, 下面是razor项目中的异常处理页代码(Pages下Error.cshtml页面). if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { app.UseExceptionHandler(\"/error\"); } 10-3>配置状态代码页 //请求处理中间件之前调用 app.UseStatusCodePages(); 10-4>UseStatusCodePagesWithRedirects重定向 该中间件作用是: (1)向客户端发送302状态码; (2)将客户端重定向到 URL 模板中的位置. /当没有正文的响应时, 重定向到指定页面, {0}表示请求出错的http的状态码 app.UseStatusCodePagesWithRedirects(\"/error/{0}\"); Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"NetCore/Net_Index.html":{"url":"NetCore/Net_Index.html","title":"Net_Index","keywords":"","body":"Log4Net, Autofac, EF Core, Dapper, Fluent API, AutoMapper, Mapster, Swagger UI, jwt, ids4, MemoryCache, Redis, MySQL, Polly, Consul, RabbitMQ, MongoDB, gRPC, Websocket, SkyWalking, Ocelot, Hangfire, Quartz, Docker, Nginx, Elasticsearch, nunit, xunit, k8s, selenuim, Playwright ASP.NET Core开发者路线图RoadMap 1>vs插件 1-1>ILSpy - 在vs中打开ILSpy查看源码 1-2>Night Owl - 主题 1-3>Color Theme Editor - 主题 1-4>Gitee Extension for Visual Studio - Gitee源代码管理 2>工具 & 开源项目 2-1>Typora–可能是最好用的本地Markdown工具 https://wiki.eryajf.net/pages/2921.html https://wiki.eryajf.net/pages/2852.html 2-2>Git常用命令 https://blog.csdn.net/web_csdn_share/article/details/79243308 2-3>vs2019利用gitee（码云）协作开发 https://blog.csdn.net/promsing/article/details/109180132 2-4>开源项目 2-4-1>开源工作流项目 OpenAuth.Core - 是基于 .Net Core/.Net 5 的开源权限工作流快速开发框架(IdentityServer、EF core、Quartz、AutoFac、WebAPI、Swagger、Mock、NUnit、VUE、Element-ui等) http://doc.openauth.net.cn/core https://gitee.com/yubaolee/OpenAuth.Core/tree/master 2-4-2>YuebonCore快速开发框架 http://docs.v.yuebon.com/guide https://gitee.com/yuebon/YuebonNetCore 2-4-3>Admin.NET https://gitee.com/zuohuaijun/Admin.NET 2-4-4>Furion https://dotnetchina.gitee.io/furion https://gitee.com/dotnetchina/Furion 2-4-5>NanoFabric https://github.com/geffzhang/NanoFabric 3>功能 & bug fix 3-1>asp net core 上传文件 https://cloud.tencent.com/developer/article/1079438 3-2>.NET Core中实现自动注入、批量注入 https://blog.csdn.net/qq_27559331/article/details/108071343 3-3>.net core实现批量依赖注入 https://www.cnblogs.com/Yuuuuu/p/12017180.html 3-4>处理错误Unable to resolve service for type 'Microsoft.AspNetCore.Http.IHttpContextAccessor' while attempting https://blog.csdn.net/xingkongtianyuzhao/article/details/101918729 3-5>isAssignableFrom()方法与instanceof关键字的区别 https://www.cnblogs.com/hetaoyuan/articles/12321361.html 3-6>.net core 针对session遇到的问题 https://www.jianshu.com/p/14c9e8cfff42 3-7>Position 和 Seek 方法的区别 https://www.cnblogs.com/qiqigou/p/13710529.html 3-8>.net core 接口返回图片并且进行压缩 https://www.cnblogs.com/wintertone/p/12927561.html 3-9>.Net Core不错的开源项目 https://www.zhihu.com/question/295227280/answer/1333085582 3-10>Coldairarrow Net Core开源项目 https://github.com/Coldairarrow 3-11>net core中获取用户请求ip地址 https://www.tnblog.net/aojiancc2/article/details/2514 3-12>使用nginx后net core无法获取ip问题 https://www.tnblog.net/aojiancc2/article/details/2517 3-13>C# 将object类型转换成List https://blog.csdn.net/weixin_43632687/article/details/117464442 3-14>ASP.NET Core中GetService（）和GetRequiredService（）之间的区别 https://www.cnblogs.com/yilezhu/p/11107648.html 4>Net Core基础 4-1>Net Core 官方中文文档 https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1 4-2>ASP.NET Core 中文文档目录 https://www.cnblogs.com/dotNETCoreSG/p/aspnetcore-index.html *4-3>【5min+】后台任务的积木。.NetCore中的IHostedService https://www.cnblogs.com/uoyo/p/12377645.html 4-4>Asp.Net Core MVC 响应结果IActionResult分析 https://blog.csdn.net/diamondsos/article/details/88741242 4-5>在 .NET Core 3.0 中支持 Newtonsoft.Json 的使用 https://www.cnblogs.com/szw/p/11594201.html *4-6>dotnet静态方法注入 https://www.cnblogs.com/wjl910/articles/10399555.html https://www.it1352.com/2232433.html https://www.cnblogs.com/Tassdar/p/9816946.html *4-7>AddMvcCore，AddControllers，AddControllersWithViews，AddRazorPages的区别 https://blog.csdn.net/linshunhuang1/article/details/106731326 4-8>.net core之向API传参使用Attribute的五种方式 https://blog.csdn.net/csdn2990/article/details/120262401 4-9>[FromHeader],[FromQuery],[FromRoute],[FromForm],[FromBody]用法场景及原理 https://www.iaspnetcore.com/Blog/BlogPost/594960eb84cd453380655bc9/aspnet-core-mvc-model-binding-fromheader-fromquery-fromroute-fromform-usage-scenarios-and-principles 4-10>.NET Core中的一个接口多种实现的依赖注入与动态选择看这篇就够了 https://www.cnblogs.com/yilezhu/p/10236163.html 5>Docker 5-1>ASP.NET Core Web MVC项目创建支持Docker发布 https://blog.csdn.net/boonya/article/details/82682520 5-2>使用docker部署Asp.net core web应用程序 https://www.cnblogs.com/subendong/p/8992285.html 5-3>net core web api部署到docker https://www.cnblogs.com/luoocean/p/11100684.html 6>Autofac 6-1>Autofac容器对象实例的几种生命周期类型 https://www.cnblogs.com/stulzq/p/8547277.html 6-2>.Net Core 学习之路-AutoFac的使用 https://www.cnblogs.com/bluesummer/p/8875702.html 6-3>处理 autofac 一个接口多个实现的情况 https://www.cnblogs.com/netcs/p/12889834.html https://www.limitcode.com/detail/5f1406baed56b80fe4cc1d0a.html 6-4>【.NET Core】使用autofac实现AOP拦截 记录所有执行方法 https://blog.csdn.net/weixin_38211198/article/details/105925821 6-5>官网 https://github.com/autofac/Autofac https://autofac.readthedocs.io/en/latest/ https://autofac.org/apidoc/html/62C594FF.htm 6-6>Autofac 依赖注入框架 使用 https://www.cnblogs.com/jys509/p/4649798.html https://www.cnblogs.com/manglu/p/4115128.html 6-7>AutoFac使用方法总结 http://niuyi.github.io/blog/2012/04/06/autofac-by-unit-test/ http://niuyi.github.io/blog/2012/04/06/autofac-by-unit-test-2/ http://niuyi.github.io/blog/2012/04/06/autofact-by-unit-test3/ 7>AutoMapper 7-1>automapper https://www.cnblogs.com/keatkeat/p/10041574.html 8>Mapster 8-1>Mapster https://www.cnblogs.com/uoyo/p/12342290.html 8-2>[非专业翻译] 高性能对象映射框架 - Mapster https://www.cnblogs.com/staneee/p/14912794.html 9>EF Core 9-1>EF Core 相关的千倍性能之差： AutoMapper ProjectTo VS Mapster ProjectToType https://www.cnblogs.com/dudu/p/10449485.html 9-2>好大一个坑： EF Core 异步读取大字符串字段比同步慢100多倍 https://www.cnblogs.com/dudu/p/10423126.html 9-3>EF Core官网教程 https://docs.microsoft.com/zh-cn/ef/core/ 9-4>Entity Framework Core 3.1 极简入门教程（完结） https://www.bilibili.com/video/BV1xa4y1v7rR 9-5>ASP.NET MVC+EF实现如何驾驭超复杂业务逻辑而不失漂亮的代码 https://www.bilibili.com/video/BV12v411b7yF 9-6>EF Core 3.1 系列 asp.net core 系列 19 EFCore介绍 asp.net core 系列 20 EF基于数据模型创建数据库 asp.net core 系列 21 EF现有数据库进行反向工程 asp.net core 系列 22 EF(连接字符串,连接复原,DbContext) asp.net core系列 23 EF模型配置(概述, 类型和属性的包含与排除) asp.net core系列 24 EF模型配置(主键,生成值,最大长度,并发标记) asp.net core系列 25 EF模型配置(隐藏属性) asp.net core系列 26 EF模型配置(实体关系) asp.net core系列 27 EF模型配置(索引,备用键,继承) asp.net core系列 28 EF模型配置(字段,构造函数，拥有实体类型) asp.net core系列 29 EF模型配置(查询类型,关系数据库建模) asp.net core系列 30 EF管理数据库架构--必备知识 迁移 asp.net core系列 31 EF管理数据库架构--必备知识 反向工程 asp.net core系列 32 EF查询数据 必备知识(1) asp.net core系列 33 EF查询数据 (2) asp.net core系列 34 EF保存数据(1) asp.net core系列 35 EF保存数据(2) -- EF系列结束 10>Polly 10-1>Net Core Polly https://blog.csdn.net/qq_28242451/article/details/104818969 https://blog.csdn.net/u011210017/article/details/104213454 11>FluentAPI 11-1>FluentAPI详细用法 https://www.cnblogs.com/wangshaod/p/10025836.html 11-2>官网 https://www.learnentityframeworkcore.com/configuration/fluent-api 12>IdentityServer4 12-1>IdentityServer4 中文文档与实战（添加了PPT资料） https://www.cnblogs.com/stulzq/p/8119928.html 12-2>【ASP.NET Core分布式项目实战】（一）IdentityServer4登录中心、oauth密码模式identity server4实现 https://www.cnblogs.com/wyt007/p/8284482.html 12-3>IdentityServer4 https://docs.identityserver.io/en/latest/index.html 12-4>微软 MVP IDS4 视频教程系列 https://www.bilibili.com/video/BV16b411k7yM 13>Nginx https://www.cnblogs.com/zouzou-busy/p/11827511.html https://blog.csdn.net/comway_Li/article/details/81147427d https://www.jianshu.com/p/d33b0439c3dc https://www.cnblogs.com/zouzou-busy/p/11622784.htmlw https://www.cnblogs.com/muhy/p/10521896.html https://blog.csdn.net/youtiankeng/article/details/111824290 https://blog.csdn.net/yangbo787827967/article/details/88992968 https://zhuanlan.zhihu.com/p/112680766 https://blog.csdn.net/chijiandao3197/article/details/100930171 https://www.yoyomooc.com/Blog/PostList?TagName=%E6%9C%80%E5%A4%9A%E9%98%85%E8%AF%BB https://www.yoyomooc.com/post/yoyomooc/aspnet-core-mvc-in-docker-index 14>MySQL mysql 基础篇系列(23) mysql 进阶篇系列(55) mysql 架构篇系列(3) 15>Git vs2019 设置git忽略文件 16>WebAPI 16-1>ASP.NET Core WebApi使用Swagger生成api说明文档看这篇就够了 https://www.cnblogs.com/yilezhu/p/9241261.html 16-2>【WebAPI】从零开始学会使用.NET Core WebAPI https://www.cnblogs.com/yanbigfeg/p/9262623.html 17>Socket 17-1>SuperSocket https://www.jianshu.com/p/67e415313516/ https://www.supersocket.net/ https://blog.csdn.net/weixin_41181778/article/details/103994362 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-10-31 10:21:12 "},"NetCore/note.html":{"url":"NetCore/note.html","title":"note","keywords":"","body":"C# 执行Javascript脚本 C# 调用JavaScript脚本并进行对象交互（ReoScript） C#执行代码块js脚本 netstat -ano => 查看当前本机的所有端口情况 netstat -aon|findstr 端口号 => netstat -aon|findstr 9002, 查看使用9002端口的进程 tasklist|findstr 进程ID => tasklist|findstr 4, 查看进程id对对应的应用 openai C# netcore sdk & demo openai API接口文档 SQL Server中Text和varchar(max)数据类型区别 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-05-17 16:50:37 "},"NetCore/Polly.html":{"url":"NetCore/Polly.html","title":"Polly","keywords":"","body":"1>相关文章 1-1>Net Core Polly https://blog.csdn.net/qq_28242451/article/details/104818969 https://blog.csdn.net/u011210017/article/details/104213454 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-08 11:14:07 "},"NetCore/大神的博客.html":{"url":"NetCore/大神的博客.html","title":"大神的博客","keywords":"","body":"1>晓晨Master https://www.cnblogs.com/stulzq 2>7tiny https://www.cnblogs.com/7tiny/p/10278261.html 3>花阴偷移 https://www.cnblogs.com/MrHSR 4>句幽 https://www.cnblogs.com/uoyo/default.html 5>edisonchou https://www.cnblogs.com/edisonchou 6>【唐】三三 https://www.cnblogs.com/tangge/category/1352215.html?page=1 7>dudu - 博客园老板 https://www.cnblogs.com/dudu 8>老张的哲学 https://www.cnblogs.com/laozhang-is-phi 9>玩双截棍的熊猫 https://www.cnblogs.com/staneee 10>原来是李 https://www.cnblogs.com/fallTakeMan 11>Jeffcky https://www.cnblogs.com/CreateMyself 12>张占岭 https://www.cnblogs.com/lori/archive/2013/01/22/2871029.html 13>GuZhenYin https://www.cnblogs.com/GuZhenYin 14>依乐祝 https://www.cnblogs.com/yilezhu/ 15>雨夜朦胧 https://www.cnblogs.com/RainingNight/default.html Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-08-17 14:26:15 "},"os/centos.html":{"url":"os/centos.html","title":"centos","keywords":"","body":"1>相关文章 阿里云开源镜像站 阿里DSN解析服务 Linux命令手册 【Linux】- CentOS查看IP Vim基本使用方法 yum和apt-get的区别 wget命令详解 2>远程连接 xshell (推荐) Xshell6绿色免安装破解版本-实际用的这个 SSH客户端 Xmanager Power Suite 6.0.0012r-实测可下 Linux系列-XShell破解版安装教程, 安装包装不上 securtCRT 远程工具securtCRT配置 ssh命令连接 #ssh 账号@ip 端口号(可不写, 默认22) ssh root@192.168.157.128 22 3>linux和win相互传输文件 lrzsz # 安装命令 yum install lrzsz -y # rz: win=>linux, sz: linux=>win # 输入rz后弹框, 将win的文件传到linux rz # 将指定文件传到win sz new_zip_file.zip xftp ftp 4>常用命令 命令格式 命令 空格 条件/参数 空格 对象/条件/目录 rm -f /tmp/testFile.txt 若命令带多个参数时候, 有两种写法 ls -l -h ls -lh whoami 查看当前的登录账号 who 查看有多少用户登录到该系统, 简单显示 w 查看有多少用户登录到该系统, 详细显示 which 用来查询环境变量里的文件的所在目录 which ls which mysql id 验证用户是否存在 # 查看当前的用户信息, 等同whoami id # 验证dylanxu是否存在 id dylanxu su 账号切换 # 推荐这种切换方式 su - root su - dylanxu # 这种方式没有变更环境变量和权限 su root su dylanxu useradd 创建系统用户 useradd testuser1 passwd 设置系统用户密码 passwd testuser1 hostname 查看主机名 hostnamectl 更改主机名 hostnamectl set-hostname dylanxu.centos7 uname 打印系统信息 uname -a man 命令手册 man ls clear 清空命令窗口 pwd 打印当前工作目录, print work directory cd 切换目录 `cd /etc` # 定位到上一次的工作目录 `cd -` ls 打印列表 # -l: 列表方式展示信息 # -h: 已用户 # -d: # -a: # 以用户友好的方式，显示指定目录下的文件及文件夹信息 ls -lh /var/log # 查看当前目录下所有文件, 包含隐藏文件 ls -a # 查看当前文件夹的信息 ls -lhd tree 树形结构显示文件及文件夹信息 如果提示没有tree命令, 则需要安装 ubuntu：sudo apt-get install tree centos：yum -y install tree tree # 只显示以 /（根目录） 开头的目录树的第一级, -L 选项告诉树你想看到多少层目录. tree -L 1/ # -N 显示中文, -F 显示文件类型 tree -FN state 显示文件或文件系统的状态。 touch 创建普通文件 若该目录下，不存在同名文件，则创建新文件 若该目录下，存在同名文件，则更新文件的时间属性 touch /home/dylanxu/test_folder_1/test_file_1.txt # 以点号开头的文件(文件夹), 为隐藏文件(文件夹) touch .test1.txt # 在同级目录下批量创建多个文件 touch ./f_1/{file_1.txt,file_2.txt,file_3.txt} # 批量创建N个文件 touch f_2/temp{1..10}.log rm 删除文件/目录 谨慎使用, 若用的虚机, 请做好快照 删前切换到root账号, 获取最大权限 # -r: 递归删除, 主要用于删除目录, 可删除指定目录及包含的所有内容, 包括所有子目录和文件 # -f: 强制删除, 不提示任何信息, 操作前一定要慎重 # -v: 显示进行的步骤 # -i: 执行删除前, 提示用户是否确认删除 # 递归强制删除文件夹 rm -rfv folder1/ # 强制删除文件 rm -f bb.txt mkdir 创建目录 支持一次创建多个目录 支持创建层级目录 不允许创建同名目录 mkdir /home/dylanxu/test_folder_1 # 一次创建多个文件夹 mkdir test-folder-2 test_folder_3 # 递归创建文件夹 mkdir -p test_folder_4/test_folder_4_1 # 批量创建同级目录 mkdir -p ./f_1/{f_1_1,f_1_2,f_1_3} # 批量创建N个文件夹 mkdir -p f_3/f3_{1..10} rmdir 删除目录 删除空目录, 目录不为空, 则无法删除 rmdir test_fiolder_1 # 一次删除多个文件夹 rmdir t5/t5_1/ t5 cp 复制文件 # f: 如果目标文件无法打开则将其移除并重试 # -r: 递归复制目录及其子目录内的所有内容 # -v: 显示明细信息 # i: 覆盖前询问(使前面的 -n 选项失效) # -l, --link: 链接文件而不复制 # -n: 不要覆盖已存在的文件 # -p --parents: 将目标的父目录结构copy到目标目录 # 将一个文件复制到指定目录下, 保持原来的文件名 cp ./aa.txt test_folder_1/ # 将一个文件复制到指定目录下, 使用新的文件名 cat aa.txt test_folder_1/aa_copy.txt # 备份aa.txt，并在尾部加上.bak后缀 cp test_folder_1/aa.txt{,.bak} # test_folder_3不存在的情况下, 将test_folder_2改名并复制成test_folder_3, 并将test_folder_2内的所有文件及文件夹递归复制到test_folder_3 cp -rfv test_folder_2 test_folder_3 # test_folder_4存在的情况下, 将test_folder_2及其内部所有的内容, 递归复制到test_folder_4 cp -rfv test_folder_2 test_folder_4 # 将aa.txt.clone文件复制到test_folder_5, 并在test_folder_5创建该文件的父目录结构 cp -f -v -p --parents test_folder_4/test_folder_2/aa.txt.clone test_folder_5 mv 剪切, 重命名 # -f: 覆盖前不询问 # -i: 覆盖前询问 # -v: 显示明细信息 # 将aa.txt重命名为hi.txt mv aa.txt hi.txt # 为hi.txt添加后缀.py mv hi.txt{,.py} # 将文件hi.txt.py移动到test_folder_7 mv hi.txt.py ./test_folder_7 # 将cc.txt移动到test_folder_7, 并重命名为cc.txt.bak mv cc.txt ./test_folder_7/cc.txt.bak # 将test_folder_6移动到test_folder_7, 若test_folder_7不存在, 则该命令的作用是将test_folder_6重命名为test_folder_7 mv test_folder_6 test_folder_7 # 将test_folder_7复制到test_folder_8, 并重命名为test_folder_7_clone mv -fv test_folder_7 test_folder_8/test_folder_7_clone ip 查看ip ip address cat 查看文件内容 # -n: 显示行号 cat test-file-1.txt cat -n test_file_0.txt head 默认显示前10行记录 # -n 前N条 head -n 5 test-file-1.txt head -5 test-file-1.txt tail 默认显示前10行记录 # -n 最后N条 tail -n 5 test-file-1.tx tail 5 test-file-1.tx grep 输出包含指定字符串的行 grep 'dylanxu' test-file-1.txt history 查看历史输入的命令, 默认3000条 # -c: 清空记录 # 显示历史记录 history # 清除记录 history -c echo 输出内容 # 单引号内的为纯字符串, 不会当做命令, 而双引号则会将特殊符号识别为命令 echo 'hi dylan' echo ${PATH} echo $name # 将字符串写入到文件 echo 'hi dylan' > test_file_1.txt # 将字符串追加到文件 echo 'good bye' >> test_file_1.txt exit 退出当前账号 logout 退出当前账号 bash 重新加载用户的环境变量, 更新用户的机器信息 ln 创建快捷方式 alias 命令别名 alias的效力仅及于该次登入的操作, 若要每次登入是即自动设好别名，可在/etc/profile或自己的~/.bashrc中设定指令的别名. # 显示所有别名设置 alias # 设置别名 alias cls='clear' alias tree='tress -FN' unalias 删除别名 # 删除指定别名 unalias cls unalias tree tar 将多个文件打包成一个文件 命名规范 .tar: 仅打包 .tar.gz: 打包+压缩 .tgz: 打包+压缩 仅用了打包, 解包不能用-zjJ参数 用什么参数压缩, 就用什么参数解压缩, 如压缩 -czvf , 则解压 -xzvf -f 一定要在最后 # -c: 创建包 # -v: 显示明细信息 # -f: 指定打包的文件名, 必须有这个参数, 且必须在最后一位 # -t: 列出包里的内容 # -u: 更新原打包文件中的文件 # -C: 解压到指定目录 # -x: 解包 # -z: 压缩为.gz格式 # -j: 压缩为.bz2格式 # -J: 压缩为.xz格式 # 将当前文件夹内的所有内容打包到all_file.tar, 不压缩 tar -cvf all_file.tar ./* # 将当前文件夹内的所有内容打包并压缩到all_file.tar tar -czvf all_file.tar.gz ./* # 查看all_file.tar包里的内容 tar -tf all_file.tar # 将压缩包all_file.tar.gz解压到test_folder_9目录 tar -xzvf all_file.tar.gz -C ./test_folder_9 # 将文件robot_1.txt到robot_3.txt文件打包到all_robot.tar, 打包后的文件大小为103M tar -cvf all_robot.tar robot_{1..3}.txt # 将文件robot_1.txt到robot_3.txt文件打包并压缩到all_robot.tar.gz, 打包后的文件大小为15M tar -czvf all_robot.tar.gz robot_{1..3}.txt zip 压缩多个文件或目录 压缩目录需要用-r 包的文件名如果没有后缀.zip, 会自动加上, 不过建议自己加上.zip # -v: 显示明细信息 # -r: 用于压缩文件夹 # 压缩robot_1.txt和robot_2.txt文件到当前目录, 压缩包名称为robot.zip zip robot.zip robot_{1..2}.txt # 若robot.zip存在, 则往压缩包里追加robot_3.txt文件 zip robot.zip robot_3.txt # 压缩robot_1.txt到robot_4.txt文件, 并且将folder_3/递归压缩 zip -rv new_zip_file.zip robot_{1..4}.txt folder_3/ uzip 查看zip包的内容, 测试压缩包是否完整, 解压缩zip包 # -t 检查压缩文件是否正确 # -v: 查看压缩文件信息 # -Z: 查看压缩文件信息 # -d: 将压缩包的内容解压到指定文件夹 # -j: 不处理压缩文件中原有的目录路径。 # -n: 解压缩时不要覆盖原有的文件。 # 校验压缩包正确性 unzip -t new_zip_file.zip # 查看压缩包内容 unzip -v new_zip_file.zip unzip -Z new_zip_file.zip # 解压缩到当前文件夹 unzip new_zip_file.zip # 解压缩到指定文件夹 unzip new_zip_file.zip -d ./tmp rename 将文件重命名 # 将*.txt文件的txt改成html rename txt html temp/*.txt md5sum 获取文件md5值 md5sum new_zip_file.zip wget 是一个下载文件的工具 支持HTTP, HTTPS和FTP协议, 可以使用HTTP代理 可以在用户退出系统的之后在后台执行 支持断点续传, 出错重试 从网络上下载资源, 如果没有指定目录, 则会默认下载到当前目录 # wget [参数] [URL地址] # -b: 启动后转入后台执行 # -v: 显示明细信息 # -t=NUMBER: 设定最大尝试链接次数(0 表示无限制) # -w=SECONDS: 两次尝试之间间隔SECONDS秒 # -nc: 不要覆盖存在的文件或使用 # -c: 接着下载没下载完的文件 # –-limit-rate=RATE 限定下载输率 # 下载并重命名 wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080 # 限速下载 wget --limit-rate=300k http://www.minjieren.com/wordpress-3.1-zh_CN.zip # 断点续传 wget -c http://www.minjieren.com/wordpress-3.1-zh_CN.zip # 后台下载 wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip # 伪装代理名称下载 wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" http://www.minjieren.com/wordpress-3.1-zh_CN.zip # 使用wget –spider测试下载链接 wget --spider URL # 增加重试次数 wget --tries=40 URL # 把下载信息存入日志文件 wget -o download.log URL # 使用wget FTP下载 # 匿名下载 wget ftp-url # 用户名和密码认证的ftp下载 wget --ftp-user=USERNAME --ftp-password=PASSWORD url # 编译安装 tar zxvf wget-1.9.1.tar.gz cd wget-1.9.1 ./configure make make install # 也可使用yum安装 yum install wget -y nmtui 可视化界面配置网络参数 sudo service network restart 重启网络服务 5>vim 简单操作 安装 yum install -y vim 常用命令 # 退出 :q # 强制退出 :q! # 保存 :w # 另存为名为filename文件 :w [filename] # 将另外一个文件读入到正在编辑的文件 :r [filename] # 将n1行到n2行的数据另存为名为filename文件 :n1,n2 w [filename] # 保存并退出 :wq # 保存并强制退出 :wq! # 保存并退出 :x # 跳转到指定行 :行号 # 开启代码高亮 :syntax on # 关闭代码高亮 :syntax off # 开启代码高亮 :syntax enable # 开启搜索高亮 set hlsearch # 关闭搜索高亮 set nohlsearch # 输入搜索字符串的同时进行搜索 set incsearch # 搜索时忽略大小写 set ignorecase # 开启光标位置提示 set ruler # 显示行号 set number # 不显示行号 set nonu # 命令部分高度为1 set cmdheight=1 # 自动缩进 set autoindent # 不自动缩进 set noautoindent # 智能缩进 set smartindent # 当文件在外部被改变时，vim自动更新载入 set autoread # 显示匹配的括号 set showmatch # 删除操作 # 删除光标所在行 dd # 删除从光标所在行开始，向下的n行 ndd # 删除从光标所在行开始，到第一行的所有行 d1G # 删除从光标所在行开始，到最后一行的所有行 dG # 删除从光标所在位置，到行尾的所有字符 d$ # 删除从光标所在位置，到行首的所有字符 d0 # 每按一次，删除光标所在位置的后面一个字符 x # 删除光标所在位置的“后面”n个字符 nx # 大写的X，每按一次，删除光标所在位置的前面一个字符 X # 删除光标所在位置的前面n个字符 nX # 复制操作 # 复制光标所在行 yy # 复制从光标所在行开始，向下的n行 nyy # 复制3行 3yy # 复制从光标所在行开始，到第一行的所有行 y1G # 复制从光标所在行开始，到最后一行的所有行 yG # 复制从光标所在位置，到行尾的所有字符 y$ # 复制从光标所在位置，到行首的所有字符 y0 # 将光标所在行与下一行合并成一行 J # 复制当前光标所在的字母到该单词的最后一个字母 yw # 复制当前光标所在的单词 yaw # 粘贴操作 # 小写字母p，粘贴剪贴板中的数据，从光标所在行的下一行开始 p # 大写字母P，粘贴剪贴板中的数据，从光标所在行的上一行开始 P # 撤销与重做操作 # 撤销上一个操作 u # 重复上一操作 . # 替换操作 # 替换光标所在处字符 r # 进入替换模式，直至按ESC退出 R # 替换光标所在行 cc # 替换光标所在的英文单词 cw # 转换大小写 ~ # 排版操作 # 光标所在行左对齐 :le # 光标所在行右对齐 :ri # 光标所在行居中 :ce # 显示最近在vim里面输入的历史 :history # 向下搜索字符串string /string # 向上搜索字符串string ?string # 粘贴模式 # 进入粘贴模式 :set paste # 退出粘贴模式 :set nopaste 6>yum yum是RedHat系列的高级软件包管理工具 主要功能是更方便的添加/删除/更新RPM包。 能自动解决包的依赖性问题。 能便于管理大量系统的更新问题。 可以同时配置多个资源库(Repository) 简洁的配置文件(/etc/yum.conf) 自动解决增加或删除rpm包时遇到的倚赖性问题 保持与RPM数据库的一致性 # 安装软件包 yum install # 删除软件包 yum remove # 查找软件包 yum search # 列出所有可安装的软件包 yum list # 列出所有可更新的软件包 yum list updates # 列出所有已安装的软件包 yum list installed # 列出所有已安装但不在 Yum Repository 内的软件包 yum list extras # 列出所指定的软件包 yum list 7>wget 8>其他知识点 linux系统大小写敏感 linux不关心扩展名, 用ls -l查看文件权限, 以权限位为准 linux注释符: # Tab补全 指令补全, 命令敲一点, 使用Tab提醒匹配的命令 文件及文件夹(路径)补全, 文件或文件件敲一点, 使用Tab提醒匹配的命令 Linux命令提示符 [dylanxu@localhost ~] dylanxu -> 登录账号 @ -> 占位符 localhost -> 主机名 ~ -> 当前在哪儿个文件夹 文件夹概念 . 当前工作目录 .. 当前工作目录的上层目录 ~ 用户的家目录 - 前一个目录 常见的重要目录 /opt, 第三方软件安装目录 /home, 普通用户家目录 /root, root用户的家目录 /etc, 存放各种配置文件的目录 /var/log, 各种系统日志 变量 param1='dylanxu' # 推荐写法 echo ${param1} # 简写 echo $param1 环境变量 ${PATH} 作用跟win system一样, 以冒号分割的路径字符串, 查找顺序从左往右, 挨个搜索文件夹 # 修改环境变量的值 echo ${PATH} # /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dylanxu/.local/bin:/home/dylanxu/bin PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dylanxu/.local/bin:/home/dylanxu/bin:/home/dylanxu/test-folder-1 echo ${PATH} # /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dylanxu/.local/bin:/home/dylanxu/bin:/home/dylanxu/test-folder-1 ${LANG} 可以修改linux的中英文切换 # en_US.UTF-8 echo ${LANG} # 切换成简体中文 LANG='zh_CN.UTF-8' linux系统文件 /etc初始化系统重要文件 /etc/sysconfig/network-scripts/ifcfg-eth0 网卡配置文件 /etc/resolv.conf linux系统DNS客户端配置文件 /etc/hosts 系统本地的DNS解析文件 /etc/fstab 配置开机设备自动挂载的文件 /etc/rc.local 存放开机自动启动程序命令的文件 /etc/iinittab 系统启动设定运行级别等配置的文件 /etc/profile及/ect/bashrc 配置系统的环境变量/别名等的文件 /etc/profile.d 用户登录后执行的脚本所在的目录 /etc/issue和/etc/issue.net 配置在用户登录中断前显示信息的文件 /usr/lib/systemd/system 软件启动从恒旭所在的目录 /etc/motd 配置用户登录系统自后显示提示内容的文件 /etc/redhat-release 声明redhat版本号和名称信息的文件 /etc/sysctl.conf linux内核参数设置文件 /proc重要路径 /proc/meminfo 系统内存信息 /proc/cpuinfo 关于处理器的信息, 如类型, 厂家, 型号, 性能等 文件(夹)命名规则 区分大小写 尽量都用小写字母 如果需要对文件名进行分割, 使用_ 长度不能超过255字符 文件尽量给正确的拓展名, 易于查看 linux分2个大类 RedHat系列: Redhat、Centos、Fedora 等 常见的安装包格式 rpm, 安装rpm包的命令是 rpm -参数 包管理工具 yum 支持 tar 包 Debian系列: Debian、Ubuntu等 常见的安装包格式 deb, 安装deb包的命令是 dpkg -参数 包管理工具 apt-get 支持 tar 包 9>账号 all user pwd: 070806880507 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-15 20:29:22 "},"os/gitbook.html":{"url":"os/gitbook.html","title":"gitbook","keywords":"","body":"I>相关文章 GitBook 使用教程 GitBook讲解 GitBook - 快速打造可留言的博客 gitbook 入门教程之使用 gitbook-cli 开发电子书 搭建Gitbook并通过Git推送部署 发布到Gitee Pages 打造完美写作系统：Gitbook+Github Pages+Github Actions Linux or Mac 安装 gitbook 3.2.3 失败解决方案 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-27 16:14:06 "},"os/nginx.html":{"url":"os/nginx.html","title":"nginx","keywords":"","body":"1>相关文章 Nginx配置-启用gzip压缩，优化网站访问速度 2>常用命令 start nginx (启动) nginx -s stop (快速停止nginx) nginx -s quit (完整有序的停止nginx) nginx -s reload (修改配置文件后使用) nginx -t (测试配置文件是否正确) tasklist /fi \"imagename eq nginx.exe\" (查看nginx是否启动成功) taskkill /f /t /im nginx.exe (强制停止服务) nginx -V (查看nginx配置的模块) netstat -ano => 查看当前本机的所有端口情况 netstat -aon|findstr 端口号 => netstat -aon|findstr 9002, 查看使用9002端口的进程 tasklist|findstr 进程ID => tasklist|findstr 4, 查看进程id对对应的应用 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-12 10:14:38 "},"os/ubuntu.html":{"url":"os/ubuntu.html","title":"ubuntu","keywords":"","body":"1>相关文章 系统镜像下载地址 VMWare虚拟机安装Ubuntu系统1 VMWare虚拟机安装Ubuntu系统2 Win10下安装配置使用WSL2 windows10安装和配置terminal、WSL、putty Windows下安装WSL与升级WSL2的方法 在WSL中启动Ubuntu 20.04时出现错误[出现错误 2147942402 (0x80070002) (启动“ubuntu2004.exe”时)] WSL2出现“参考的对象类型不支持尝试的操作”的解决方法 2>常用命令 2-1>软件操作命令 更新系统数据： sudo apt-get update 更新所有已安装的软件：sudo apt-get upgrade 升级系统：sudo apt-get dist-upgrade 安装软件： sudo apt-get install software 卸载软件:sudo apt-get remove software 卸载并清除配置：sudo apt-getremove --purge sofaware 自动删除长期不需要的软件: sudo apt autoremove 修复依赖命令: sudo apt-get-f install 自动安装（autoconf/automake主要用于创建Makefile）:sudo apt-get install automakeapt-cache search package 搜索包 apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package 安装包 sudo apt-get install package –reinstall 重新安装包 sudo apt-get -f install 强制安装 sudo apt-get remove package 删除包 sudo apt-get remove package –purge 删除包，包括删除配置文件等 sudo apt-get autoremove 自动删除不需要的包 sudo apt-get update 更新源 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-get dselect-upgrade 使用 dselect 升级 apt-cache depends package 了解使用依赖 apt-cache rdepends package 了解某个具体的依赖 sudo apt-get build-dep package 安装相关的编译环境 apt-get source package 下载该包的源代码 sudo apt-get clean && sudo apt-get autoclean 清理下载文件的存档 sudo apt-get check 检查是否有损坏的依赖 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-12 10:12:54 "},"python/note_command.html":{"url":"python/note_command.html","title":"note_command","keywords":"","body":"I. pip & pip3 pip --version 显示pip版本和路径 pip install --upgrade pip pip3 install --upgrade pip 升级 pip (Linux or MacOS) python -m pip install -U pip python -m pip3 install -U pip 升级 pip (Windows) pip install SomePackage 安装包的最新版本 pip install SomePackage==1.0.4 安装包的指定版本 pip install SomePackage>=1.0.4 安装包的最小版本 pip install --upgrade SomePackage 升级包, 可以使用 ==, >, >=, pip install -r requirements.txt 批量安装requirements.txt列出的包 requirements.txt内容如下 flask requests PyYaml pysocks pyDes apscheduler pip freeze > requirements.txt 导出requirements.txt pip uninstall SomePackage 卸载包 pip search SomePackage 搜索包 pip show SomePackage 显示安装的包的信息 pip list 列出已安装的包 pip list -o 查看可升级的包 pip install -i mirror-site some-package 临时使用某个镜像站点安装包 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple Django 临时使用清华镜像站点安装Django pip config set global.index-url mirror-site pip config set install.trusted-host mirrors.aliyun.com 使用命令方式设置默认的镜像站点 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pip config set global.index-url https://mirrors.aliyun.com/pypi/simple pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple pip config set global.index-url http://pypi.douban.com/simple 手动设置镜像源 1.创建配置文件 Windows系统 在%APPDATA%目录下创建pip目录，并在pip目录下创建pip.ini文件。 运行 -> %APPDATA% -> 创建pip目录 -> 创建pip.ini文件 * 其中的%APPDATA%是映射到C:\\Users\\你的用户名\\AppData\\Roaming目录，也可以手动打开该目录 Linux系统 修改~/.pip/pip.conf文件，如果提示不存在，则创建文件。 2.配置安装源信息 在pip.ini或pip.conf文件输入安装源信息： [global] index-url=https://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com 镜像源列表 https://mirrors.aliyun.com/pypi/simple 阿里云 https://pypi.douban.com/simple   豆瓣 https://pypi.tuna.tsinghua.edu.cn/simple 清华大学 https://pypi.hustunique.com/ 华中科技大学 https://pypi.mirrors.ustc.edu.cn/simple 中国科技大学 https://pypi.sdutlinux.org/ 山东理工大学 python -m venv virtual-env-name 创建虚拟空间 python -m venv venv 创建虚拟空间 & e:/2_webend_project/calc-gpt/venv/Scripts/Activate.ps1 手动调用powershell激活脚本, 激活虚拟空间。 若使用vs code, 可手动选择编译环境 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-08 11:11:26 "},"python/note_logic.html":{"url":"python/note_logic.html","title":"note_logic","keywords":"","body":"python官方站点 python 3 菜鸟教程 selenium 【Python爬虫 • selenium】selenium4新版本使用指南 Selenium4+Python3系列- 多窗口处理之句柄切换 Selenium中执行JavaScript脚本 【selenium】执行js脚本 Selenium执行JavaScript脚本的方法示例 Selenium常用API详解，从入门到进阶（上） Python Selenium常用元素操作API Selenium修改默认下载文件路径 selenium如何指定下载目录？ Python Selenium 各浏览器下载到特定文件夹方法总结 selenium 下载文件取消安全下载的配置 python爬虫之selenium--记录日志信息 用selenium解决滑块验证码 Selenium滑动验证码破解（缺口对应却无法通过，需要做鼠标轨迹模拟） Python专题——五分钟带你了解map、reduce和filter python正则表达式 pickle python OrderedDict函数详细介绍 Python定时任务框架APScheduler详解 python静态方法、实例方法、类方法使用 Python函数参数传递 python之异常、异常的捕获、else、finally、主动抛出异常raise Python程序暂停 Python3 数据类型_python判断数据类型 Python filter() 函数 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-15 09:08:22 "},"webend/@vue_cli.html":{"url":"webend/@vue_cli.html","title":"@vue_cli","keywords":"","body":"1>相关文章 日常工作中 @vue/cli 需要关注的一些配置 Vue-cli卸载 Vue Cli官网 2>常用命令 npm install -g @vue/cli npm uninstall -g @vue/cli vue inspect > webpack.config.js 导出 webpack 配置信息(导入到项目目录中)，webpack.config.js 可修改成自定义文件名 vue inspect --mode 输出 指定环境 的配置信息 mode：production、test、development vue inspect --rules 查看所有已配置规则名称列表 vue inspect --rule 查看指定规则 ruleName： 上述数组选项 vue inspect --plugins 查看所有已配置插件列表 vue inspect --plugin 查看指定插件配置 vue inspect -v vue inspect --verbose 显示完整webpack配置 vue inspect -h vue inspect --help 显示帮助信息 vue inspect --mode=production > webpack.config.js or vue inspect --mode=production > webpack.config.json5 vue create 项目名称 创建项目 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-08 11:11:47 "},"webend/cdn.html":{"url":"webend/cdn.html","title":"cdn","keywords":"","body":"1>相关文章 BootCDN Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-10-28 13:53:48 "},"webend/chat_gpt.html":{"url":"webend/chat_gpt.html","title":"chat_gpt","keywords":"","body":"I>相关文章 II>插件&应用 chat-gpt官网 ChatGPT_JCM ChatGPT-Shortcut chatpdf 5个插件/工具 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-04-10 16:52:27 "},"webend/chrome_plugins.html":{"url":"webend/chrome_plugins.html","title":"chrome_plugins","keywords":"","body":"I>相关文章 chrome plugin 官网 chrome manifest 官网说明 chrome API 文档 PlasmoHQ/plasmo PlasmoHQ docs PlasmoHQ examples vite-chromeV3插件 vite+vue3+ts+chromeV3插件 封装的框架 chrome V3插件入门到放弃，Plasmo不完全使用指南 chrome扩展程序开发入门 V3 II> 核心介绍 1. manifest.json { // Required \"manifest_version\": 3, \"name\": \"My Extension\", \"version\": \"versionString\", // Recommended \"action\": {...}, \"default_locale\": \"en\", \"description\": \"A plain text description\", \"icons\": {...}, // Optional \"author\": ..., \"automation\": ..., \"background\": { // Required \"service_worker\": \"background.js\", // Optional \"type\": ... }, \"chrome_settings_overrides\": {...}, \"chrome_url_overrides\": {...}, \"commands\": {...}, \"content_capabilities\": ..., \"content_scripts\": [{...}], \"content_security_policy\": {...}, \"converted_from_user_script\": ..., \"cross_origin_embedder_policy\": {\"value\": \"require-corp\"}, \"cross_origin_opener_policy\": {\"value\": \"same-origin\"}, \"current_locale\": ..., \"declarative_net_request\": ..., \"devtools_page\": \"devtools.html\", \"differential_fingerprint\": ..., \"event_rules\": [{...}], \"externally_connectable\": { \"matches\": [\"*://*.example.com/*\"] }, \"file_browser_handlers\": [...], \"file_system_provider_capabilities\": { \"configurable\": true, \"multiple_mounts\": true, \"source\": \"network\" }, \"homepage_url\": \"https://path/to/homepage\", \"host_permissions\": [...], \"import\": [{\"id\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"}], \"incognito\": \"spanning, split, or not_allowed\", \"input_components\": ..., \"key\": \"publicKey\", \"minimum_chrome_version\": \"versionString\", \"nacl_modules\": [...], \"natively_connectable\": ..., \"oauth2\": ..., \"offline_enabled\": true, \"omnibox\": { \"keyword\": \"aString\" }, \"optional_host_permissions\": [\"...\"], \"optional_permissions\": [\"tabs\"], \"options_page\": \"options.html\", \"options_ui\": { \"page\": \"options.html\" }, \"permissions\": [\"tabs\"], \"platforms\": ..., \"replacement_web_app\": ..., \"requirements\": {...}, \"sandbox\": [...], \"short_name\": \"Short Name\", \"storage\": { \"managed_schema\": \"schema.json\" }, \"system_indicator\": ..., \"tts_engine\": {...}, \"update_url\": \"https://path/to/updateInfo.xml\", \"version_name\": \"aString\", \"web_accessible_resources\": [...] } 2. background.js // 『重点』下面将出现的background.js 配置service work \"background\": { // Required \"service_worker\": \"service-worker.js\", }, 不使用时终止，需要时重新启动（类似于事件页面）。 无权访问 DOM。（service worker独立于页面） 3. content_script // manifest.json { \"name\": \"My extension\", ... \"content_scripts\": [ { // 满足matches匹配的域名 \"matches\": [\"https://*.nytimes.com/*\"], // 注入css \"css\": [\"my-styles.css\"], // 注入js \"js\": [\"content-script.js\"], \"run_at\": \"document_idle\" | \"document_start\" | \"document_end\" } ], \"permissions\": [ \"activeTab\" ], } 读取或写入网页的扩展程序使用 content_script。内容脚本包含在已加载到浏览器的页面上下文中执行的 JavaScript。内容脚本读取和修改浏览器访问的网页的 DOM。 content_script可以通过使用storage/message API来与扩展其他部分进行通信。 4. popup // manifest.json 中引入popup.html \"action\": { \"default_title\": \"Click to view a popup\", \"default_popup\": \"popup.html\" } // popup.html 引入相关js css等 京东揽才 III> 相互间的通信方式 JS种类 可访问的API DOM访问情况 JS访问情况 直接跨域 injected script 和普通JS无任何差别，不能访问任何扩展API 可以访问 可以访问 不可以 content script 只能访问 extension、runtime等部分API 可以访问 不可以 不可以 popup js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 background js 可访问绝大部分API，除了devtools系列 不可直接访问 不可以 可以 devtools js 只能访问 devtools、extension、runtime等部分API 可以访问devtools 可以访问devtools 不可以 1. content script与background 使用 chrome.runtime.sendMessage 发送信息 使用 chrome.tabs.sendMessage接收监听信息 // content_script // 监听接收信息 chrome.runtime.onMessage.addListener((request, sender, sendResponse) => { // 可写成switch形式 监听所有 if (sender === \"\") { // do something } if (request.from === \"cc\") { // from 不是固定词，可使用其他自定义词汇 // do something } // 发送回传 sendResponse({number: request.number}); // 修改dom document.querySelector(\"#s-usersetting-top\").innerText = request.number; // 重发信息 chrome.runtime.sendMessage({number: request.number + 1}, (response) => { console.log( `content script -> background infos have been received. number: ${response.number}` ); }); }); // background // 监听消息接收 chrome.runtime.onMessage.addListener((request, sender, sendResponse)=> { chrome.tabs.query({active: true, currentWindow: true}, (tabs)=> { chrome.tabs.sendMessage(tabs[0].id,{number: request.number + 1},(response) => { console.log( `background -> content script infos have been received. number: ${response.number}` ); }); }); // 消息回传 sendResponse({number: request.number}); }); 2. popup与background // popup document.querySelector(\"#button\").addEventListener(\"click\", () => { const val1 = document.querySelector(\"#input1\").value || \"0\"; const val2 = document.querySelector(\"#input2\").value || \"0\"; chrome.runtime.sendMessage({val1, val2}, (response) => { document.querySelector(\"#ans\").innerHTML = response.res; }); });d // background const dealwithBigNumber = (val1, val2) => BigInt(val1) * BigInt(val2) + \"\"; chrome.runtime.onMessage.addListener((request, sender, sendResponse) => { const {val1, val2} = request; sendResponse({res: dealwithBigNumber(val1, val2)}); }); 3. popup与content // content_script // 接收popup数据并修改dom chrome.runtime.onMessage.addListener((request, sender, sendResponse) => { $(\"body\").css(\"background\", request.color); sendResponse({name: 1}); }); chrome.tabs.query( { active: true },(tabs)=>{ if (tabs.length > 0) { var current = tabs[0]; chrome.tabs.sendMessage(current.id, { action: \"getData\"}, function (response) { isCanrecruit = response?response.sourceCanrecruit:null; showContent() }) } }); Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-11-25 18:21:03 "},"webend/git.html":{"url":"webend/git.html","title":"git","keywords":"","body":"1>命令 1. 变量的配置 1.1 全局变量的配置 git config --global user.name 全局用户名，这个名字在ssh模式下可以随便设置 git config --global user.email 这个用户名和邮箱是可以随便配置的（不提倡），如果你配置的邮箱是github里真实存在的邮箱，则commits里显示的是这个邮箱对应的账号；如果配置的邮箱是一个在github里不存在的邮箱，则commits里显示的是你配置的用户名。 git config --global user.xxx “xxx” 用于配置全局用户名或者地址 1.2 局部变量的配置 在1基础上去掉–global参数，配置的即为局部用户名或者地址 局部变量多用于特定仓库中 使用变量的时候优先从局部变量中搜索 1.3 ssh公钥的配置 输入ssh-keygen（并不需要加参数，因为默认的生成的公钥已经足够）生成公钥私钥。在~/.ssh/目录下找id_rsa.pub，将内容复制添加到你的网页远端的ssh公钥处。这样在提交修改后代码的时候就不用再输入账号密码验证了。因为你机器上生成的公钥已经给了网页服务端，它可以通过这个验证。 远端网页服务器添加多个公钥，就表明这些公钥对应的私钥所在客户端和远端服务器通信的时候都不需要密码验证了。 2. 初始化仓库 2.1 拉取别人的仓库做开发建设的情况 在网页fork别人的仓库为自己的 在本地创建一个文件夹test,进去执行下面的操作 git init git config user.name “xxx”（这里是配置局部变量，如果你的全局变量配置对应着你的gitee，也可以不用设置局部变量的） git config user.name “xxx” 这一步添加你fork的仓库 git remote add 仓库别名 url 可以换成ssh的url，这样提交时就不用验证了。 git pull 拉取远端仓库内容以同步仓库状态，之后就可以修改 提交 git add . git commit -m “xxx” git push 仓库别名 master 2.2 拉取自己仓库情况 在2.1配置远端仓库的时候，将url设置为自己的远端仓库即可。 3. git版本控制 在本地仓库里，可使用此功能回退到相应版本的代码处，版本号可以从网页服务器端获取。 git reset --hard 版本号 此功能多用来找丢失文件或者回退到稳定版本 注意，找到文件后，应该让本地仓库回到最新版本状态。 4. git分支管理 master分支是默认分支，一般是软件正式发布的正确代码 在本地仓库可以创建新分支 本地仓库可以切换到新分支，在新分支中进行的修改，不会影响master分支 可以将新分支merge到master分支，实现分支合并 命令 git branch 查看分支 git branch 分支名 创建以此分支名为名字的分支 git checkout 分支名 转到此分支 git push 仓库别名 分支名:分支名 提交此分支的内容，冒号意思是，如果远端仓库没有此分支则创建一个此分支 git merge 分支名 将分支名所表示分支合并到当前分支。直接进入分支，不会让文件处于工作区或者暂存区。 5. 工作区，暂存区，仓库分支 工作区文件是红的 暂存区是绿的add可以提交到暂存区 git status可以查看当前分支工作区和暂存区状态 6. 快速开发 在配置好ssh情况下，直接在仓库文件夹下clone远程仓库，url选择ssh版本的，在此仓库中可以直接进行修改文件等一系列操作。前提是此仓库是你自己主页的，而不是从别人主页clone来的。如果想要别人的仓库，自己可以先fork一份。 7. http模式 push的时候需要输入仓库所在账号密码才能成功push成功 8. 初始管理远程所有分支 git clone url git clone -b 2.0.0 https://gitee.com/calcdev/RAD.git 默认只拉取HEAD指向的master分支，其他的分支没有拉取到本地 git -b（branch） 分支名 拉取指定分支到本地 git branch -a 查看所有分支，包括此仓库的所有远端分支名 git checkout -b 本地分支名 origin/远端分支名 创建本地分支a，转到本地分支a,并将远端分支关联到本地分支 git branch -d 分支名 删除本地分支 git push origin --delete BranchName 删除远端分支 9. 一般的git提交分支流程 1.拉取master 2.以master为基创建dev开发分支 3.开发…开发完成，有多个dev本地commit 4.将多个dev本地commit合并为一个 5.pull master获取master最新内容 6.将master rebase到 dev，在dev中解决冲突问题 7.将dev merge到master，让本地master处于在服务端的最新版本基础上又添加了自己的改动的最新状态 8.提交master到远程仓库 具体如下: 拉取远端master分支 建立master为基的分支dev 在master中使用git branch dev创建，就是以master为基创建dev分支 如果用git checkout -b dev则新创建的分支和master没有关系，也没有任何内容 在dev中进行修改工作，该提交本地仓库就提交 修改工作完成后，先回到master，pull最新master 此处是master有可能在远端被其他开发者更改了，所以需要先把master最新信息同步到本地master 回到dev git rebase -i HEAD~number 将dev分支中的number个提交化为一个提交 可以修改弹出来的内容为除了第一项之外前面都改成s,表示合并提交到一次中（本来一个commit就是一次提交） git rebase master 由于dev是基于master产生的，所以这一步的意思是将master内容合并到自己修改之处。此处合并若有冲突产生，则rebase过程会停止，在自己开发仓库中处理冲突。 git status 使用此命令查看冲突文件 使用vim打开冲突文件进行修改，删除git给你添加的冲突标志线和其他提示信息。然后保存退出编辑器。但是我们需要将rebase过程走完。 git rebase --continue 这一步是继续进行将master合并到自己的dev开发分支，也就是将rebase或称走完。合并完毕后，自己的dev开发分支就处于最新远端仓库的版本上又添加了自己内容的状态 回到master，将dev分支合并到master 因为我们dev分支中除了有当前master的内容，又加上了我们自己的内容。 git checkout master git merge dev 合并完毕之后提交 git push origin master 追加：回退历史版本 1、使用git log命令查看所有的历史版本，获取某个历史版本的id 比如：42294a2adc041c6b37d99fd776dac00a425e4b96 2.恢复到历史版本 git reset --hard 42294a2adc041c6b37d99fd776dac00a425e4b961 3、 把修改推到远程服务器( 注意：reset之后push到远程上会删除这个历史版本之后的所有版本 )。 git push -f -u origin master 备注：强制push到远程 master分支 备注：穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 其他命令 git config --global http.sslVerify \"false\" git config --globa http.postBuffer 524288000 git rm --cached package-lock.json //移除指定文件的版本管理 2>浅谈GIT中的Fork https://blog.csdn.net/qq_29947967/article/details/80519113 3>Windows下GitLab配置SSH 3-1> 确定自己的电脑用户路径下没有.ssh文件夹，如果有，则删除 3-2>设置本地git的账户邮箱和用户名 请先确认自己的电脑安装过git客户端 在电脑任意位置右击，选择Git Bash Here，此时会弹出git的命令窗口 然后在窗口中输入以下命令： git config --global user.name \"Git账号\"回车 git config --global user.email \"Git邮箱\"回车 在执行两条命令的过程中，如果没有任何异常提示，则说明执行成功了。当然，我们也可以用命令查看配置的git账户和邮箱是否成功了 git config user.name回车，查看用户名 git config user.email回车，查看用户邮箱 3-3>生成一个新的SSH密钥 在git命令窗口中执行以下命令 ssh-keygen -t rsa -C \"你的Git邮箱\" 然后连续敲三次回车，如果没问题你会看到如下界面 3-4>将SSH公钥添加到GitLab账户 在这个文件夹中有一对密钥文件 使用notepad++等工具打开id_rsa.pub，复制其中的内容，千万不要改变其中的内容 登陆你的gitlab账户，在gitlab的设置页面，找到设置SSH的地方 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-12-29 18:11:30 "},"webend/node&npm.html":{"url":"webend/node&npm.html","title":"node&npm","keywords":"","body":"1>相关文章 npm官网 nodejs官网 nvm介绍及使用 发布一个npm包，构建自己的第三方库 如何创建自己的npm包 npm包的介绍、前端实现自己的包并上传到npm仓库的方法 上传npm包 使用webpack构建属于你自己的npm包 记npm包开发全过程 创建自己的library类库包并使用webpack4.x打包发布到npm webpack4与babel配合使es6代码可运行于低版本浏览器 webpack发布npm-package npm 发布如何忽略指定的文件 element-ui组件库二次开发——打包、上传npm 前端多个vue项目公共组件的三种方法（推荐npm file引入） npm file方式引入公共包遇到的几个坑 2>常用命令 npm npm install webpack webpack-cli --global (全局安装插件) =>npm install webpack webpack-cli -g npm ls element-ui(查看某个包本地当前的版本) npm view element-ui versions(查看包所有版本) npm view element-ui version(查看包的最新版本) npm info element-ui(查看包的更多版本信息) npm install calc-common (在dependencies, devDependencies安装) npm install --save calc-common (在dependencies, devDependencies安装) npm install --save-dev calc-common (只在devDependencies安装) =>npm install -D npm i --save-dev mini-css-extract-plugin@1.0.0(安装指定版本的包) npm i xxx@latest --save-dev(安装指定的包最新的版本) npm uninstall calc-common(卸载包) npm uninstall jquery bootstrap babel (卸载多个包) npm update xxx -D(升级指定包) npm view autoprefixer versions(查看指定包可用的版本) 删除 node_modules 依赖 `npm install rimraf -g rimraf node_modules` npm init (初始化自定义包的环境) npm config get registry (查看镜像地址) npm config set registry URL (设置镜像地址) npm config set registry https://registry.npm.taobao.org (设置淘宝镜像源) npm config set registry https://registry.npmjs.org (设置npm官方像源) npm login(登录npm账号) npm adduser(创建npm账号) npm publish (上传发布) npm version patch (更新版本) npm unpublish 包名@版本号 (删除指定的版本) npm unpublish 包名 --force (删除整个包, 会有警告提示, 删除后该包名24小时之内不可再用) npm audit --json (查看需要手动更新的漏洞) npm prune(清理不必要的软件包) npm config set proxy null (取消代理) npm config set https-proxy null (取消https代理) npm install -g cnpm (全局安装cnpm) npm cache clear --force (强制刷新npm缓存) npm cache dir (查看npm缓存的位置) nvm nvm list available：列出所有可以安装的node版本号 nvm ls：列出所有已经安装的node版本 nvm install v10.4.0：安装指定版本号的node nvm uninstall v10.4.0：删除指定版本号的node nvm current：当前node版本 nvm use v10.3.0：切换node的版本，这个是全局的 nrm npm i -g nrm open@8.4.2 全局安装npm的镜像源管理工具, open包必须制定8.4.2, 不然nrm使用会报错 nrm ls 查看所有可用的镜像 nrm use 镜像名称 nrm current 查看当前所用镜像 nrm add taobao2 https://registry.npm.taobao.org 添加镜像地址 3>其他知识点 *dependencies(生产依赖): 如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到 dependencies 节点中。 *devDependencies(开发依赖): 如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies 节点中。 *如何仅仅安装生产依赖? 默认npm install 会安装所有依赖（开发和生产依赖都安装） 通过–production 选项可以仅仅安装生产依赖 npm install --production *自定义.env, 及.env文件讲解 若需要自定义.env文件, 文件名称必须是.env.自定义名称, 如.env.report, 文件内容如下 另, 根目录下可以创建.env文件, 该文件内的配置优先级低于指定环境的配置文件 # NODE_ENV 将决定您的应用运行的模式，是开发，生产还是测试，因此也决定了创建哪种 webpack 配置，如果文件内部不包含 NODE_ENV 变量，它的值将取决于模式，例如，在 production 模式下被设置为 \"production\"，在 test 模式下被设置为 \"test\"，默认是 \"development\"。 NODE_ENV = production BABEL_ENV = production # 环境变量必须是 VUE_APP_ 开头 VUE_APP_ENV = 'report' #项目中读取方式 process.env.VUE_APP_ENV *dial tcp 104.20.22.46:443 timeout nvm node_mirror https://npm.taobao.org/mirrors/node/ Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-27 14:11:43 "},"webend/note_奇技淫巧.html":{"url":"webend/note_奇技淫巧.html","title":"note_奇技淫巧","keywords":"","body":"Windows下GitLab配置SSH 官方Web API 接口参考 【SVN】SVN创建分支 SVN创建分支/合并分支/切换分支 SVN的使用、分支合并及解决冲突详解 SVN创建分支与合并分支 SVN分支/合并操作小记 vue项目eslint格式化最全注释 git修改当前项目仓库地址的三种方法 SVN分支/合并操作小记 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-04 21:45:54 "},"webend/note_布局和样式.html":{"url":"webend/note_布局和样式.html","title":"note_布局和样式","keywords":"","body":"Class^=,Class*= ,Class$=含义 CSS3四个自适应关键字——fill-available、max-content、min-content、fit-content css3自适应法宝fill-available、fit-content、max-content、min-content [class^=\"icon-\"]、[class$=\"icon-\"]、[class*=\"icon-\"] position:absolute水平居中 CSS--box-shadow 利用伪元素和css3实现鼠标移入下划线向两边展开效果 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-04 21:45:44 "},"webend/note_打包.html":{"url":"webend/note_打包.html","title":"note_打包","keywords":"","body":"require.context()的使用 配置顶级的await vue/cli 配置顶级的await 配置顶级await的替代方案 Uncaught Syntax Error: Cannot use import statement outside a module的解决方法 WARNING in asset size limit: The following asset(s) exceed the recommended size limit vue快速删除node_modules文件夹 fatal: unable to access 'https://github.com/nhn/raphael.git/' How to import package.json in TypeScript git pull fatal: unable to access OpenSSL SSL_read: Connection was reset, errno 10054 ValidationError: Progress Plugin Invalid Options (PS:项目中遇到的情况是, 使用@vue/cli 5.x版本创建vue2模板的项目, 将旧项目copy进来后, run dev报9>的错误, 因为@vue/cli 5.x用的是webpack 5.X的版本, 然后旧项目的devDependencies - webpack用的是4.x版本, 需要使用将其升级到最新版本即可) 前端模块化——彻底搞懂AMD、CMD、UMD、ESM和CommonJS 『Webpack系列』—— externals用法详解 详解.env文件配置---全局环境变量 .env 文件详解 webpack中BundleAnalyzerPlugin插件基本配置项 vue-cli打包之性能优化 vue打包优化 不使用 babel-plugin-component 实现按需引用element-ui element-ui按需引入, 报错 If you are using bothon-demand and importing all, make sure to invoke the importing all first. 在线图片压缩 如何为项目开启gzip压缩及实现原理 Webpack5学习笔记（高级篇） 详细讲解vue中祖孙组件间的通信之使用$attrs和$listeners的方式 require和import静态和动态导入 *webpack项目中, 可以使用require动态/静态引入es6的export模块, 以及json, json5文件, 以及module.exports = {}的模块 *js中, import的几种用法 import \"nprogress/nprogress.css\"; // 引入样式 import \"@/locale\"; // 引入locale文件夹内的index.js脚本, 并执行 import { i18n } from \"@/locale\"; // 引入locale文件夹内的index.js脚本, 引入i18n vue打包之compression-webpack-plugin实现gzip压缩 chainWebpack之optimization.splitChunks的cacheGroups缓存组代码分块实践案 前端性能之压缩, 配合Nginx, 实现优先找服务器的gzip文件, 若没有, 才使用服务器压缩 lodash按需引入 SplitChunksPlugin拆分规则 vue2 项目升级到vue3之后npm run build执行两遍打包 Vue Cli 项目打包体积过大，优化vue项目体积 element-ui iconfont乱码问题处理 使用Element-UI 之乱码问题 将 SCSS 变量分享给 JS Cannot read properties of null (reading ‘pickAlgorithm‘)解决方法 vue项目引入自定义js报错,使用了可选链和双问号 用sass替代node-sass nexus设置npm下载管理 上传npm包到私有nexus仓库中《解决服务端安装npm依赖失败的问题》 通过npm 和 yarn 缓存策略 解决前端打包慢的问题 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-04 21:45:54 "},"webend/note_逻辑.html":{"url":"webend/note_逻辑.html","title":"note_逻辑","keywords":"","body":"input的file类型的accept属性的值 js实现文件下载有很多种方式，本文主要介绍7种 js常用下载的几种方式 vue 中优雅的使用 web worker JavaScript Array 对象 原生 JS DOM 常用操作大全 原生JS DOM操作方法 ES6 Class类 addEventListener, removeEventListener 关于addEventListener立即触发的问题 事件句柄 Event Handlers vue + element 树形表 懒加载 增加和删除时 刷新节点 preload错误 Vue - 生命周期函数(activated) 标签http-equiv属性中pragma cache-control expires三者的关系。 Vue自定义指令监听el-table的滚动事件 详解 input accept属性 h5中performance.timing轻松获取网页各个数据 如dom加载时间 渲染时长 加载完触发时间 获取页面dom渲染时间，内存占用，响应耗时，TCP连接耗时 js统计页面加载完成需要的时间 TortoiseGit clone项目时报错：No supported authentication methods available (server sent: publickey) js中鼠标事件 element-ui中的el-popover结合vue中的v-for的使用方法 js实现textarea回车换行 jQuery属性操作prop()、attr()和data() jQuery获取父节点、子节点、兄弟节点 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-04 21:45:54 "},"webend/package.json.html":{"url":"webend/package.json.html","title":"package.json","keywords":"","body":"1>相关文章 package.json scripts 脚本使用指南 package.json 中的版本号，符号~ 与 ^的区别解析 package.json版本号符号^和~前缀的区别 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-03 22:10:09 "},"webend/react.html":{"url":"webend/react.html","title":"react","keywords":"","body":"I>相关文章 中文官网 英文官网 II>create-react-app 全局安装 create-react-app npm i -g create-react-app 创建一个项目 create-react-app app名称 非全局安装 npx i create-react-app app名称 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-03 22:10:25 "},"webend/third_party_plugins.html":{"url":"webend/third_party_plugins.html","title":"third_party_plugins","keywords":"","body":"1. Splitpanes 介绍: 界面容器分割器, 空间自动以伸缩。没有对splitpanes和pane的pros进行介绍, 需查看源码, 用法简单. 2. echarts 介绍: 腾讯强大的chart插件, 参数繁多, 功能复杂, 拓展性好. 3. vue-i18n 介绍: 国际化 4. xlsx 介绍: 前端操作excel的插件 相关文章: Vue3-前端json数据导入/导出Excel表格 JSON与excel之间的相互转化(Vue) Vue+File saver+xlsx使用json_to_sheet导出数据为excel vue 前端导出excel xlsx插件 修改表格行高列宽度 vue导出含有多个表的excel，并设置边框、背景色、字体、宽度等 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-01-04 19:31:59 "},"webend/typescript.html":{"url":"webend/typescript.html","title":"typescript","keywords":"","body":"I>相关文章 TS官网 tsconfig.json详细配置 Typescript最强入门 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-02-10 14:01:07 "},"webend/uni_app.html":{"url":"webend/uni_app.html","title":"uni_app","keywords":"","body":"I>相关文章 uniapp-微信小程序关于禁止ios自带的下拉上拉（橡皮筋回弹） HbuilderX使用教程 HbuilderX插件市场 uni-app教程 uni-app UI框架 - uView uni-app 国际化 shopro商城使用vue-i18n国际化 uni-app 国际化开发 h5+ API 5+ App开发Native.js入门指南 苹果开发者网站 创建苹果P12证书和描述文件 真机运行常见问题 使用Apple证书签名iOS标准基座 uni-app导航栏开发指南 导航栏示例应用 uni-app subNVue 原生子窗体开发指南 uni-app 怎么实现路由拦截 拦截器应用示例 — 图片选择 App权限判断和提示 系统剪贴板 II>uni-app教程 1. uni-app工程目录 ┌─uniCloud 云空间目录，阿里云为uniCloud-aliyun,腾讯云为uniCloud-tcb（详见uniCloud） │─components 符合vue组件规范的uni-app组件目录 │ └─comp-a.vue 可复用的a组件 ├─utssdk 存放uts文件 ├─pages 业务页面文件存放的目录 │ ├─index │ │ └─index.vue index页面 │ └─list │ └─list.vue list页面 ├─static 存放应用引用的本地静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此 ├─uni_modules 存放uni_module。 ├─platforms 存放各平台专用页面的目录，详见 ├─nativeplugins App原生语言插件 详见 ├─nativeResources App端原生资源目录 │ └─android Android原生资源目录 详见 ├─hybrid App端存放本地html文件的目录，详见 ├─wxcomponents 存放小程序组件的目录，详见 ├─unpackage 非工程代码，一般存放运行或发行的编译结果 ├─AndroidManifest.xml Android原生应用清单文件 详见 ├─main.js Vue初始化入口文件 ├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期 ├─manifest.json 配置应用名称、appid、logo、版本等打包信息，详见 ├─pages.json 配置页面路由、导航条、选项卡等页面类信息，详见 └─uni.scss 这里是uni-app内置的常用样式变量 static目录 使用注意 编译到任意平台时，static 目录下除不满足条件编译的文件，会直接复制到最终的打包目录，不会打包编译。非 static 目录下的文件（vue、js、css 等）只有被引用时，才会被打包编译。 css、less/scss 等资源不要放在 static 目录下，建议这些公用的资源放在自建的 common 目录下。 2. 页面 2.1 Note 指符合Vue SFC规范的.vue文件或.nvue文件。 .vue页面和.nvue页面，均全平台支持，差异在于当uni-app发行到App平台时，.vue文件会使用webview进行渲染，.nvue会使用原生进行渲染。 在工程根目录下的pages目录下。 每次新建页面，均需在pages.json中配置pages列表；未在pages.json -> pages 中配置的页面，uni-app会在编译阶段进行忽略。 删除页面时，需做两件工作：1. 删除.vue文件或.nvue文件; 2. 删除pages.json -> pages列表项中的配置。 pages.json -> pages配置项中的第一个页面，作为当前工程的首页（启动页）。 页面生命周期 支持 Vue 组件生命周期 onInit: 监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad => 百度小程序 仅百度小程序基础库 3.260 以上支持 onInit 生命周期 其他版本或平台可以同时使用 onLoad 生命周期进行兼容，注意避免重复执行相同逻辑 不依赖页面传参的逻辑可以直接使用 created 生命周期替代 onLoad: 监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考示例 onShow: 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 onReady: 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 onHide: 监听页面隐藏 onUnload: 监听页面卸载 onResize: 监听窗口尺寸变化 => App、微信小程序、快手小程序 onPullDownRefresh: 监听用户下拉动作，一般用于下拉刷新，参考示例 onReachBottom: 页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项 使用注意 可在pages.json里定义具体页面底部的触发距离onReachBottomDistance，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。如使用scroll-view导致页面没有滚动，则触底事件不会被触发。 onTabItemTap: 点击 tab 时触发，参数为Object，具体见下方注意事项 => 微信小程序、QQ小程序、支付宝小程序、百度小程序、H5、App、快手小程序、京东小程序 onTabItemTap常用于点击当前tabitem，滚动或刷新当前页面。如果是点击不同的tabitem，一定会触发页面切换。 如果想在App端实现点击某个tabitem不跳转页面，不能使用onTabItemTap，可以使用plus.nativeObj.view放一个区块盖住原先的tabitem，并拦截点击事件。 支付宝小程序平台onTabItemTap表现为点击非当前tabitem后触发，因此不能用于实现点击返回顶部这种操作 onTabItemTap : function(e) { console.log(e); // e的返回格式为json对象： {\"index\":0,\"text\":\"首页\",\"pagePath\":\"pages/index/index\"} }, onShareAppMessage: 用户点击右上角分享 => 微信小程序、QQ小程序、支付宝小程序、字节小程序、飞书小程序、快手小程序、京东小程序 onPageScroll: 监听页面滚动，参数为Object => nvue暂不支持 如果想实现滚动时标题栏透明渐变，在App和H5下，可在pages.json中配置titleNView下的type为transparent，参考。 在App、微信小程序、H5中，也可以使用wxs监听滚动，参考；在app-nvue中，可以使用bindingx监听滚动，参考。 onPageScroll : function(e) { //nvue暂不支持滚动监听，可用bindingx代替 console.log(\"滚动距离为：\" + e.scrollTop); }, onNavigationBarButtonTap: 监听原生标题栏按钮点击事件，参数为Object => App、H5 onNavigationBarButtonTap : function (e) { console.log(e); // e的返回格式为json对象：{\"text\":\"测试\",\"index\":0} } onBackPress: 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：onBackPress 详解。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。 => app、H5、支付宝小程序 from: 触发返回行为的来源：'backbutton'——左上角导航栏按钮及安卓返回键；'navigateBack'——uni.navigateBack() 方法。支付宝小程序端不支持返回此字段 export default { data() { return {}; }, onBackPress(options) { console.log('from:' + options.from) } } onNavigationBarSearchInputChanged: 监听原生标题栏搜索输入框输入内容变化事件 => App、H5 onNavigationBarSearchInputConfirmed: 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 => App、H5 onNavigationBarSearchInputClicked: 监听原生标题栏搜索输入框点击事件（pages.json 中的 searchInput 配置 disabled 为 true 时才会触发） => App、H5 onShareTimeline: 监听用户点击右上角转发到朋友圈 => 微信小程序 onAddToFavorites: 监听用户点击右上角收藏 => 微信小程序、QQ小程序 2.2 (自定义)组件声明周期 组件支持的生命周期，与vue标准组件的生命周期相同。 beforeCreate: 在实例初始化之前被调用。 created: 在实例创建完成后被立即调用。 beforeMount: 在挂载开始之前被调用。 mounted: 挂载到实例上去之后调用。详见 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档 beforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前。 updated: 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。详见 beforeDestroy: 实例销毁之前调用。在这一步，实例仍然完全可用。详见 destroyed: Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。详见 2.3 相关页面接口 getApp() 函数用于获取当前应用实例，一般用于获取globalData 。 const app = getApp() console.log(app.globalData) 不要在定义于 App() 内的函数中，或调用 App 前调用 getApp() ，可以通过 this.$scope 获取对应的app实例 当在首页nvue中使用getApp()不一定可以获取真正的App对象。对此提供了const app = getApp({allowDefault: true})用来获取原始的App对象，可以用来在首页对globalData等初始化 getCurrentPages()用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。 页面实例的方法属性列表 方法 描述 平台说明 page.$getAppWebview() 获取当前页面的webview对象实例 App page.route 获取当前页面的路由 navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 不能在 App.vue 里面进行页面跳转。 $getAppWebview()可以得到当前webview的对象实例，从而实现对 webview 更强大的控制。 获取当前页面 webview 的对象实例 export default { data() { return { title: 'Hello' } }, onLoad() { // #ifdef APP-PLUS const currentWebview = this.$scope.$getAppWebview(); //此对象相当于html5plus里的plus.webview.currentWebview()。在uni-app里vue页面直接使用plus.webview.currentWebview()无效 currentWebview.setBounce({position:{top:'100px'},changeoffset:{top:'0px'}}); //动态重设bounce效果 // #endif } } 获取指定页面 webview 的对象实例 var pages = getCurrentPages(); var page = pages[pages.length - 1]; // #ifdef APP-PLUS var currentWebview = page.$getAppWebview(); console.log(currentWebview.id);//获得当前webview的id console.log(currentWebview.isVisible());//查询当前webview是否可见 ); // #endif nvue 开发与 vue 开发的常见区别 3. 互相引用 3.1 引用组件 传统vue项目开发，引用组件需要导入 - 注册 - 使用三个步骤 // 1. 导入组件 import uniRate from '@/components/uni-rate/uni-rate.vue'; export default { components: { uniRate } // 2. 注册组件 } Vue 3.x增加了script setup特性，将三步优化为两步，无需注册步骤 // 1. 导入组件 import uniRate from '@/components/uni-rate/uni-rate.vue'; uni-app的easycom机制，将组件引用进一步优化，开发者只管使用，无需考虑导入和注册 3.2 引用js js文件或script标签内（包括 renderjs 等）引入js文件时，可以使用相对路径和绝对路径 // 绝对路径，@指向项目根目录，在cli项目中@指向src目录 import add from '@/common/add.js'; // 相对路径 import add from '../../common/add.js'; js 文件不支持使用/开头的方式引入 3.3 引用css 使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。 @import \"../../common/uni.css\"; .uni-card { box-shadow: none; } 3.4 引用静态资源 templat引入静态资源 template内引入静态资源，如image、video等标签的src属性时，可以使用相对路径或者绝对路径 @开头的绝对路径以及相对路径会经过 base64 转换规则校验 引入的静态资源在非 h5 平台，均不转为 base64。 H5 平台，小于 4kb 的资源会被转换成 base64，其余不转。 自HBuilderX 2.6.6起template内支持@开头路径引入静态资源，旧版本不支持此方式 App 平台自HBuilderX 2.6.9起template节点中引用静态资源文件时（如：图片），调整查找策略为【基于当前文件的路径搜索】，与其他平台保持一致 支付宝小程序组件内 image 标签不可使用相对路径 css 引入静态资源 css文件或style标签内引入css文件时（scss、less 文件同理），可以使用相对路径或绝对路径（HBuilderX 2.6.6） /* 绝对路径 */ @import url('/common/uni.css'); @import url('@/common/uni.css'); /* 相对路径 */ @import url('../../common/uni.css'); css文件或style标签内引用的图片路径可以使用相对路径也可以使用绝对路径，需要注意的是，有些小程序端 css 文件不允许引用本地文件（请看注意事项）。 引入字体图标请参考，字体图标 @开头的绝对路径以及相对路径会经过 base64 转换规则校验 不支持本地图片的平台，小于 40kb，一定会转 base64。（共四个平台 mp-weixin, mp-qq, mp-toutiao, app v2） h5 平台，小于 4kb 会转 base64，超出 4kb 时不转。 其余平台不会转 base64 /* 绝对路径 */ background-image: url(/static/logo.png); background-image: url(@/static/logo.png); /* 相对路径 */ background-image: url(../../static/logo.png); 3.5 引用原生插件 4. js语法 4.1 ES6 支持 uni-app 在支持绝大部分 ES6 API 的同时，也支持了 ES7 的 await/async。各操作系统平台版本的支持情况，请见 5. CSS语法 5.1 尺寸单位 支持的通用 css 单位包括 px、rpx vue 页面支持下面这些普通 H5 单位，但在 nvue 里不支持： rem 根字体大小可以通过 page-meta 配置 vh viewpoint height，视窗高度，1vh 等于视窗高度的 1% vw viewpoint width，视窗宽度，1vw 等于视窗宽度的 1% rpx详细说明: 设计师在提供设计图时，一般只提供一个分辨率的图。严格按设计图标注的 px 做开发，在不同宽度的手机上界面很容易变形。而且主要是宽度变形。高度一般因为有滚动条，不容易出问题。由此，引发了较强的动态宽度单位需求。 微信小程序设计了 rpx 解决这个问题。uni-app 在 App 端、H5 端都支持了 rpx，并且可以配置不同屏幕宽度的计算方式，具体参考：rpx 计算配置。rpx 是相对于基准宽度的单位，可以根据屏幕宽度进行自适应。uni-app 规定屏幕基准宽度 750rpx。 开发者可以通过设计稿基准宽度计算页面元素 rpx 值，设计稿 1px 与框架样式 1rpx 转换公式如下： 设计稿 1px / 设计稿基准宽度 = 框架样式 1rpx / 750rpx 换言之，页面元素宽度在 uni-app 中的宽度计算公式： 750 * 元素在设计稿中的宽度 / 设计稿基准宽度 若设计稿宽度为 750px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 750，结果为：100rpx。 若设计稿宽度为 640px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 640，结果为：117rpx。 若设计稿宽度为 375px，元素 B 在设计稿上的宽度为 200px，那么元素 B 在 uni-app 里面的宽度应该设为：750 * 200 / 375，结果为：400rpx。 注意 rpx 是和宽度相关的单位，屏幕越宽，该值实际像素越大。如不想根据屏幕宽度缩放，则应该使用 px 单位。 如果开发者在字体或高度中也使用了 rpx ，那么需注意这样的写法意味着随着屏幕变宽，字体会变大、高度会变大。如果你需要固定高度，则应该使用 px 。 rpx 不支持动态横竖屏切换计算，使用 rpx 建议锁定屏幕方向 早期 uni-app 提供了 upx ，目前已经推荐统一改为 rpx 了，详见 5.2 内联样式 请尽量避免将静态的样式写进 style 中，以免影响渲染速度。 5.3 选择器 在 uni-app 中不能使用 * 选择器。 微信小程序自定义组件中仅支持 class 选择器 page 相当于 body 节点 page { background-color: #ccc; } 5.4 全局样式与局部样式 定义在 App.vue 中的样式为全局样式，作用于每一个页面。在 pages 目录下 的 vue 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 App.vue 中相同的选择器。 5.5 CSS变量 当设置 \"navigationStyle\":\"custom\" 取消原生导航栏后，由于窗体为沉浸式，占据了状态栏位置。此时可以使用一个高度为 var(--status-bar-height) 的 view 放在页面顶部，避免页面内容出现在状态栏。 由于在 H5 端，不存在原生导航栏和 tabbar，也是前端 div 模拟。如果设置了一个固定位置的居底 view，在小程序和 App 端是在 tabbar 上方，但在 H5 端会与 tabbar 重叠。此时可使用--window-bottom，不管在哪个端，都是固定在 tabbar 上方。 目前 nvue 在 App 端，还不支持 --status-bar-height变量，替代方案是在页面 onLoad 时通过 uni.getSystemInfoSync().statusBarHeight 获取状态栏高度，然后通过 style 绑定方式给占位 view 设定高度。下方提供了示例代码 CSS 变量 描述 App 小程序 H5 --status-bar-height 系统状态栏高度 系统状态栏高度、nvue 注意见下 25px 0 --window-top 内容区域距离顶部的距离 0 0 NavigationBar 的高度 --window-bottom 内容区域距离底部的距离 0 0 TabBar 的高度 普通页面使用 css 变量 状态栏下的文字 .status_bar { height: var(--status-bar-height); width: 100%; } nvue 页面获取状态栏高度 export default { data() { return { iStatusBarHeight: 0, }; }, onLoad() { this.iStatusBarHeight = uni.getSystemInfoSync().statusBarHeight; }, }; 5.5 uni-app 固定值组件 组件 描述 App H5 NavigationBar 导航栏 44px 44px TabBar 底部选项卡 HBuilderX 2.3.4 之前为 56px，2.3.4 起和 H5 调为一致，统一为 50px。（但可以自主更改高度） 50px 5.6 建议使用Flex布局 阮一峰的 flex 教程 5.7 背景图片 支持 base64 格式图片。 支持网络路径图片。 小程序不支持在 css 中使用本地文件，包括本地的背景图和字体文件。需以 base64 方式方可使用。 使用本地路径背景图片需注意： 为方便开发者，在背景图片小于 40kb 时，uni-app 编译到不支持本地背景图的平台时，会自动将其转化为 base64 格式； 图片大于等于 40kb，会有性能问题，不建议使用太大的背景图，如开发者必须使用，则需自己将其转换为 base64 格式使用，或将其挪到服务器上，从网络地址引用。 本地背景图片的引用路径推荐使用以 ~@ 开头的绝对路径。 .test2 { background-image: url('~@/static/logo.png'); } 5.8 字体图标 引用方式 @font-face { font-family: test1-icon; src: url('~@/static/iconfont.ttf'); } nvue中不可直接使用 css 的方式引入字体文件，需要使用以下方式在 js 内引入。 &#xe600; &#xe687; &#xe60b; @font-face { font-family: 'iconfont'; src: url('https://at.alicdn.com/t/font_865816_17gjspmmrkti.ttf') format('truetype'); } .test { font-family: iconfont; margin-left: 20rpx; } 6. VUE(2) 语法 6.1 基础 事件映射表 // 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件 { click: 'tap', touchstart: 'touchstart', touchmove: 'touchmove', touchcancel: 'touchcancel', touchend: 'touchend', tap: 'tap', longtap: 'longtap', //推荐使用longpress代替 input: 'input', change: 'change', submit: 'submit', blur: 'blur', focus: 'focus', reset: 'reset', confirm: 'confirm', columnchange: 'columnchange', linechange: 'linechange', error: 'error', scrolltoupper: 'scrolltoupper', scrolltolower: 'scrolltolower', scroll: 'scroll' } 6.2 组件 跟VUE基本一致 6.3 API 全局配置 Vue 全局配置 描述 H5 App端 小程序 说明 Vue.config.silent 取消 Vue 所有的日志与警告 详情 √ √ √ Vue.config.optionMergeStrategies 自定义合并策略的选项 详情 √ √ √ Vue.config.devtools 配置是否允许 vue-devtools 检查代码 详情 √ x x 只在Web环境下支持 Vue.config.errorHandler 指定组件的渲染和观察期间未捕获错误的处理函数 详情 √ √ √ Vue.config.warnHandler 为 Vue 的运行时警告赋予一个自定义处理函数 详情 √ √ √ Vue.config.ignoredElements 须使 Vue 忽略在 Vue 之外的自定义元素 详情 √ √ √ 强烈不推荐，会覆盖uni-app框架配置的内置组件 Vue.config.keyCodes 给 v-on 自定义键位别名 详情 √ x x Vue.config.performance 设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪 详情 √ x x 只在Web环境下支持 Vue.config.productionTip 设置为 false 以阻止 vue 在启动时生成生产提示 详情 √ √ √ - 全局API Vue 全局 API 描述 H5 App端 小程序 说明 Vue.extend 使用基础 Vue 构造器，创建一个“子类” 详情 √ √ x 不可作为组件使用 Vue.nextTick 在下次 DOM 更新循环结束之后执行延迟回调 详情 √ x x Vue.set 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新 详情 √ √ √ Vue.delete 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图 详情 √ √ √ Vue.directive 注册或获取全局指令 详情 √ √ x Vue.filter 注册或获取全局过滤器 详情 √ √ x Vue.component 注册或获取全局组件。注册还会自动使用给定的 id 设置组件的名称 详情 √ √ √ Vue.use 安装 Vue.js 插件 详情 √ √ √ Vue.mixin 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例 详情 √ √ √ Vue.version 提供字符串形式的 Vue 安装版本号 详情 √ √ √ Vue.compile 将一个模板字符串编译成 render 函数。只在完整版时可用。详情 √ x x uni-app使用的vue是只包含运行时的版本 选项 Vue 选项 描述 H5 App端 小程序 说明 data Vue 实例的数据对象 详情 √ √ √ props props 可以是数组或对象，用于接收来自父组件的数据 详情 √ √ √ propsData 创建实例时传递 props。主要作用是方便测试 详情 √ √ √ computed 计算属性将被混入到 Vue 实例中 详情 √ √ √ methods methods 将被混入到 Vue 实例中 详情 √ √ √ watch 一个对象，键是需要观察的表达式，值是对应回调函数 详情 √ √ √ el 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标 详情 √ x x template 一个字符串模板作为 Vue 实例的标识使用 详情 √ x x uni-app使用的vue是只包含运行时的版本 render 字符串模板的代替方案，该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。详情 √ x x renderError 当 render 函数遭遇错误时，提供另外一种渲染输出，只在开发者环境下工作 详情 √ x x directives 包含 Vue 实例可用指令的哈希表 详情 √ √ x filters 包含 Vue 实例可用过滤器的哈希表 详情 √ √ √ components 包含 Vue 实例可用组件的哈希表 详情 √ √ √ parent 指定已创建的实例之父实例，在两者之间建立父子关系 详情 √ √ √ 不推荐 mixins 选项接收一个混入对象的数组 详情 √ √ √ extends 允许声明扩展另一个组件 详情 √ √ √ provide/inject 允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效 详情 √ √ √ name 允许组件模板递归地调用自身 详情 √ √ √ delimiters 改变纯文本插入分隔符 详情 √ x x functional 使组件无状态 (没有 data) 和无实例 (没有 this 上下文) 详情 √ x x model 允许一个自定义组件在使用 v-model 时定制 prop 和 event 详情 √ √ x inheritAttrs inheritAttrs属性默认值为true，表示允许组件的根节点继承$attrs包含的属性 详情 √ √ x comments 当设为 true 时，将会保留且渲染模板中的 HTML 注释 详情 √ x x - 实例属性 Vue 实例属性 描述 H5 App端 小程序 说明 vm.$data Vue 实例观察的数据对象 详情 √ √ √ vm.$props 当前组件接收到的 props 对象 详情 √ √ √ vm.$el Vue 实例使用的根 DOM 元素 详情 √ x x vm.$options 用于当前 Vue 实例的初始化选项 详情 √ √ √ vm.$parent 父实例，如果当前实例有的话 详情 √ √ √ H5端 view、text 等内置标签是以 Vue 组件方式实现，$parent 会获取这些到内置组件，导致的问题是 this.$parent 与其他平台不一致，解决方式是使用 this.$parent.$parent 获取或自定义组件根节点由 view 改为 div vm.$root 当前组件树的根 Vue 实例 详情 √ √ √ vm.$children 当前实例的直接子组件 详情 √ √ √ H5端 view、text 等内置标签是以 Vue 组件方式实现，$children 会获取到这些内置组件，导致的问题是 this.$children 与其他平台不一致，解决方式是使用 this.$children.$children 获取或自定义组件根节点由 view 改为 div vm.$slots 用来访问被插槽分发的内容 详情 √ x √ vm.$scopedSlots 用来访问作用域插槽 详情 √ √ √ vm.$refs 一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例详情 √ √ √ 非H5端只能用于获取自定义组件，不能用于获取内置组件实例（如：view、text） vm.$isServer 当前 Vue 实例是否运行于服务器 详情 √ √ x App端总是返回false vm.$attrs 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 详情 √ √ x vm.$listeners 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器 详情 √ √ x - 实例方法 实例方法 描述 H5 App端 小程序 说明 vm.$watch() 观察 Vue 实例上的一个表达式或者一个函数计算结果的变化 详情 √ √ √ vm.$set() 这是全局 Vue.set 的别名 详情 √ √ √ vm.$delete() 这是全局 Vue.delete 的别名 详情 √ √ √ vm.$on() 监听当前实例上的自定义事件 详情 √ √ √ vm.$once() 监听一个自定义事件，但是只触发一次 详情 √ √ √ vm.$off() 移除自定义事件监听器 详情 √ √ √ vm.$emit() 触发当前实例上的事件 详情 √ √ √ vm.$mount() 手动地挂载一个未挂载的实例 详情 √ x x vm.$forceUpdate() 迫使 Vue 实例重新渲染 详情 √ √ √ vm.$nextTick() 将回调延迟到下次 DOM 更新循环之后执行 详情 √ √ √ vm.$destroy() 完全销毁一个实例 详情 √ √ √ - 模板指令 Vue 指令 描述 H5 App端 小程序 说明 v-text 更新元素的 textContent 详情 √ √ √ v-html 更新元素的 innerHTML 详情 √ √ x 微信小程序会被转成 rich-text v-show 根据表达式之真假值，切换元素的 display CSS属性 详情 √ √ √ v-if 根据表达式的值的 truthiness 来有条件地渲染元素 详情 √ √ √ v-else 为 v-if 或者 v-else-if 添加“else 块” 详情 √ √ √ v-else-if 表示 v-if 的“else if 块”。可以链式调用 详情 √ √ √ v-for 基于源数据多次渲染元素或模板块 详情 √ √ √ v-on 绑定事件监听器 详情 √ √ √ v-bind 动态地绑定一个或多个 attribute，或一个组件 prop 到表达式 详情 √ √ √ v-model 在表单控件或者组件上创建双向绑定 详情 √ √ √ v-pre 跳过这个元素和它的子元素的编译过程 详情 √ √ x v-cloak 这个指令保持在元素上直到关联实例结束编译 详情 √ x x v-once 只渲染元素和组件一次 详情 √ √ x - 特殊属性 特殊属性 描述 H5 App端 小程序 说明 key 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes 详情 √ √ √ ref ref 被用来给元素或子组件注册引用信息 详情 √ √ √ 非 H5 平台只能获取 vue 组件实例不能获取到内置组件实例 is 用于动态组件且基于 DOM 内模板的限制来工作 详情 √ √ (需传入 String 类型) x - 内置组件 内置组件 描述 H5 App端 小程序 说明 component 渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染 详情 √ √ x transition 作为单个元素/组件的过渡效果 详情 √ x x transition-group 作为多个元素/组件的过渡效果 详情 √ x x keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们 详情 √ x x slot 作为组件模板之中的内容分发插槽 详情 √ √ √ - template 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性 详情 √ √ √ - 7. VUEX 用法基本与H5一致, 可见 8. 组合式 API 暂时不用, 可见 9. TypeScript专题 暂时不用, 可见 10. 条件编译 10.1 以 #ifdef 或 #ifndef 加 **%PLATFORM%** 开头，以 #endif 结尾 #ifdef：if defined 仅在某平台存在 #ifndef：if not defined 除了某平台均存在 %PLATFORM% 可取值 值 生效条件 VUE3 HBuilderX 3.2.0+ 详情 APP-PLUS App APP-PLUS-NVUE或APP-NVUE App nvue 页面 APP-ANDROID App Android 平台 仅限 uts文件 APP-IOS App iOS 平台 仅限 uts文件 H5 H5 MP-WEIXIN 微信小程序 MP-ALIPAY 支付宝小程序 MP-BAIDU 百度小程序 MP-TOUTIAO 字节跳动小程序 MP-LARK 飞书小程序 MP-QQ QQ小程序 MP-KUAISHOU 快手小程序 MP-JD 京东小程序 MP-360 360小程序 MP 微信小程序/支付宝小程序/百度小程序/字节跳动小程序/飞书小程序/QQ小程序/360小程序 QUICKAPP-WEBVIEW 快应用通用(包含联盟、华为) QUICKAPP-WEBVIEW-UNION 快应用联盟 QUICKAPP-WEBVIEW-HUAWEI 快应用华为 10.2 API的条件编译 // #ifdef %PLATFORM% 平台特有的API实现 // #endif 10.3 组件的条件编译 平台特有的组件 微信公众号关注组件 10.4 样式的条件编译 /* #ifdef %PLATFORM% */ 平台特有样式 /* #endif */ 10.5 pages.json的条件编译 10.6 static目录的条件编译 在不同平台，引用的静态资源可能也存在差异，通过 static 的条件编译可以解决此问题，static 目录下新建不同平台的专有目录，专有目录下的静态资源只有在特定平台才会编译进去。 目录名称 说明 app-plus App h5 H5 mp-weixin 微信小程序 mp-alipay 支付宝小程序 mp-baidu 百度小程序 mp-qq QQ小程序 mp-toutiao 字节小程序 mp-lark 飞书小程序 mp-kuaishou 快手小程序 mp-jd 京东小程序 11. APP专题 11.1 NVUE 适用场景: 需要高性能的区域长列表或瀑布流滚动。webview 的页面级长列表滚动是没有性能问题的（就是滚动条覆盖 webview 整体高度），但页面中某个区域做长列表滚动，则需要使用 nvue 的list、recycle-list、waterfall等组件(详见)。这些组件的性能要高于 vue 页面里的区域滚动组件scroll-view。 复杂高性能的自定义下拉刷新。uni-app 的 pages.json 里可以配置原生下拉刷新，但引擎内置的下拉刷新样式只有雪花和 circle 圈 2 种样式。如果你需要自己做复杂的下拉刷新，推荐使用 nvue 的 refresh 组件。当然插件市场里也有很多 vue 下的自定义下拉刷新插件，只要是基于 renderjs 或 wxs 的，性能也可以商用，只是没有 nvue 的refresh组件更极致。 左右拖动的长列表。在 webview 里，通过swiper+scroll-view实现左右拖动的长列表，前端模拟下拉刷新，这套方案的性能不好。此时推荐使用 nvue，比如新建 uni-app 项目时的新闻示例模板，就采用了 nvue，切换很流畅。 实现区域滚动长列表+左右拖动列表+吸顶的复杂排版效果，效果可参考 hello uni-app 模板里的swiper-list。详见 如需要将软键盘右下角按钮文字改为“发送”，则需要使用 nvue。比如聊天场景，除了软键盘右下角的按钮文字处理外，还涉及聊天记录区域长列表滚动，适合 nvue 来做。 解决前端控件无法覆盖原生控件的层级问题。当你使用map、video、live-pusher等原生组件时，会发现前端写的view等组件无法覆盖原生组件，层级问题处理比较麻烦，此时使用 nvue 更好。或者在 vue 页面上也可以覆盖一个 subnvue（一种非全屏的 nvue 页面覆盖在 webview 上），以解决 App 上的原生控件层级问题。详见 如深度使用map组件，建议使用 nvue。除了层级问题，App 端 nvue 文件的 map 功能更完善，和小程序拉齐度更高，多端一致性更好。 如深度使用video，建议使用 nvue。比如如下 2 个场景：video 内嵌到 swiper 中，以实现抖音式视频滑动切换，例子见插件市场；nvue 的视频全屏后，通过cover-view实现内容覆盖，比如增加文字标题、分享按钮。 直播推流：nvue 下有live-pusher组件，和小程序对齐，功能更完善，也没有层级问题。 对 App 启动速度要求极致化。App 端如果首页使用 nvue 且在 manifest 里配置 fast 模式，那么 App 的启动速度可以控制在 1 秒左右。而使用 vue 页面的话，App 的启动速度一般是 3 秒起，取决于你的代码性能和体积。 但注意，在某些场景下，nvue 不如 vue 页面，如下： canvas。nvue 的 canvas 性能不高，尤其是 Android App 平台，所以这个组件干脆没有内置，而是需要单独引入。操作 canvas 动画，最高性能的方式是使用 vue 页面的 renderjs 技术，在 hello uni-app 里的 canvas 示例就是如此。 动态横竖屏。nvue 页面的 css 不支持媒体查询，所以横竖屏动态切换、动态适配屏幕是很困难的。 nvue开发与vue开发的常见区别 nvue 页面控制显隐只可以使用v-if不可以使用v-show nvue 页面只能使用flex布局，不支持其他布局方式。页面开发前，首先想清楚这个页面的纵向内容有什么，哪些是要滚动的，然后每个纵向内容的横轴排布有什么，按 flex 布局设计好界面。 nvue 页面的布局排列方向默认为竖排（column），如需改变布局方向，可以在 manifest.json -> app-plus -> nvue -> flex-direction 节点下修改，仅在 uni-app 模式下生效。详情。 nvue页面编译为H5、小程序时，会做一件css默认值对齐的工作。因为weex渲染引擎只支持flex，并且默认flex方向是垂直。而H5和小程序端，使用web渲染，默认不是flex，并且设置display:flex后，它的flex方向默认是水平而不是垂直的。所以nvue编译为H5、小程序时，会自动把页面默认布局设为flex、方向为垂直。当然开发者手动设置后会覆盖默认设置。 文字内容，必须、只能在组件下。不能在、的text区域里直接写文字。否则即使渲染了，也无法绑定js里的变量。 只有text标签可以设置字体大小，字体颜色。 布局不能使用百分比、没有媒体查询。 nvue 切换横竖屏时可能导致样式出现问题，建议有 nvue 的页面锁定手机方向。 支持的css有限，不过并不影响布局出你需要的界面，flex还是非常强大的。详见 不支持背景图。但可以使用image组件和层级来实现类似web中的背景效果。因为原生开发本身也没有web这种背景图概念 css选择器支持的比较少，只能使用 class 选择器。详见 nvue 的各组件在安卓端默认是透明的，如果不设置background-color，可能会导致出现重影的问题。 class 进行绑定时只支持数组语法。 Android端在一个页面内使用大量圆角边框会造成性能问题，尤其是多个角的样式还不一样的话更耗费性能。应避免这类使用。 nvue页面没有bounce回弹效果，只有几个列表组件有bounce效果，包括 list、recycle-list、waterfall。 原生开发没有页面滚动的概念，页面内容高过屏幕高度并不会自动滚动，只有部分组件可滚动（list、waterfall、scroll-view/scroller），要滚的内容需要套在可滚动组件下。这不符合前端开发的习惯，所以在 nvue 编译为 uni-app模式时，给页面外层自动套了一个 scroller，页面内容过高会自动滚动。（组件不会套，页面有recycle-list时也不会套）。后续会提供配置，可以设置不自动套。 在 App.vue 中定义的全局js变量不会在 nvue 页面生效。globalData和vuex是生效的。 App.vue 中定义的全局css，对nvue和vue页面同时生效。如果全局css中有些css在nvue下不支持，编译时控制台会报警，建议把这些不支持的css包裹在条件编译里，APP-PLUS-NVUE 不能在 style 中引入字体文件，nvue 中字体图标的使用参考：加载自定义字体。如果是本地字体，可以用plus.io的API转换路径。 目前不支持在 nvue 页面使用 typescript/ts。 nvue 页面关闭原生导航栏时，想要模拟状态栏，可以参考文章。但是，仍然强烈建议在nvue页面使用原生导航栏。nvue的渲染速度再快，也没有原生导航栏快。原生排版引擎解析json绘制原生导航栏耗时很少，而解析nvue的js绘制整个页面的耗时要大的多，尤其在新页面进入动画期间，对于复杂页面，没有原生导航栏会在动画期间产生整个屏幕的白屏或闪屏。 样式 nvue的css仅支持flex布局，是webview的css语法的子集。这是因为操作系统原生排版不支持非flex之外的web布局。当然flex足以排布出各种页面，只是写法需要适应。 class 进行绑定时只支持数组语法。 不支持媒体查询 不能在 style 中引入字体文件 不能使用百分比布局，如width：100% 不支持在css里写背景图background-image，但可以使用image组件和层级来实现类似web中的背景效果。因为原生开发本身也没有web这种背景图概念 使用image标签，支持使用base64，不支持svg格式图片 nvue 的各组件在安卓端默认是透明的，如果不设置background-color，可能会导致出现重影的问题 文字内容，必须只能在text组件下，text组件不能换行写内容，否则会出现无法去除的周边空白 只有text标签可以设置字体大小，字体颜色 不支持 /deep/ NVUE支持的样式 width, height, padding, border, margin, flex, position, transition, transform, 伪类(active, focus, disabled, enabled), 渐变(linear-gradient), box-shadow, color, font-size, font-style, font-weight, text-decoration, text-align, font-family, text-overflow, lines, line-height, word-wrap API uni.requireNativePlugin 引入 App 原生插件 //使用方式 const PluginName = uni.requireNativePlugin(PluginName); // PluginName 为原生插件名称 DOM.addRule(type, contentObject) Weex 提供 DOM.addRule 以加载自定义字体。开发者可以通过指定 font-family加载 iconfont 和 custom font。 &#xe85c; export default{ beforeCreate() { const domModule = uni.requireNativePlugin('dom') domModule.addRule('fontFace', { 'fontFamily': \"myIconfont\", 'src': \"url('http://at.alicdn.com/t/font_2234252_v3hj1klw6k9.ttf')\" }); } } .my-iconfont { font-family:myIconfont; font-size:60rpx; color: #00AAFF; } scrollToElement(ref, options) @ref，要滚动到的那个节点。 @options offset，一个到其可见位置的偏移距离，默认是 0。 animated，是否需要附带滚动动画，默认是 true。 Go to 10 Go to 20 const dom = uni.requireNativePlugin('dom') export default { data() { return { rows: [] } }, created() { for (let i = 0; i getComponentRect(ref, callback) @ref，要获取外框的那个节点。 @callback，异步方法，通过回调返回信息。 回调方法中的数据样例 { result: true, size: { bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 } } animation const animation = uni.requireNativePlugin('animation') export default { methods: { move() { var testEl = this.$refs.test; animation.transition(testEl, { styles: { backgroundColor: '#007AFF', transform: 'translate(100px, 80px)', transformOrigin: 'center center' }, duration: 800, //ms timingFunction: 'ease', delay: 0 //ms },()=>{ uni.showToast({ title: 'finished', icon:'none' }); }) } } } .box{ width:750rpx; height:750rpx; } .box-item{ width: 250rpx; height: 250rpx; background-color: #00aaff; } transition BindingX nvue 和 vue 相互通讯 使用 uni.$on , uni.$emit 的方式进行页面通讯 // 接收信息的页面 // $on(eventName, callback) uni.$on('page-popup', (data) => { console.log('标题：' + data.title) console.log('内容：' + data.content) }) // 发送信息的页面 // $emit(eventName, data) uni.$emit('page-popup', { title: '我是title', content: '我是content' }); vue 和 nvue 共享的变量和数据 vuex uni.storage globalData 使用 HTML5Plus API nvue页面可直接使用plus的API，并且不需要等待plus ready。 nvue 里不支持的 uni-app API 不支持的 API | API | 说明 | 解决方案 | | --------------------- | ---------------- | ------------------------------------------------------------ | | uni.createAnimation() | 创建一个动画实例 | animation | | API | 说明 | 解决方案 | | ------------------ | -------------------- | ------------------------------------------------------------ | | uni.pageScrollTo() | 将页面滚动到目标位置 | scrollToElement | | API | 说明 | | -------------------------------- | -------------------------------------------- | | uni.createIntersectionObserver() | 创建并返回一个 IntersectionObserver 对象实例 | 事件 用到再看。 11.2 html5plus h5+ API 在html中使用plus的api，需要等待plus ready。 而uni-app不需要等，可以直接使用。而且如果你调用plus ready，反而不会触发。 在普通的 H5+ 项目中，需要使用 document.addEventListener 监听原生扩展的事件。uni-app 中，没有 document。可以使用 plus.globalEvent.addEventListener 来实现。 // #ifdef APP-PLUS // 监听新意图事件 plus.globalEvent.addEventListener('newintent', function(){}); // #endif 11.3 native-js 用到再看。 11.4 renderjs 用到再看。 11.5 原生插件开发 用到再看。 11.6 User Agent 默认情况使用系统Webview的User Agent，并添加Html5Plus/1.0、uni-app两字段 11.7 使用高斯模糊 用到再看。 11.8 APP打包配置 用到再看。 11.9 uni-app 全局变量的几种实现方式 公用模块 (不推荐) 这种方式只支持多个vue页面或多个nvue页面之间公用，vue和nvue之间不公用。 挂载 Vue.prototype (不推荐) 将一些使用频率较高的常量或者方法，直接扩展到 Vue.prototype 上，每个 Vue 对象都会“继承”下来。这种方式只支持vue页面。 globalData (推荐, 可是变量不是响应式) 在 App.vue 可以定义 globalData ，也可以使用 API 读写这个值。支持vue和nvue共享数据。 ```js App.vue export default { globalData: { text: 'text' }, onLaunch: function() { console.log('App Launch') }, onShow: function() { console.log('App Show') }, onHide: function() { console.log('App Hide') } } /*每个页面公共css */ //js中操作globalData的方式如下: //赋值 getApp().globalData.text = 'test' //取值 console.log(getApp().globalData.text) // 'test' * `VUEX (最推荐, 变量是响应式)` ### `12. 性能优化` #### `12.1 避免使用大图` #### `12.2 优化数据更新` * 在 `uni-app` 中，定义在 data 里面的数据每次变化时都会通知视图层重新渲染页面。所以如果不是视图所需要的变量，可以不定义在 data 中，可在外部定义变量或直接挂载在vue实例上，以避免造成资源浪费。 #### `12.3 减少一次性渲染的节点数量` * 页面初始化时，逻辑层如果一次性向视图层传递很大的数据，使视图层一次性渲染大量节点，可能造成通讯变慢、页面切换卡顿，所以建议以局部更新页面的方式渲染页面。如：服务端返回100条数据，可进行分批加载，一次加载50条，500ms 后进行下一次加载。 #### `12.4 减少组件数量、减少节点嵌套层级` * 深层嵌套的节点在页面初始化构建时往往需要更多的内存占用，并且在遍历节点时也会更慢些，所以建议减少深层的节点嵌套。 #### `12.5 避免视图层和逻辑层频繁进行通讯` - 减少 scroll-view 组件的 scroll 事件监听，当监听 scroll-view 的滚动事件时，视图层会频繁的向逻辑层发送数据； - 监听 scroll-view 组件的滚动事件时，不要实时的改变 scroll-top/scroll-left 属性，因为监听滚动时，视图层向逻辑层通讯，改变 scroll-top/scroll-left 时，逻辑层又向视图层通讯，这样就可能造成通讯卡顿。 - 注意 onPageScroll 的使用，onPageScroll 进行监听时，视图层会频繁的向逻辑层发送数据； - 多使用css动画，而不是通过js的定时器操作界面做动画 - 如需在canvas里做跟手操作，app端建议使用renderjs，小程序端建议使用web-view组件。web-view里的页面没有逻辑层和视图层分离的概念，自然也不会有通信折损。 #### `12.6 优化页面切换动画` - 页面初始化时若存在大量图片或原生组件渲染和大量数据通讯，会发生新页面渲染和窗体进入动画抢资源，造成页面切换卡顿、掉帧。建议延时100ms~300ms渲染图片或复杂原生组件，分批进行数据通讯，以减少一次性渲染的节点数量。 - App端动画效果可以自定义。popin/popout的双窗体联动挤压动画效果对资源的消耗更大，如果动画期间页面里在执行耗时的js，可能会造成动画掉帧。此时可以使用消耗资源更小的动画效果，比如slide-in-right/slide-out-right。 - App-nvue和H5，还支持页面预载，[uni.preloadPage](https://uniapp.dcloud.io/api/preload-page)，可以提供更好的使用体验 #### `12.7 优化背景色闪白` - 如果页面背景是深色，在vue页面中可能会发生新窗体刚开始动画时是灰白色背景，动画结束时才变为深色背景，造成闪屏。这是因为webview的背景生效太慢的问题。此时需将样式写在 `App.vue` 里，可以加速页面样式渲染速度。`App.vue` 里面的样式是全局样式，每次新开页面会优先加载 `App.vue` 里面的样式，然后加载普通 vue 页面的样式。 - app端还可以在pages.json的页面的style里单独配置页面原生背景色，比如在globalStyle->style->app-plus->background下配置全局背景色 - 另外nvue页面不存在此问题，也可以更改为nvue页面。 #### `12.8 使用nvue代替vue` * 在 App 端 `uni-app` 的 nvue 页面可是基于weex升级改造的原生渲染引擎，实现了页面原生渲染能力、提高了页面流畅性。若对页面性能要求较高可以使用此方式开发，详见：[nvue](https://uniapp.dcloud.net.cn/tutorial/nvue-outline)。 #### `12.9 优化启动速度` * 工程代码越多，包括背景图和本地字体文件越大，对小程序启动速度有影响，应注意控制体积。组件引用的前景图不影响性能。 * App端的 splash 关闭有白屏检测机制，如果首页一直白屏或首页本身就是一个空的中转页面，可能会造成 splash 10秒才关闭，可参考此文解决https://ask.dcloud.net.cn/article/35565 * App端，首页为nvue页面时，并设置为[fast启动模式](https://ask.dcloud.net.cn/article/36749)，此时App启动速度最快。 * App设置为纯nvue项目（manifest里设置app-plus下的renderer:\"native\"），这种项目的启动速度更快，2秒即可完成启动。因为它整个应用都使用原生渲染，不加载基于webview的那套框架。 #### `12.10 优化包体积` - uni-app发行到小程序时，自带引擎只有几十K，主要是一个定制过的vue.js核心库。如果使用了es6转es5、css对齐的功能，可能会增大代码体积，可以配置这些编译功能是否开启。 - uni-app的H5端，自带了vue.js、vue-router及部分es6 polyfill库，这部分的体积gzip后只有92k，和web开发使用vue基本一致。而内置组件ui库（如picker、switch等）、小程序的对齐js api等，相当于一个完善的大型ui库。但大多数应用不会用到所有内置组件和API。由此uni-app提供了摇树优化机制，未摇树优化前的uni-app整体包体积约500k，服务器部署gzip后162k。开启摇树优化需在manifest配置，[详情](https://uniapp.dcloud.io/collocation/manifest?id=optimization)。 - uni-app的App端，因为自带了一个独立v8引擎和小程序框架，所以比HTML5Plus或mui等普通hybrid的App引擎体积要大。Android基础引擎约9M。App还提供了扩展模块，比如地图、蓝牙等，打包时如不需要这些模块，可以裁剪掉，以缩小发行包体积。在 manifest.json-App模块权限 里可以选择。 - App端支持如果选择纯nvue项目（manifest里设置app-plus下的renderer:\"native\"），包体积可以进一步减少2M左右。 - uni-app的App-Android端有so库的概念，支持不同的cpu类型的so库越多，包越大。在HBuilderX 2.7以前，Android app默认包含arm32和x86两个cpu的支持so库。包体积比较大。如果你在意体积控制，可以在manifest里去掉x86 cpu的支持（manifest可视化界面-App其他设置里选择cpu），这可以减少包体积到9M。从HBuilderX 2.7起，默认不再包含x86，如有需求请自行在manifest里勾选后打包。一般手机都是arm的，涉及x86 cpu场景很少，包括：个别少见的Android pad、as的模拟器里选择x86类型。 ### `13. 国际化专题` uni-app的国际化, 分为应用部分和框架部分。 可以在HBuilderX新建项目里选择`Hello i18n`示例或者插件市场[查看](https://ext.dcloud.net.cn/plugin?id=6462)。 #### `13.1 vue界面和js内容的国际化` * main.js 引入并初始化 VueI18n ```javascript // 国际化 json 文件，文件内容详见下面的示例 import en from './en.json' import zhHans from './zh-Hans.json' import zhHant from './zh-Hant.json' const messages = { en, 'zh-Hans': zhHans, 'zh-Hant': zhHant } let i18nConfig = { locale: uni.getLocale(),// 获取已设置的语言 messages } // VUE2 // #ifndef VUE3 import Vue from 'vue' import VueI18n from 'vue-i18n'// v8.x Vue.use(VueI18n) const i18n = new VueI18n(i18nConfig) Vue.config.productionTip = false App.mpType = 'app' const app = new Vue({ i18n, ...App }) app.$mount() // #endif // VUE3 // #ifdef VUE3 import { createSSRApp } from 'vue' import { createI18n } from 'vue-i18n'// v9.x const i18n = createI18n(i18nConfig) export function createApp() { const app = createSSRApp(App) app.use(i18n) return { app } } // #endif 国际化json文件内容 { \"index.title\": \"Hello i18n\" } 页面模板中使用 $t() 获取，并传递国际化json文件中定义的key，js中使用 this.$t('') $t('index.title') export default { data() { return { } } } 页面中设置语言后需要调用 this.$i18n.locale = 'zh-Hans' 后生效 13.2 nvue页面国际化 nvue 目前的国际化方案需要在每个页面单独引入uni-i18n，后续框架会抹平差异，抹平差异后和 vue 页面一样只需要在 main.js 中引入 import { initVueI18n } from '@dcloudio/uni-i18n' // const messages = {} 此处内容省略，和 vue 全局引入的写法一致 const { t } = initVueI18n(messages) export default { data() { return { } } } 13.3 pages.json 国际化 pages.json不属于vue页面，其中的原生tabbar和原生导航栏里也有文字内容。 项目根目录的locale目录下配置语言json文件，locale/语言地区代码.json，如：en.json，zh-Hans.json，zh-Hant.json ├── locale │ ├── en.json │ ├── zh-Hans.json │ └── zh-Hant.json pages.json 示例 pages.json 支持以下属性配置国际化信息 navigationBarTitleText titleNView->titleText titleNView->searchInput->placeholder tabBar->list->text { \"pages\": [ { \"path\": \"pages/index/index\", \"style\": { \"navigationBarTitleText\": \"%index.title%\" // locale目录下 语言地区代码.json 文件中定义的 key，使用 %% 占位 } } ], \"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"%index.home%\" } ] } } 13.4 框架内置组件和API国际化 这部分国际化，提供了2种策略，有自动策略，也有自定义方案。 13.4.1 自动适配手机或浏览器语言 内置组件和接口显示会根据系统语言环境自动切换，未支持的系统语言环境会显示为英文。 13.4.2 自定义国际化内容 项目根目录支持 locale 目录，locale/uni-app.语言地区代码.json，如：uni-app.en.json，uni-app.zh-Hans.json，uni-app.zh-Hant.json ├── locale │ ├── uni-app.en.json │ ├── uni-app.zh-Hans.json │ └── uni-app.zh-Hant.json uni-app.zh-Hans.json 文件 { \"common\": { \"uni.app.quit\": \"再按一次退出应用\", \"uni.async.error\": \"连接服务器超时，点击屏幕重试\", \"uni.showActionSheet.cancel\": \"取消\", \"uni.showToast.unpaired\": \"请注意 showToast 与 hideToast 必须配对使用\", \"uni.showLoading.unpaired\": \"请注意 showLoading 与 hideLoading 必须配对使用\", \"uni.showModal.cancel\": \"取消\", \"uni.showModal.confirm\": \"确定\", \"uni.chooseImage.cancel\": \"取消\", \"uni.chooseImage.sourceType.album\": \"从相册选择\", \"uni.chooseImage.sourceType.camera\": \"拍摄\", \"uni.chooseVideo.cancel\": \"取消\", \"uni.chooseVideo.sourceType.album\": \"从相册选择\", \"uni.chooseVideo.sourceType.camera\": \"拍摄\", \"uni.previewImage.cancel\": \"取消\", \"uni.previewImage.button.save\": \"保存图像\", \"uni.previewImage.save.success\": \"保存图像到相册成功\", \"uni.previewImage.save.fail\": \"保存图像到相册失败\", \"uni.setClipboardData.success\": \"内容已复制\", \"uni.scanCode.title\": \"扫码\", \"uni.scanCode.album\": \"相册\", \"uni.scanCode.fail\": \"识别失败\", \"uni.scanCode.flash.on\": \"轻触照亮\", \"uni.scanCode.flash.off\": \"轻触关闭\", \"uni.startSoterAuthentication.authContent\": \"指纹识别中...\", \"uni.picker.done\": \"完成\", \"uni.picker.cancel\": \"取消\", \"uni.video.danmu\": \"弹幕\", \"uni.video.volume\": \"音量\", \"uni.button.feedback.title\": \"问题反馈\", \"uni.button.feedback.send\": \"发送\" }, \"ios\": {}, \"android\": {} } 13.5 manifest.json 国际化 和 pages.json 一致，在项目根目录增加 locale/uni-app.语言地区代码.json 文件，然后在 manifest.json 中使用 %% 占位 { \"name\" : \"%app.name%\", \"appid\" : \"\", \"description\" : \"\", \"versionName\" : \"1.0.0\", \"versionCode\" : \"100\", \"locale\": \"zh-Hans\" // 设置默认语言， } 13.5 语言API uni.getSystemInfo 可以得到设备OS的语言、运行宿主host的语言以及应用自身的语言。 uni.getLocale 获取应用当前使用的语言 uni.setLocale 设置应用语言 uni.onLocaleChange 当前应用语言发生变化时，触发回调。也就是uni.setLocale执行时。 13.6 语言代码 语言代码通常为两个或三个字母，参考ISO 639规范 语言代码-地区代码，地区代码为两个字母，参考ISO 3166-2规范 14. easycom组件规范 传统vue组件，需要安装、引用、注册，三个步骤后才能使用组件。easycom将其精简为一步。 只要组件安装在项目的components目录下或uni_modules目录下，并符合components/组件名称/组件名称.vue目录结构。就可以不用引用、注册，直接在页面中使用。 比如前述举例的uni-rate组件，它导入到uni-app项目后，存放在了目录/components/uni-rate/uni-rate.vue 同时它的组件名称也叫uni-rate，所以这样的组件，不用在script里注册和引用。 如下： // 这里不用import引入，也不需要在components内注册uni-list组件。template里就可以直接用 export default { data() { return { } } } 不管components目录下安装了多少组件，easycom打包后会自动剔除没有使用的组件，对组件库的使用尤为友好。组件库批量安装，随意使用，自动按需打包。 easycom是自动开启的，不需要手动开启。 如果你的组件名称或路径不符合easycom的默认规范，可以在pages.json的easycom节点进行个性化设置，自定义匹配组件的策略。另见 15. uni_module规范 uni_module其实不止服务于组件，它可以服务于组件、js库、页面、项目等所有DCloud插件市场所支持的种类。 符合uni_module规范的组件都在项目的uni_modules目录下，以插件id为目录存放。（项目模板不放在uni_modules目录下） 在HBuilderX中点右键可方便的更新插件，插件作者也可以方便的上传插件。 uni_module还支持云端一体的插件。 uni_module有详细的专项文档，请另行查阅uni_module规范。 III>uni-app 全局配置文件 1. pages.json 页面路由 配置项列表 属性 类型 必填 描述 平台兼容 globalStyle Object 否 设置默认页面的窗口表现 pages Object Array 是 设置页面路径及窗口表现 easycom Object 否 组件自动引入规则 2.5.5+ tabBar Object 否 设置底部 tab 的表现 condition Object 否 启动模式配置 subPackages Object Array 否 分包加载配置 preloadRule Object 否 分包预下载规则 微信小程序 workers String 否 Worker 代码放置的目录 微信小程序 leftWindow Object 否 大屏左侧窗口 H5 topWindow Object 否 大屏顶部窗口 H5 rightWindow Object 否 大屏右侧窗口 H5 uniIdRouter Object 否 自动跳转相关配置，新增于HBuilderX 3.5.0 entryPagePath String 否 默认启动首页，新增于HBuilderX 3.7.0 { \"pages\": [{ \"path\": \"pages/component/index\", \"style\": { \"navigationBarTitleText\": \"组件\" } }, { \"path\": \"pages/API/index\", \"style\": { \"navigationBarTitleText\": \"接口\" } }, { \"path\": \"pages/component/view/index\", \"style\": { \"navigationBarTitleText\": \"view\" } }], \"condition\": { //模式配置，仅开发期间生效 \"current\": 0, //当前激活的模式（list 的索引项） \"list\": [{ \"name\": \"test\", //模式名称 \"path\": \"pages/component/view/index\" //启动页面，必选 }] }, \"globalStyle\": { \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"演示\", \"navigationBarBackgroundColor\": \"#F8F8F8\", \"backgroundColor\": \"#F8F8F8\", \"usingComponents\":{ \"collapse-tree-item\":\"/components/collapse-tree-item\" }, \"renderingMode\": \"seperated\", // 仅微信小程序，webrtc 无法正常时尝试强制关闭同层渲染 \"pageOrientation\": \"portrait\", //横屏配置，全局屏幕旋转设置(仅 APP/微信/QQ小程序)，支持 auto / portrait / landscape \"rpxCalcMaxDeviceWidth\": 960, \"rpxCalcBaseDeviceWidth\": 375, \"rpxCalcIncludeWidth\": 750 }, \"tabBar\": { \"color\": \"#7A7E83\", \"selectedColor\": \"#3cc51f\", \"borderStyle\": \"black\", \"backgroundColor\": \"#ffffff\", \"height\": \"50px\", \"fontSize\": \"10px\", \"iconWidth\": \"24px\", \"spacing\": \"3px\", \"iconfontSrc\":\"static/iconfont.ttf\", // app tabbar 字体.ttf文件路径 app 3.4.4+ \"list\": [{ \"pagePath\": \"pages/component/index\", \"iconPath\": \"static/image/icon_component.png\", \"selectedIconPath\": \"static/image/icon_component_HL.png\", \"text\": \"组件\", \"iconfont\": { // 优先级高于 iconPath，该属性依赖 tabbar 根节点的 iconfontSrc \"text\": \"\\ue102\", \"selectedText\": \"\\ue103\", \"fontSize\": \"17px\", \"color\": \"#000000\", \"selectedColor\": \"#0000ff\" } }, { \"pagePath\": \"pages/API/index\", \"iconPath\": \"static/image/icon_API.png\", \"selectedIconPath\": \"static/image/icon_API_HL.png\", \"text\": \"接口\" }], \"midButton\": { \"width\": \"80px\", \"height\": \"50px\", \"text\": \"文字\", \"iconPath\": \"static/image/midButton_iconPath.png\", \"iconWidth\": \"24px\", \"backgroundImage\": \"static/image/midButton_backgroundImage.png\" } }, \"easycom\": { \"autoscan\": true, //是否自动扫描组件 \"custom\": {//自定义扫描规则 \"^uni-(.*)\": \"@/components/uni-$1.vue\" } }, \"topWindow\": { \"path\": \"responsive/top-window.vue\", \"style\": { \"height\": \"44px\" } }, \"leftWindow\": { \"path\": \"responsive/left-window.vue\", \"style\": { \"width\": \"300px\" } }, \"rightWindow\": { \"path\": \"responsive/right-window.vue\", \"style\": { \"width\": \"300px\" }, \"matchMedia\": { \"minWidth\": 768 } } } 1.1 globalStyle 属性 类型 默认值 描述 平台差异说明 navigationBarBackgroundColor HexColor #F7F7F7 导航栏背景颜色（同状态栏背景色） APP与H5为#F7F7F7，小程序平台请参考相应小程序文档 navigationBarTextStyle String white 导航栏标题颜色及状态栏前景颜色，仅支持 black/white 支付宝小程序不支持，请使用 my.setNavigationBar navigationBarTitleText String 导航栏标题文字内容 navigationStyle String default 导航栏样式，仅支持 default/custom。custom即取消默认的原生导航栏，需看使用注意 微信小程序 7.0+、百度小程序、H5、App（2.0.3+） backgroundColor HexColor #ffffff 下拉显示出来的窗口的背景色 微信小程序 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light 微信小程序 enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面生命周期。 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见页面生命周期 backgroundColorTop HexColor #ffffff 顶部窗口的背景色（bounce回弹区域） 仅 iOS 平台 backgroundColorBottom HexColor #ffffff 底部窗口的背景色（bounce回弹区域） 仅 iOS 平台 titleImage String 导航栏图片地址（替换当前文字标题），支付宝小程序内必须使用https的图片链接地址 支付宝小程序、H5、APP transparentTitle String none 导航栏整体（前景、背景）透明设置。支持 always 一直透明 / auto 滑动自适应 / none 不透明 支付宝小程序、H5、APP titlePenetrate String NO 导航栏点击穿透 支付宝小程序、H5 pageOrientation String portrait 横屏配置，屏幕旋转设置，仅支持 auto / portrait / landscape 详见 响应显示区域变化 App 2.4.7+、微信小程序、QQ小程序 animationType String pop-in 窗口显示的动画效果，详见：窗口动画 App animationDuration Number 300 窗口显示动画的持续时间，单位为 ms App app-plus Object 设置编译到 App 平台的特定样式，配置项参考下方 app-plus App h5 Object 设置编译到 H5 平台的特定样式，配置项参考下方 H5 H5 mp-alipay Object 设置编译到 mp-alipay 平台的特定样式，配置项参考下方 MP-ALIPAY 支付宝小程序 mp-weixin Object 设置编译到 mp-weixin 平台的特定样式 微信小程序 mp-baidu Object 设置编译到 mp-baidu 平台的特定样式 百度小程序 mp-toutiao Object 设置编译到 mp-toutiao 平台的特定样式 字节跳动小程序 mp-lark Object 设置编译到 mp-lark 平台的特定样式 飞书小程序 mp-qq Object 设置编译到 mp-qq 平台的特定样式 QQ小程序 mp-kuaishou Object 设置编译到 mp-kuaishou 平台的特定样式 快手小程序 mp-jd Object 设置编译到 mp-jd 平台的特定样式 京东小程序 usingComponents Object 引用小程序组件，参考 小程序组件 renderingMode String 同层渲染，webrtc(实时音视频) 无法正常时尝试配置 seperated 强制关掉同层 微信小程序 leftWindow Boolean true 当存在 leftWindow 时，默认是否显示 leftWindow H5 topWindow Boolean true 当存在 topWindow 时，默认是否显示 topWindow H5 rightWindow Boolean true 当存在 rightWindow 时，默认是否显示 rightWindow H5 rpxCalcMaxDeviceWidth Number 960 rpx 计算所支持的最大设备宽度，单位 px App（vue2 且不含 nvue）、H5（2.8.12+） rpxCalcBaseDeviceWidth Number 375 rpx 计算使用的基准设备宽度，设备实际宽度超出 rpx 计算所支持的最大设备宽度时将按基准宽度计算，单位 px App（vue2 且不含 nvue）、H5（2.8.12+） rpxCalcIncludeWidth Number 750 rpx 计算特殊处理的值，始终按实际的设备宽度计算，单位 rpx App（vue2 且不含 nvue）、H5（2.8.12+） dynamicRpx Boolean false 动态 rpx，屏幕大小变化会重新渲染 rpx App-nvue（vue3 固定值为 true） 3.2.13+ maxWidth Number 单位px，当浏览器可见区域宽度大于maxWidth时，两侧留白，当小于等于maxWidth时，页面铺满；不同页面支持配置不同的maxWidth；maxWidth = leftWindow(可选)+page(页面主体)+rightWindow(可选) H5（2.9.9+） 1.2 pages uni-app 通过 pages 节点配置应用由哪些页面组成，pages 节点接收一个数组，数组每个项都是一个对象，其属性值如下： pages节点的第一项为应用入口页（即首页） 应用中新增/减少页面，都需要对 pages 数组进行修改 文件名不需要写后缀，框架会自动寻找路径下的页面资源 属性 类型 默认值 描述 path String 配置页面路径 style Object 配置页面窗口表现，配置项参考下方 pageStyle { \"pages\": [ { \"path\": \"pages/index/index\", \"style\": { ... } }, { \"path\": \"pages/login/login\", \"style\": { ... } } ] } 1.3 style 用于设置每个页面的状态栏、导航条、标题、窗口背景色等。 页面中配置项会覆盖 globalStyle 中相同的配置项 使用 maxWidth 时，页面内fixed元素需要使用--window-left,--window-right来保证布局位置正确 属性 类型 默认值 描述 平台差异说明 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色（同状态栏背景色），如\"#000000\" navigationBarTextStyle String white 导航栏标题颜色及状态栏前景颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 navigationBarShadow Object 导航栏阴影，配置参考下方 导航栏阴影 navigationStyle String default 导航栏样式，仅支持 default/custom。custom即取消默认的原生导航栏，需看使用注意 微信小程序 7.0+、百度小程序、H5、App（2.0.3+） disableScroll Boolean false 设置为 true 则页面整体不能上下滚动（bounce效果），只在页面配置中有效，在globalStyle中设置无效 微信小程序（iOS）、百度小程序（iOS） backgroundColor HexColor #ffffff 窗口的背景色 微信小程序、百度小程序、字节跳动小程序、飞书小程序、京东小程序 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面生命周期。 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见页面生命周期 backgroundColorTop HexColor #ffffff 顶部窗口的背景色（bounce回弹区域） 仅 iOS 平台 backgroundColorBottom HexColor #ffffff 底部窗口的背景色（bounce回弹区域） 仅 iOS 平台 disableSwipeBack Boolean false 是否禁用滑动返回 App-iOS（3.4.0+） titleImage String 导航栏图片地址（替换当前文字标题），支付宝小程序内必须使用https的图片链接地址 支付宝小程序、H5、App transparentTitle String none 导航栏透明设置。支持 always 一直透明 / auto 滑动自适应 / none 不透明 支付宝小程序、H5、APP titlePenetrate String NO 导航栏点击穿透 支付宝小程序、H5 app-plus Object 设置编译到 App 平台的特定样式，配置项参考下方 app-plus App h5 Object 设置编译到 H5 平台的特定样式，配置项参考下方 H5 H5 mp-alipay Object 设置编译到 mp-alipay 平台的特定样式，配置项参考下方 MP-ALIPAY 支付宝小程序 mp-weixin Object 设置编译到 mp-weixin 平台的特定样式 微信小程序 mp-baidu Object 设置编译到 mp-baidu 平台的特定样式 百度小程序 mp-toutiao Object 设置编译到 mp-toutiao 平台的特定样式 字节跳动小程序 mp-lark Object 设置编译到 mp-lark 平台的特定样式 飞书小程序 mp-qq Object 设置编译到 mp-qq 平台的特定样式 QQ小程序 mp-kuaishou Object 设置编译到 mp-kuaishou 平台的特定样式 快手小程序 mp-jd Object 设置编译到 mp-jd 平台的特定样式 京东小程序 usingComponents Object 引用小程序组件，参考 小程序组件 App、微信小程序、支付宝小程序、百度小程序、京东小程序 leftWindow Boolean true 当存在 leftWindow时，当前页面是否显示 leftWindow H5 topWindow Boolean true 当存在 topWindow 时，当前页面是否显示 topWindow H5 rightWindow Boolean true 当存在 rightWindow时，当前页面是否显示 rightWindow H5 maxWidth Number 单位px，当浏览器可见区域宽度大于maxWidth时，两侧留白，当小于等于maxWidth时，页面铺满；不同页面支持配置不同的maxWidth；maxWidth = leftWindow(可选)+page(页面主体)+rightWindow(可选) H5（2.9.9+ { \"pages\": [{ \"path\": \"pages/index/index\", \"style\": { \"navigationBarTitleText\": \"首页\",//设置页面标题文字 \"enablePullDownRefresh\":true//开启下拉刷新 } }, ... ] } 1.3.1 app-plus 配置编译到 App 平台时的特定样式，部分常用配置 H5 平台也支持。以下仅列出常用，更多配置项参考 WebviewStyles .nvue 页面仅支持 titleNView、pullToRefresh、scrollIndicator 配置，其它配置项暂不支持 属性 类型 默认值 描述 平台兼容 background HexColor #FFFFFF 窗体背景色。无论vue页面还是nvue页面，在App上都有一个父级原生窗体，该窗体的背景色生效时间快于页面里的css生效时间 App titleNView Object 导航栏 ，详见:导航栏 App、H5 subNVues Object 原生子窗体，详见:原生子窗体 App 1.9.10+ bounce String 页面回弹效果，设置为 \"none\" 时关闭效果。 App-vue（nvue Android无页面级bounce效果，仅list、recycle-list、waterfall等滚动组件有bounce效果） popGesture String close 侧滑返回功能，可选值：\"close\"（启用侧滑返回）、\"none\"（禁用侧滑返回） App-iOS softinputNavBar String auto iOS软键盘上完成工具栏的显示模式，设置为 \"none\" 时关闭工具栏。 App-iOS softinputMode String adjustPan 软键盘弹出模式，支持 adjustResize、adjustPan 两种模式 App pullToRefresh Object 下拉刷新 App scrollIndicator String 滚动条显示策略，设置为 \"none\" 时不显示滚动条。 App animationType String pop-in 窗口显示的动画效果，详见：窗口动画。 App animationDuration Number 300 窗口显示动画的持续时间，单位为 ms。 App 1.3.1.1 titleNView (导航栏) 属性 类型 默认值 描述 版本兼容性 backgroundColor String #F7F7F7 背景颜色，支持16进制颜色或RGBA颜色。 App端仅悬浮导航栏支持RGBA颜色 buttons Array 自定义按钮，详见 buttons 纯nvue即render:native时暂不支持 titleColor String #000000 标题文字颜色 titleOverflow String ellipsis 标题文字超出显示区域时处理方式。\"clip\"-超出显示区域时内容裁剪；\"ellipsis\"-超出显示区域时尾部显示省略标记（...）。 titleText String 标题文字内容 titleSize String 标题文字字体大小 type String default 导航栏样式。\"default\"-默认样式；\"transparent\"-滚动透明渐变；\"float\"-悬浮导航栏。 App-nvue 2.4.4+ 支持、App-vue、H5 tags Array 原生 View 增强，详见：5+ View 控件 searchInput Object 原生导航栏上的搜索框配置，详见：searchInput 1.6.0 homeButton Boolean false 标题栏控件是否显示Home按钮 autoBackButton Boolean true 标题栏控件是否显示左侧返回按钮 App 2.6.3+ backButton Object 返回按钮的样式，详见：backButton App 2.6.3 backgroundImage String 支持以下类型： 背景图片路径 - 如\"/static/img.png\"，仅支持本地文件绝对路径，根据实际标题栏宽高拉伸绘制； 渐变色 - 仅支持线性渐变，两种颜色的渐变，如“linear-gradient(to top, #a80077, #66ff00)”， 其中第一个参数为渐变方向，可取值： \"to right\"表示从左向右渐变， “to left\"表示从右向左渐变， “to bottom\"表示从上到下渐变， “to top\"表示从下到上渐变， “to bottom right\"表示从左上角到右下角， “to top left\"表示从右下角到左上角 2.6.3 backgroundRepeat String 仅在backgroundImage设置为图片路径时有效。 可取值： \"repeat\" - 背景图片在垂直方向和水平方向平铺； \"repeat-x\" - 背景图片在水平方向平铺，垂直方向拉伸； “repeat-y” - 背景图片在垂直方向平铺，水平方向拉伸； “no-repeat” - 背景图片在垂直方向和水平方向都拉伸。 默认使用 “no-repeat\" 2.6.3 titleAlign String \"auto\" 可取值： \"center\"-居中对齐； \"left\"-居左对齐； \"auto\"-根据平台自动选择（Android平台居左对齐，iOS平台居中对齐） 2.6.3 blurEffect String \"none\" 此效果将会高斯模糊显示标题栏后的内容，仅在type为\"transparent\"或\"float\"时有效。 可取值： \"dark\" - 暗风格模糊，对应iOS原生UIBlurEffectStyleDark效果； \"extralight\" - 高亮风格模糊，对应iOS原生UIBlurEffectStyleExtraLight效果； \"light\" - 亮风格模糊，对应iOS原生UIBlurEffectStyleLight效果； \"none\" - 无模糊效果。 注意：使用模糊效果时应避免设置背景颜色，设置背景颜色可能覆盖模糊效果。 2.4.3 coverage String \"132px\" 标题栏控件变化作用范围，仅在type值为transparent时有效，页面滚动时标题栏背景透明度将发生变化。 当页面滚动到指定偏移量时标题栏背景变为完全不透明。 支持百分比、像素值 splitLine Boolean false 标题栏的底部分割线(SplitLineStyles)，设置此属性则在标题栏控件的底部显示分割线，可配置颜色值及高度。 设置此属性值为undefined或null则隐藏分割线。 默认不显示底部分割线 2.6.6 subtitleColor String 副标题文字颜色，颜色值格式为\"#RRGGBB\"和\"rgba(R,G,B,A)\"，如\"#FF0000\"表示标题文字颜色为红色。 默认值与主标题文字颜色一致 2.6.6 subtitleSize String \"auto\" 副标题文字字体大小，字体大小单位为像素，如\"14px\"表示字体大小为14像素，默认值为12像素。 2.6.6 subtitleOverflow String \"ellipsis\" 标题文字超出显示区域时处理方式，可取值： \"clip\" - 超出显示区域时内容裁剪； \"ellipsis\" - 超出显示区域时尾部显示省略标记（...）。 2.6.6 subtitleText String 副标题文字内容，设置副标后将显示两行标题，副标显示在主标题（titleText）下方。 注意：设置副标题后将居左显示 2.6.6 titleIcon String 标题图标，图标路径如\"./img/t.png\"，仅支持本地文件路径， 相对路径，相对于当前页面的host位置，固定宽高为逻辑像素值\"34px\"。 要求图片的宽高相同。 注意：设置标题图标后标题将居左显示。 2.6.6 titleIconRadius String 无圆角 标题图标圆角，取值格式为\"XXpx\"，其中XX为像素值（逻辑像素），如\"10px\"表示10像素半径圆角。 2.6.6 1.3.1.1.1 splitLine 属性 类型 默认值 描述 版本兼容性 color String #CCCCCC 底部分割线颜色，可取值： \"#RRGGBB\"格式字符串，如\"#FF0000\"表示绘制红色分割线； \"rgba(R,G,B,A)\"，其中R/G/B分别代表红色值/绿色值/蓝色值，正整数类型，取值范围为0-255，A为透明度，浮点数类型，取值范围为0-1（0为全透明，1为不透明），如\"rgba(255,0,0,0.5)\"，表示红色半透明 height String \"1px\" 可取值：像素值（逻辑像素），支持小数点，如\"1px\"表示1像素高；百分比，如\"1%\"，相对于标题栏控件的高度。 1.3.1.1.2 自定义按钮 属性 类型 默认值 描述 type String none 按钮样式，可取值见：buttons 样式 color String 默认与标题文字颜色一致 按钮上文字颜色 background String 默认值为灰色半透明 按钮的背景颜色，仅在标题栏type=transparent时生效 colorPressed String 默认值为 color 属性值自动调整透明度为 0.3 按下状态按钮文字颜色 float String right 按钮在标题栏上的显示位置，可取值\"left\"、\"right\" fontWeight String normal 按钮上文字的粗细。可取值\"normal\"-标准字体、\"bold\"-加粗字体。 fontSize String 按钮上文字大小 fontSrc String 按钮上文字使用的字体文件路径。不支持网络地址，请统一使用本地地址。 select String false 是否显示选择指示图标（向下箭头），常用于城市选择 text String 按钮上显示的文字。使用字体图标时 unicode 字符表示必须 '\\u' 开头，如 \"\\ue123\"（注意不能写成\"\\e123\"）。 width String 44px 按钮的宽度，可取值： \"*px\" - 逻辑像素值，如\"10px\"表示10逻辑像素值，不支持rpx。按钮的内容居中显示； \"auto\" - 自定计算宽度，根据内容自动调整按钮宽度 1.3.1.1.3 自定义返回按钮的样式 当autoBackButton设置为true时生效。 通过此属性可自定义返回按钮样式，如图标大小、红点、角标、标题等。 属性 类型 默认值 描述 background String none 背景颜色，仅在标题栏type=transparent时生效，当标题栏透明时按钮显示的背景颜色。 可取值#RRGGBB和rgba格式颜色字符串，默认值为灰色半透明。 badgeText String 角标文本，最多显示3个字符，超过则显示为... color String 窗口标题栏控件的标题文字颜色。 图标和标题颜色，可取值： \"#RRGGBB\"格式字符串，如\"#FF0000\"表示红色； \"rgba(R,G,B,A)\"，其中R/G/B分别代表红色值/绿色值/蓝色值，正整数类型，取值范围为0-255，A为透明度，浮点数类型，取值范围为0-1（0为全透明，1为不透明），如\"rgba(255,0,0,0.5)\"，表示红色半透明。 colorPressed String 按下状态按钮文字颜色，可取值： \"#RRGGBB\"格式字符串，如\"#FF0000\"表示红色； \"rgba(R,G,B,A)\"，其中R/G/B分别代表红色值/绿色值/蓝色值，正整数类型，取值范围为0-255，A为透明度，浮点数类型，取值范围为0-1（0为全透明，1为不透明），如\"rgba(255,0,0,0.5)\"，表示红色半透明。 默认值为color属性值自动调整透明度为0.3。 fontWeight String \"normal\" 返回图标的粗细，可取值： \"normal\" - 标准字体； \"bold\" - 加粗字体。 fontSize String 返回图标文字大小，可取值：字体高度像素值，数字加\"px\"格式字符串，如\"22px\"。 窗口标题栏为透明样式（type=\"transparent\"）时，默认值为\"22px\"； 窗口标题栏为默认样式（type=\"default\"）时，默认值为\"27px\"。 redDot Boolean false 是否显示红点，设置为true则显示红点，false则不显示红点。默认值为false。 注意：当设置了角标文本时红点不显示。 title String 返回按钮上的标题，显示在返回图标（字体图标）后，默认为空字符串。 titleWeight String \"normal\" 返回按钮上标题的粗细，可取值： \"normal\" - 标准字体； \"bold\" - 加粗字体。 1.3.1.1.4 按钮样式 使用 type 值设置按钮的样式时，会忽略 fontSrc 和 text 属性。 值 说明 forward 前进按钮 back 后退按钮 share 分享按钮 favorite 收藏按钮 home 主页按钮 menu 菜单按钮 close 关闭按钮 none 无样式，需通过 text 属性设置按钮上显示的内容、通过 fontSrc 属性设置使用的字体库。 1.3.1.1.5 搜索框配置 searchInput可以在titleNView的原生导航栏上放置搜索框。其宽度根据周围元素自适应。 | 属性 | 类型 | 默认值 | 描述 | | :--------------- | :------ | :-------------------- | :----------------------------------------------------------- | | autoFocus | Boolean | false | 是否自动获取焦点 | | align | String | center | 非输入状态下文本的对齐方式。可取值： \"left\" - 居左对齐； \"right\" - 居右对齐； \"center\" - 居中对齐。 | | backgroundColor | String | rgba(255,255,255,0.5) | 背景颜色 | | borderRadius | String | 0px | 输入框的圆角半径，取值格式为\"XXpx\"，其中XX为像素值（逻辑像素），不支持rpx。 | | placeholder | String | | 提示文本。 | | placeholderColor | String | #CCCCCC | 提示文本颜色 | | disabled | Boolean | false | 是否可输入 | 常见titleNView配置代码示例 buttons 的 text 推荐使用字体图标。如果使用了汉字或英文，推荐把字体改小一点，否则文字长度增加后，距离屏幕右边距太近。 App平台，buttons动态修改，详见 App平台，buttons角标动态修改，见 hello uni-app 中模板-顶部导航标题栏-导航栏带红点和角标 App平台，设置searchInput的文字动态修改，API见文档。注意disable状态无法设置文字、placehold暂不支持动态设置 H5平台，如需实现上述动态修改，需在条件编译通过dom操作修改 { \"pages\": [{ \"path\": \"pages/index/index\", //首页 \"style\": { \"app-plus\": { \"titleNView\": false //禁用原生导航栏 } } }, { \"path\": \"pages/log/log\", //日志页面 \"style\": { \"app-plus\": { \"bounce\": \"none\", //关闭窗口回弹效果 \"titleNView\": { \"buttons\": [ //原生标题栏按钮配置, { \"text\": \"分享\" //原生标题栏增加分享按钮，点击事件可通过页面的 onNavigationBarButtonTap 函数进行监听 } ], \"backButton\": { //自定义 backButton \"background\": \"#00FF00\" } } } } }, { \"path\": \"pages/detail/detail\", //详情页面 \"style\": { \"navigationBarTitleText\": \"详情\", \"app-plus\": { \"titleNView\": { \"type\": \"transparent\"//透明渐变导航栏 App-nvue 2.4.4+ 支持 } } } }, { \"path\": \"pages/search/search\", //搜索页面 \"style\": { \"app-plus\": { \"titleNView\": { \"type\": \"transparent\",//透明渐变导航栏 App-nvue 2.4.4+ 支持 \"searchInput\": { \"backgroundColor\": \"#fff\", \"borderRadius\": \"6px\", //输入框圆角 \"placeholder\": \"请输入搜索内容\", \"disabled\": true //disable时点击输入框不置焦，可以跳到新页面搜索 } } } } } ... ] } 1.3.1.2 subNVues(原生子窗体) subNVues 是 vue 页面的原生子窗体。用于解决App中 vue 页面中的层级覆盖和原生界面灵活自定义用的。 它不是全屏页面，也不是组件，就是一个原生子窗体。它是一个 nvue 页面，使用 weex 引擎渲染，提供了比 cover-view、plus.nativeObj.view 更强大的原生排版能力，方便自定义原生导航或覆盖原生地图、视频等。请详读subNVues 开发指南 subNVue 也可以在 nvue 页面中使用。 subNVues 的 id 是全局唯一的，不能重复 可以通过 uni.getSubNVueById('id') 获取 subNVues 的实例 subNVues 的 path 属性只能是 nvue 文件路径 属性 类型 描述 id String subNVue 原生子窗体的标识 path String 配置 nvue 文件路径，nvue 文件需放置到使用 subNvue 的页面文件目录下 type String 原生子窗口内置样式，可取值：'popup',弹出层；\"navigationBar\",导航栏 style Object subNVue 原生子窗体的样式，配置项参考下方 subNVuesStyle 1.3.1.2.1 原生子窗体样式 属性 类型 默认值 描述 position String absolute 原生子窗体的排版位置，排版位置决定原生子窗体在父窗口中的定位方式。 可取值：\"static\"，原生子窗体在页面中正常定位，如果页面存在滚动条则随窗口内容滚动；\"absolute\"，原生子窗体在页面中绝对定位，如果页面存在滚动条不随窗口内容滚动；\"dock\"，原生子窗体在页面中停靠，停靠的位置由dock属性值决定。 默认值为\"absolute\"。 dock String bottom 原生子窗体的停靠方式,仅当原生子窗体 \"position\" 属性值设置为 \"dock\" 时才生效，可取值：\"top\"，原生子窗体停靠则页面顶部；\"bottom\"，原生子窗体停靠在页面底部；\"right\"，原生子窗体停靠在页面右侧；\"left\"，原生子窗体停靠在页面左侧。 默认值为\"bottom\"。 mask HexColor rgba(0,0,0,0.5) 原生子窗体的遮罩层,仅当原生子窗体 \"type\" 属性值设置为 \"popup\" 时才生效，可取值： rgba格式字符串，定义纯色遮罩层样式，如\"rgba(0,0,0,0.5)\"，表示黑色半透明； width String 100% 原生子窗体的宽度,支持百分比、像素值，默认为100%。未设置width属性值时，可同时设置left和right属性值改变窗口的默认宽度。 height String 100% 原生子窗体的高度,支持百分比、像素值，默认为100%。 当未设置height属性值时，优先通过top和bottom属性值来计算原生子窗体的高度。 top String 0px 原生子窗体垂直向下的偏移量，支持百分比、像素值，默认值为0px。 未设置top属性值时，优先通过bottom和height属性值来计算原生子窗体的top位置。 bottom String 原生子窗体垂直向上偏移量,支持百分比、像素值，默认值无值（根据top和height属性值来自动计算）。 当同时设置了top和height值时，忽略此属性值； 当未设置height值时，可通过top和bottom属性值来确定原生子窗体的高度。 left String 0px 原生子窗体水平向左的偏移量，支持百分比、像素值，默认值为0px。 未设置left属性值时，优先通过right和width属性值来计算原生子窗体的left位置。 right String 原生子窗体水平向右的偏移量，支持百分比、像素值，默认无值（根据left和width属性值来自动计算）。 当设置了left和width值时，忽略此属性值； 当未设置width值时，可通过left和bottom属性值来确定原生子窗体的宽度。 margin String 原生子窗体的边距，用于定位原生子窗体的位置，支持auto，auto表示居中。若设置了left、right、top、bottom则对应的边距值失效。 zindex Number 原生子窗体的窗口的堆叠顺序值，拥有更高堆叠顺序的窗口总是会处于堆叠顺序较低的窗口的前面，拥有相同堆叠顺序的窗口后调用show方法则在前面。 background String #FFFFFF 窗口的背景颜色,Android平台4.0以上系统才支持“transparent”背景透明样式。比如subnvue为圆角时需要设置为 { \"pages\": [{ \"path\": \"pages/index/index\", //首页 \"style\": { \"app-plus\": { \"titleNView\": false , //禁用原生导航栏 \"subNVues\":[{//侧滑菜单 \"id\": \"drawer\", //subNVue 的 id，可通过 uni.getSubNVueById('drawer') 获取 \"path\": \"pages/index/drawer.nvue\", // nvue 路径 \"style\": { //webview style 子集，文档可暂时开放出来位置，大小相关配置 \"position\": \"popup\", //除 popup 外，其他值域参考 5+ webview position 文档 \"width\": \"50%\" } }, {//弹出层 \"id\": \"popup\", \"path\": \"pages/index/popup\", \"style\": { \"position\": \"popup\", \"margin\":\"auto\", \"width\": \"150px\", \"height\": \"150px\" } }, {//自定义头 \"id\": \"nav\", \"path\": \"pages/index/nav\", \"style\": { \"position\": \"dock\", \"height\": \"44px\" } }] } } }] } 1.3.1.3 下拉刷新 在 App 平台下可以自定义部分下拉刷新的配置 page->style->app-plus->pullToRefresh。 enablePullDownRefresh 与 pullToRefresh->support 同时设置时，后者优先级较高。 如果期望在 App 和小程序上均开启下拉刷新的话，请配置页面的 enablePullDownRefresh 属性为 true。 若仅期望在 App 上开启下拉刷新，则不要配置页面的 enablePullDownRefresh 属性，而是配置 pullToRefresh->support 为 true。 开启原生下拉刷新时，页面里不应该使用全屏高的scroll-view，向下拖动内容时，会优先触发下拉刷新而不是scroll-view滚动 原生下拉刷新的起始位置在原生导航栏的下方，如果取消原生导航栏，使用自定义导航栏，原生下拉刷新的位置会在屏幕顶部。如果希望在自定义导航栏下方拉动，只能使用circle方式的下拉刷新，并设置offset参数，将circle圈的起始位置调整到自定义导航栏下方。hello uni-app的扩展组件中有示例。 如果想在app端实现更多复杂的下拉刷新，比如美团、京东App那种拉下一个特殊图形，可以使用nvue的组件。HBuilderX 2.0.3+起，新建项目选择新闻模板可以体验 如果想在vue页面通过web前端技术实现下拉刷新，插件市场有例子，但前端下拉刷新的性能不如原生，复杂长列表会很卡 iOS上，default模式的下拉刷新和bounce回弹是绑定的，如果设置了bounce:none，会导致无法使用default下拉刷新 属性 类型 默认值 描述 support Boolean false 是否开启窗口的下拉刷新功能 color String #2BD009 颜色值格式为\"#RRGGBB\"，仅\"circle\"样式下拉刷新支持此属性。 style String Android 平台为 circle；iOS 平台为 default。 可取值：\"default\"——经典下拉刷新样式（下拉拖动时页面内容跟随）；\"circle\"——圆圈样式下拉刷新控件样式（下拉拖动时仅刷新控件跟随）。 height String 窗口的下拉刷新控件进入刷新状态的拉拽高度。支持百分比，如\"10%\"；像素值，如\"50px\"，不支持rpx。 range String 窗口可下拉拖拽的范围。支持百分比，如\"10%\"；像素值，如\"50px\"，不支持rpx。 offset String 0px 下拉刷新控件的起始位置。仅对\"circle\"样式下拉刷新控件有效，用于定义刷新控件下拉时的起始位置。支持百分比，如\"10%\"；像素值，如\"50px\"，不支持rpx。如使用了非原生title且需要原生下拉刷新，一般都使用circle方式并将offset调至自定义title的高度 contentdown Object 目前支持一个属性：caption——在下拉可刷新状态时下拉刷新控件上显示的标题内容。仅对\"default\"样式下拉刷新控件有效。 contentover Object 目前支持一个属性：caption——在释放可刷新状态时下拉刷新控件上显示的标题内容。仅对\"default\"样式下拉刷新控件有效。 contentrefresh Object 目前支持一个属性：caption——在正在刷新状态时下拉刷新控件上显示的标题内容。仅对\"default\"样式下拉刷新控件有效。 { \"pages\": [ { \"path\": \"pages/index/index\", //首页 \"style\": { \"app-plus\": { \"pullToRefresh\": { \"support\": true, \"color\": \"#ff3333\", \"style\": \"default\", \"contentdown\": { \"caption\": \"下拉可刷新自定义文本\" }, \"contentover\": { \"caption\": \"释放可刷新自定义文本\" }, \"contentrefresh\": { \"caption\": \"正在刷新自定义文本\" } } } } } ] } 1.3.2 h5 用到再看。 1.4 tabBar 如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定一级导航栏，以及 tab 切换时显示的对应页。 在 pages.json 中提供 tabBar 配置，不仅仅是为了方便快速开发导航，更重要的是在App和小程序端提升性能。在这两个平台，底层原生引擎在启动时无需等待js引擎初始化，即可直接读取 pages.json 中配置的 tabBar 信息，渲染原生tab。 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 tabbar 切换第一次加载时可能渲染不及时，可以在每个tabbar页面的onLoad生命周期里先弹出一个等待雪花（hello uni-app使用了此方式） tabbar 的页面展现过一次后就保留在内存中，再次切换 tabbar 页面，只会触发每个页面的onShow，不会再触发onLoad。 顶部的 tabbar 目前仅微信小程序上支持。需要用到顶部选项卡的话，建议不使用 tabbar 的顶部设置，而是自己做顶部选项卡，可参考 hello uni-app->模板->顶部选项卡。 属性 类型 必填 默认值 描述 平台差异说明 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar 上边框的颜色，可选值 black/white，也支持其他颜色值 App 2.3.4+ 、H5 3.0.0+ blurEffect String 否 none iOS 高斯模糊效果，可选值 dark/extralight/light/none（参考:使用说明） App 2.4.0+ 支持、H5 3.0.0+（只有最新版浏览器才支持） list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top top 值仅微信小程序支持 fontSize String 否 10px 文字默认大小 App 2.3.4+、H5 3.0.0+ iconWidth String 否 24px 图标默认宽度（高度等比例缩放） App 2.3.4+、H5 3.0.0+ spacing String 否 3px 图标和文字的间距 App 2.3.4+、H5 3.0.0+ height String 否 50px tabBar 默认高度 App 2.3.4+、H5 3.0.0+ midButton Object 否 中间按钮 仅在 list 项为偶数时有效 App 2.3.4+、H5 3.0.0+ iconfontSrc String 否 list设置 iconfont 属性时，需要指定字体文件路径 App 3.4.4+、H5 3.5.3+ 其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 平台差异 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字，在 App 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 position 为 top 时，此参数无效，不支持网络图片，不支持字体图标 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 position 为 top 时，此参数无效 visible Boolean 否 该项是否显示，默认显示 App (3.2.10+)、H5 (3.2.10+) iconfont Object 否 字体图标，优先级高于 iconPath App（3.4.4+）、H5 (3.5.3+) midButton 属性说明 midButton没有pagePath，需监听点击事件，自行处理点击后的行为逻辑。监听点击事件为调用API：uni.onTabBarMidButtonTap，详见https://uniapp.dcloud.io/api/ui/tabbar?id=ontabbarmidbuttontap 属性 类型 必填 默认值 描述 width String 否 80px 中间按钮的宽度，tabBar 其它项为减去此宽度后平分，默认值为与其它项平分宽度 height String 否 50px 中间按钮的高度，可以大于 tabBar 高度，达到中间凸起的效果 text String 否 中间按钮的文字 iconPath String 否 中间按钮的图片路径 iconWidth String 否 24px 图片宽度（高度等比例缩放） backgroundImage String 否 中间按钮的背景图片路径 iconfont Object 否 字体图标，优先级高于 iconPath iconfont参数说明: 属性 类型 说明 text String 字库 Unicode 码 selectedText String 选中后字库 Unicode 码 fontSize String 字体图标字号(px) color String 字体图标颜色 selectedColor String 字体图标选中颜色 1.4.1 tabbar常见问题 tabbar 的 js api 见接口-界面-tabbar，可实现动态显示隐藏（如弹出层无法覆盖tabbar）、内容修改（如国际化）、item加角标等功能。hello uni-app中也有示例。 tabbar 的 item 点击事件见页面生命周期的onTabItemTap。 代码跳转到 tabbar 页面，api只能使用uni.switchTab，不能使用uni.navigateTo、uni.redirectTo；使用navigator组件跳转时必须设置open-type=\"switchTab\" tabbar 的默认高度，在不同平台不一样。App端的默认高度在HBuilderX 2.3.4起从56px调整为50px，与H5端统一。开发者也可以自行设定高度，调回56px。详见 tabbar 在H5端是div模拟的，属于前端屏幕窗口的一部分，如果要使用bottom居底定位方式，应该使用css变量--window-bottom，比如悬浮在tabbar上方10px的按钮，样式如下bottom: calc(var(--window-bottom) + 10px) 中间带+号的tabbar模板例子，参考。可跨端，但+号不凸起。如需中间凸起，配置tabbar的midButton。 如果是需要先登录、后进入tab页面，不需要把登录页设为首页，首页仍然是tabbar页，可参考云端一体登录模板 前端弹出遮罩层挡不住tabbar的问题，跨端处理方式时动态隐藏tabbar。App端可以使用plus.nativeObj.view或subNVue做弹出和遮罩，可参考这个底部原生图标分享菜单例子 微信小程序模拟器1.02.1904090版有bug，在缩放模拟器页面百分比后，tabbar点击多次后就会卡死。真机无碍，使用时注意。详见 PC宽屏上，当页面存在topWindow或leftWindow或rightWindow等多窗体结构时，若想改变 tabbar 显示的位置，请使用 custom-tab-bar组件 配置，若想隐藏 tabbar，可以使用如下 css（好处是可以和 leftwindow 等窗体联动）： 1.4.2 自定义tabbar 原生tabBar是相对固定的配置方式，可能无法满足所有场景，这就涉及到自定义tabBar。 但注意除了H5端，自定义tabBar的性能体验会低于原生tabBar。App和小程序端非必要不要自定义。 H5端的自定义tabBar组件：H5端不存在原生tabBar性能更高的概念，并且宽屏下常见的tabBar在顶部而不是底部，此时可以使用 custom-tab-bar组件 来自定义 普通自定义tabBar：使用view自行绘制tabBar。如果页面是多页方式，切换tabBar将无法保持底部tabBar一直显示。所以这种情况建议使用单页方式。单页方式，如果是复杂页面，应用性能会下降明显，需减少页面复杂度。如果是App端，nvue单页的性能会显著高于vue页面 微信小程序自定义tabbar：微信提供一直基于webview自定义tabBar的方案。该功能体验不佳，不太推荐使用。如果要使用，参考微信文档，项目根创建 custom-tab-bar 目录，注意里边的代码是 wxml,wxss，不是 vue，uni-app编译器会直接拷贝该目录到微信小程序中 原生的tabbar有且只有一个且在首页。二级页如需的tab，需自行编写view来实现。一般二级页面更适合的导航是 segement组件 1.5 condition 启动模式配置，仅开发期间生效，用于模拟直达页面的场景，如：小程序转发后，用户点击所打开的页面。 属性说明： 属性 类型 是否必填 描述 current Number 是 当前激活的模式，list节点的索引值 list Array 是 启动模式列表 list说明： 属性 类型 是否必填 描述 name String 是 启动模式名称 path String 是 启动页面路径 query String 否 启动参数，可在页面的 onLoad 函数里获得 \"condition\": { //模式配置，仅开发期间生效 \"current\": 0, //当前激活的模式（list 的索引项） \"list\": [{ \"name\": \"swiper\", //模式名称 \"path\": \"pages/component/swiper/swiper\", //启动页面，必选 \"query\": \"interval=4000&autoplay=false\" //启动参数，在页面的onLoad函数里面得到。 }, { \"name\": \"test\", \"path\": \"pages/component/switch/switch\" } ] } 1.6 subPackages 分包加载配置，此配置为小程序的分包加载机制。 因小程序有体积和资源加载限制，各家小程序平台提供了分包方式，优化小程序的下载和启动速度。 所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据pages.json的配置进行划分。 在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，会把对应分包自动下载下来，下载完成后再进行展示。此时终端界面会有等待提示。 App默认为整包。从uni-app 2.7.12+ 开始，也兼容了小程序的分包配置。其目的不用于下载提速，而用于首页是vue时的启动提速。App下开启分包，除在pages.json中配置分包规则外，还需要在manifest中设置在app端开启分包设置，详见：https://uniapp.dcloud.io/collocation/manifest?id=app-vue-optimization subPackages 节点接收一个数组，数组每一项都是应用的子包，其属性值如下： 属性 类型 是否必填 描述 root String 是 子包的根目录 pages Array 是 子包由哪些页面组成，参数同 pages 注意： subPackages 里的pages的路径是 root 下的相对路径，不是全路径。 微信小程序每个分包的大小是2M，总体积一共不能超过20M。 百度小程序每个分包的大小是2M，总体积一共不能超过8M。 支付宝小程序每个分包的大小是2M，总体积一共不能超过8M。 QQ小程序每个分包的大小是2M，总体积一共不能超过24M。 字节小程序每个分包的大小是2M，总体积一共不能超过16M（字节小程序基础库 1.88.0 及以上版本开始支持，字节小程序开发者工具请使用大于等于 2.0.6 且小于 3.0.0 的版本）。 快手小程序每个分包的大小是2M，总体积一共不能超过24M。 分包下支持独立的 static 目录，用来对静态资源进行分包。 uni-app内支持对微信小程序、QQ小程序、百度小程序、支付宝小程序、字节小程序(HBuilderX 3.0.3+)、快手小程序分包优化，即将静态资源或者js文件放入分包内不占用主包大小。详情请参考：关于分包优化的说明 针对vendor.js过大的情况可以使用运行时压缩代码 HBuilderX创建的项目勾选运行-->运行到小程序模拟器-->运行时是否压缩代码 cli创建的项目可以在package.json中添加参数--minimize，示例：\"dev:mp-weixin\": \"cross-env NODE_ENV=development UNI_PLATFORM=mp-weixin vue-cli-service uni-build --watch --minimize\" 使用方法： 假设支持分包的 uni-app 目录结构如下： ┌─pages │ ├─index │ │ └─index.vue │ └─login │ └─login.vue ├─pagesA │ ├─static │ └─list │ └─list.vue ├─pagesB │ ├─static │ └─detail │ └─detail.vue ├─static ├─main.js ├─App.vue ├─manifest.json └─pages.json 则需要在 pages.json 中填写 { \"pages\": [{ \"path\": \"pages/index/index\", \"style\": { ...} }, { \"path\": \"pages/login/login\", \"style\": { ...} }], \"subPackages\": [{ \"root\": \"pagesA\", \"pages\": [{ \"path\": \"list/list\", \"style\": { ...} }] }, { \"root\": \"pagesB\", \"pages\": [{ \"path\": \"detail/detail\", \"style\": { ...} }] }], \"preloadRule\": { \"pagesA/list/list\": { \"network\": \"all\", \"packages\": [\"__APP__\"] }, \"pagesB/detail/detail\": { \"network\": \"all\", \"packages\": [\"pagesA\"] } } } 1.6 preloadRule 用到再看。 2. manifest.json 应用配置 manifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等。HBuilderX 创建的工程此文件在根目录，CLI 创建的工程此文件在 src 目录。 配置项列表 属性 类型 默认值 描述 最低版本 name String 应用名称 appid String 新建 uni-app 项目时，DCloud 云端分配。用途详见 应用标识 description String 应用描述 locale String auto 设置当前默认语言，具体参考 locale versionName String 版本名称，例如：1.0.0。详见下方Tips说明 versionCode Number 版本号，例如：36 transformPx Boolean true 是否转换项目的px，为true时将px转换为rpx，为false时，px为传统的实际像素。为兼容历史项目默认值为 true，但不推荐新项目启用此配置（新建项目模板一般配置为 false） networkTimeout Object 网络超时时间，详见 debug Boolean false 是否开启 debug 模式，开启后调试信息以 info 的形式给出，其信息有页面的注册，页面路由，数据更新，事件触发等 uniStatistics Object 是否开启 uni 统计，全局配置 2.2.3+ app-plus Object App 特有配置 h5 Object H5 特有配置 quickapp Object 快应用特有配置，即将支持 mp-weixin Object 微信小程序特有配置 mp-alipay Object 支付宝小程序特有配置 mp-baidu Object 百度小程序特有配置 mp-toutiao Object 字节跳动小程序特有配置 1.6.0 mp-lark Object 飞书小程序特有配置 3.2.12 mp-qq Object qq 小程序特有配置 2.1.0 mp-kuaishou Object 快手小程序特有配置 3.2.2 2.1 networkTimeout 各类网络请求的超时时间，单位均为毫秒。 属性 类型 必填 默认值 说明 request Number 否 60000 uni.request 的超时时间，单位毫秒。 connectSocket Number 否 60000 uni.connectSocket 的超时时间，单位毫秒。 uploadFile Number 否 60000 uni.uploadFile 的超时时间，单位毫秒。 downloadFile Number 否 60000 uni.downloadFile 的超时时间，单位毫秒。 2.2 uniStatistics uni 统计配置项 属性 类型 必填 默认值 说明 enable Boolean 是 true 是否开启uni统计 2.3 app-plus 属性 类型 说明 最低版本 splashscreen Object App 启动界面信息，详见 screenOrientation Array 重力感应、横竖屏配置，可取值：\"portrait-primary\"：竖屏正方向；\"portrait-secondary\"：竖屏反方向；\"landscape-primary\"：横屏正方向；\"landscape-secondary\"：横屏反方向。 modules Object 权限模块，详见 distribute Object App 发布信息，详见 nvueCompiler String 切换 nvue 编译模式，可选值，weex ：老编译模式，uni-app： 新编译模式，默认为 weex 。编译模式区别详情 2.0.3+ nvueStyleCompiler String 切换 nvue 样式编译模式，可选值，weex ：老编译模式，uni-app： 新编译模式，默认为 weex 。编译模式区别详情 3.1.1+ renderer String 可不加载基于 webview 的运行框架，减少包体积、提升启动速度。可选值 native App-nvue 2.2.0+ nvueLaunchMode String Nvue 首页启动模式，可选值：normal、fast 默认 normal（HBuilderX 2.4.4-2.4.9 固定为 fast） 详见 2.5.0+ nvue Object nvue 页面布局初始配置，详见 2.0.3+ optimization Object 分包配置，可以减轻启动时加载的js数量，提升启动速度 2.7.12+ runmode String normal：默认模式，liberate：资源释放模式 uniStatistics Object App 是否开启 uni 统计，配置方法同全局配置 2.2.3+ webView Object 当系统webview低于指定版本时，会弹出提示。或者下载x5内核后继续启动，仅Android支持，详情 3.5.0+ PS：上表只列出了核心部分，App平台的配置其实非常多，完整内容请参考 完整的 manifest.json。 manifest.json 文件的配置，推荐在 HBuilderX 提供的可视化操作界面完成。 部分配置在打包时的操作界面补全，例如：证书等信息。 Native.js 权限部分会根据配置的模块权限，在打包后自动填充。 部分 modules 是默认的，不需要进行配置。 微信小程序的 appid 等信息，需要配置在 mp-weixin 节点下。不要配置在 app-plus下。sdkConfigs 下出现的 weixin 节点，配置的是 App 的第三方 SDK 信息。 2.3.1 App Splashscreen splash（启动封面）是App必然存在的、不可取消的。 属性 类型 默认值 描述 最低版本 alwaysShowBeforeRender Boolean true 是否等待首页渲染完毕后再关闭启动界面 1.6.0 autoclose Boolean true 是否自动关闭启动界面，仅当alwaysShowBeforeRender设置为false时生效，如果需要手动关闭启动界面，需将 alwaysShowBeforeRender 及 autoclose 均设置为 false。 waiting Boolean true 是否在程序启动界面显示等待圈或雪花 alwaysShowBeforeRender和autoclose属性组合设置，可配置以下三种关闭启动界面（splash）策略，详见 如果不配置自己的splash图，App端会默认把App的icon放到splash中 splash只能是标准png，不要用jpg改名为png。也不支持gif等动画 相关改动，云打包生效，真机运行不生效。本地打包需自行在原生工程中配置 App启动图中iOS的MAX等大屏设备的splash图若不配，会导致iOS认为此App没有为MAX优化，App将无法全屏，四周会有黑边 Android的splash支持.9.png，详见 2.3.2 App Modules 模块选择是为了控制App的包体积，不需要的模块可以在打包时剔除。 名称 描述 Bluetooth BLE蓝牙 Contacts 系统通讯录 Fingerprint 指纹识别 iBeacon iBeacon LivePusher 直播推流 Maps 地图 Messaging 短彩邮件消息 OAuth 登录授权 Payment 支付 Push 消息推送 Share 社交分享 Speech 语音识别 SQLite SQLite数据库 Statistic 统计 VideoPlayer 视频播放 2.3.3 App Distribute 属性 类型 描述 android Object Android 应用配置，详见: Android配置明细 ios Object iOS 应用配置，详见: iOS配置明细 sdkConfigs Object SDK配置，仅打包生效 详见 orientation Array 同 screenOrientation 配置，仅打包生效，已废弃，推荐使用 screenOrientation 2.3.4 App SdkConfigs 属性 类型 描述 oauth Object 授权登录，配置后可调用 uni.login 进行登录操作，目前支持的授权登录平台有：QQ、微信、新浪微博。 share Object 分享，配置后可调用 uni.share 进行分享，目前支持QQ、微信、新浪微博等分享， 具体配置 详见。 push Object push配置，使用方式 详见，目前支持：uniPush、个推，注意App仅支持一种 push 方式，配置多个 push 无效，建议使用 uniPush，支持多厂商推送。 payment Object 三方支付配置，配置后可调用 uni.payment 进行支付，目前支持微信支付、支付宝支付、苹果内购， 具体配置 详见。 statics Object 统计配置，目前仅支付友盟统计，详见，在uni-app中只用 plus.statistic 进行调用。 speech Object 语音识别配置，支持讯飞语音、百度语音，详见，在uni-app中只用 plus.speech 进行调用。 maps Object 原生地图配置，目前仅支持 高德地图，申请方式可参考：地图插件配置。 2.3.4 optimization 可以减轻启动时加载的js数量，提升启动速度。 从uni-app 2.7.12+ 开始，App-vue平台也兼容了小程序的分包配置，但默认并不开启。 在manifest配置以下节点，可以在App端启动分包。 属性 类型 说明 subPackages Boolean 是否开启分包优化 \"app-plus\": { \"optimization\": { \"subPackages\": true }, \"runmode\" : \"liberate\" // 开启分包优化后，必须配置资源释放模式 } 在manifest中启动分包后，需要在pages.json中配置具体的分包规则，与小程序的配置相同，详见：https://uniapp.dcloud.io/collocation/pages?id=subpackages 也就是一旦在pages.json里配置分包，小程序一定生效，而app是否生效，取决于manifest里是否开启。 注意: App开启分包后，每个分包单独编译成一个js文件(都包含在app内，不会联网下载)，当App首页是vue时，可减小启动加载文件大小，提升启动速度。 首页是nvue时，分包不会提升启动速度，nvue本身启动速度就快于vue，也快于开启分包后的首页为vue的应用。如果追求极致启动速度，还是应该使用nvue做首页并在manifest开启fast模式。 App页面较少时，分包对启动速度的优化不明显。 2.3.5 nvue nvue 页面布局初始设置 属性 类型 描述 flex-direction String flex 成员项的排列方向，支持项，row：从左到右； row-reverse：从右到左；column：从上到下；column-reverse：与 column 相反，默认值 column。 2.3.6 webview 当App代码使用了低版本webview不支持的语法时（比如使用了vue3），可以在manifest配置本属性，来指定最低运行的webview版本。 当系统webview版本不符合需求时，uni-app引擎会自动弹框。同时开发者可以指定使用 x5引擎webview 来替代系统webview，以保障浏览器兼容性。详见x5文档 当你的应用强依赖x5时，比如需要vue页面的字体和tabbar等原生界面保持一致时，也可以在manifest配置本属性。 属性 类型 说明 minUserAgentVersion String 最小webview版本，例如：64.0.3282.116。（当低于最小版本要求时，显示 WebView版本过低 弹框，点击确定退出应用。） x5 Object 此属性需要在manifest模块配置中勾选 Android X5 Webview 模块，详细参见下面的说明 x5 属性说明 属性 类型 默认值 说明 timeOut Number 3000 超时时间 showTipsWithoutWifi Boolean false 是否在非WiFi网络环境时，显示用户确认下载x5内核的弹窗。（如果为true时，在非WiFi网络下载x5模块，会显示用户确认弹框，内容为 当前处于非WiFi网络，是否允许下载x5模块？ ，false时不显示弹框 。） allowDownloadWithoutWiFi Boolean false 是否允许用户在非WiFi网络时进行x5内核的下载。（如果为true，就不会显示用户确认的弹窗。false时，如果showTipsWithoutWifi为true，就会显示用户确认弹框；showTipsWithoutWifi为false时，不下载x5模块。） { \"app-plus\" : { \"webView\": { \"minUserAgentVersion\": \"64.0.3282.116\", \"x5\": { \"timeOut\": 3000, \"showTipsWithoutWifi\": true, \"allowDownloadWithoutWiFi\": false } } } } 2.4 h5 用到再看。 2.5 mp-weixin 用到再看。 2.6 mp-alipay 用到再看。 2.7 mp-baidu 用到再看。 2.8 mp-toutiao 用到再看。 2.9 mp-lark 用到再看。 2.10 mp-qq 用到再看。 2.11 mp-kuaishou 用到再看。 2.12 完整 manifest.json { \"appid\": \"__UNI__XXXXXX，创建应用时云端分配的，不要修改。\", \"name\": \"应用名称，如uni-app\", \"description\": \"应用描述\", \"versionName\": \"1.0.0\", \"versionCode\": \"100\", \"uniStatistics\": { \"enable\": false }, \"app-plus\": { \"nvueCompiler\": \"weex\", //可选，字符串类型，nvue页面编译模式，可取值uni-app、weex，参考：https://ask.dcloud.net.cn/article/36074 \"nvueStyleCompiler\": \"weex\", //可选，字符串类型，nvue页面样式编译模式，可取值uni-app、weex，参考：https://ask.dcloud.net.cn/article/38751 \"renderer\": \"native\", //可选，字符串类型，可不加载基于 webview 的运行框架，可取值native \"compilerVersion\": 2, //可选，数字类型，编译器版本，可取值2、3，参考：https://ask.dcloud.net.cn/article/36599 \"nvueLaunchMode\": \"normal\", //可选，字符串类型，nvue首页启动模式，compilerVersion值为3时生效，可取值normal、fast，参考：https://ask.dcloud.net.cn/article/36749 \"nvue\": { //可选，JSON对象，nvue页面相关配置 \"flex-direction\": \"row\" //可选，字符串类型，nvue页面的flex-direction默认值，可取值row、row-reverse、column、column-reverse }, \"optimization\": { //可选，JSON对象，分包配置 \"subPackages\": true //可选，Boolean类型，是否开启分包优化，参考：https://uniapp.dcloud.io/collocation/pages.html#subpackages }, \"uniStatistics\": { //可选，JSON对象，uni统计配置 \"enable\": true, //可选，Boolean类型，是否开启uni统计 }, \"screenOrientation\": [ //可选，字符串数组类型，应用支持的横竖屏 \"portrait-primary\", //可选，字符串类型，支持竖屏 \"portrait-secondary\", //可选，字符串类型，支持反向竖屏 \"landscape-primary\", //可选，字符串类型，支持横屏 \"landscape-secondary\" //可选，字符串类型，支持反向横屏 ], \"splashscreen\": { //可选，JSON对象，splash界面配置 \"alwaysShowBeforeRender\": true, //可选，Boolean类型，是否等待首页渲染完毕后再关闭启动界面 \"autoclose\": true, //可选，Boolean类型，是否自动关闭启动界面 \"waiting\": true, //可选，Boolean类型，是否在程序启动界面显示等待雪花 \"event\": \"loaded\", //可选，字符串类型，可取值titleUpdate、rendering、loaded，uni-app项目已废弃 \"target\": \"defalt\", //可选，字符串类型，可取值default、second，uni-app项目已废弃 \"dealy\": 0, //可选，数字类型，延迟自动关闭启动时间，单位为毫秒，uni-app项目已废弃 \"ads\": { //可选，JSON对象，开屏广告配置 \"backaground\": \"#RRGGBB\", //可选，字符串类型，格式为#RRGGBB，开屏广告背景颜色 \"image\": \"\" //可选，字符串类型，底部图片地址，相对应用资源目录路径 }, \"androidTranslucent\": false //可选，Boolean类型，使用“自定义启动图”启动界面时是否显示透明过渡界面，可解决点击桌面图标延时启动应用的效果 }, \"modules\": { //可选，JSON对象，使用的模块 \"Bluetooth\": { //可选，JSON对象，Bluetooth(低功耗蓝牙) \"description\": \"低功耗蓝牙\" }, \"Contacts\": { //可选，JSON对象，Contact(通讯录) \"description\": \"通讯录\" }, \"FaceID\": { //可选，JSON对象，FaceID(人脸识别)，仅iOS支持 \"description\": \"人脸识别\" }, \"Fingerprint\": { //可选，JSON对象，Fingerprint(指纹识别) \"description\": \"指纹识别\" }, \"Geolocation\": { //可选，JSON对象，Geolocation(定位) \"description\": \"定位\" }, \"iBeacon\": { //可选，JSON对象，iBeacon \"description\": \"iBeacon\" }, \"LivePusher\": { //可选，JSON对象，LivePusher(直播推流) \"description\": \"直播推流\" }, \"Maps\": { //可选，JSON对象，Maps(地图) \"description\": \"地图\" }, \"Messaging\": { //可选，JSON对象，Messaging(短彩邮件消息) \"description\": \"短彩邮件消息\" }, \"OAuth\": { //可选，JSON对象，OAuth(登录鉴权) \"description\": \"登录鉴权\" }, \"Payment\": { //可选，JSON对象，Payment(支付) \"description\": \"iBeacon\" }, \"Push\": { //可选，JSON对象，Push(消息推送) \"description\": \"iBeacon\" }, \"Share\": { //可选，JSON对象，Share(分享) \"description\": \"iBeacon\" }, \"Speech\": { //可选，JSON对象，Speech(语音输入) \"description\": \"iBeacon\" }, \"Statistic\": { //可选，JSON对象，Statistic(统计) \"description\": \"iBeacon\" }, \"SQLite\": { //可选，JSON对象，SQLite(统计) \"description\": \"iBeacon\" }, \"VideoPlayer\": { //可选，JSON对象，VideoPlayer(视频播放) \"description\": \"iBeacon\" }, \"Webview-x5\": { //可选，JSON对象，Android X5 Webview(腾讯TBS)，仅Android支持 \"description\": \"iBeacon\" }, \"UIWebview\": { //可选，JSON对象，UIWebview，仅iOS支持 \"description\": \"iBeacon\" } }, \"webView\": { // 3.5.0 + 当系统webview低于指定版本时，会弹出提示。或者下载x5内核后继续启动，仅Android支持 \"minUserAgentVersion\": \"95.0.4638.75\", // 最小webview版本 \"x5\": { // 此属性需要勾选 Android X5 Webview 模块，详细参见下面的说明 \"timeOut\": 3000, // 超时时间 \"showTipsWithoutWifi\": true, // 是否在非WiFi网络环境时，显示用户确认下载x5内核的弹窗。 \"allowDownloadWithoutWiFi\": false // 是否允许用户在非WiFi网络时进行x5内核的下载。（如果为true，就不会显示用户确认的弹窗。） } }, \"checkPermissionDenied\": false, // 是否校验已拒绝权限 如果拒绝则不会再申请 默认false 不校验已拒绝权限 \"distribute\": { //必选，JSON对象，云端打包配置 \"android\": { //可选，JSON对象，Android平台云端打包配置 \"packagename\": \"\", //必填，字符串类型，Android包名 \"keystore\": \"\", //必填，字符串类型，Android签名证书文件路径 \"password\": \"\", //必填，字符串类型，Android签名证书文件的密码 \"aliasname\": \"\", //必填，字符串类型，Android签名证书别名 \"schemes\": \"\", //可选，字符串类型，参考：https://uniapp.dcloud.io/tutorial/app-android-schemes \"abiFilters\": [ //可选，字符串数组类型，参考：https://uniapp.dcloud.io/tutorial/app-android-abifilters \"armeabi-v7a\", \"arm64-v8a\", \"x86\", \"x86_64\" ], \"permissions\": [ //可选，字符串数组类型，Android权限配置 \"\" ], \"custompermissions\": false, //可选，Boolean类型，是否自定义Android权限配置 \"permissionExternalStorage\": { //可选，JSON对象，Android平台应用启动时申请读写手机存储权限策略 \"request\": \"always\", //必填，字符串类型，申请读写手机存储权限策略，可取值none、once、always \"prompt\": \"\" //可选，字符串类型，当request设置为always值用户拒绝时弹出提示框上的内容 }, \"permissionPhoneState\": { //可选，JSON对象，Android平台应用启动时申请读取设备信息权限配置 \"request\": \"always\", //必填，字符串类型，申请读取设备信息权限策略，可取值none、once、always \"prompt\": \"\" //可选，字符串类型，当request设置为always值用户拒绝时弹出提示框上的内容 }, \"minSdkVersion\": 21, //可选，数字类型，Android平台最低支持版本，参考：https://uniapp.dcloud.io/tutorial/app-android-minsdkversion \"targetSdkVersion\": 30, //可选，数字类型，Android平台目标版本，参考：https://uniapp.dcloud.io/tutorial/app-android-targetsdkversion \"packagingOptions\": [ //可选，字符串数组类型，Android平台云端打包时build.gradle的packagingOptions配置项 \"doNotStrip '*/armeabi-v7a/*.so'\", \"merge '**/LICENSE.txt'\" ], \"jsEngine\": \"v8\", //可选，字符串类型，uni-app使用的JS引擎，可取值v8、jsc \"debuggable\": false, //可选，Boolean类型，是否开启Android调试开关 \"locale\": \"default\", //可选，应用的语言 \"forceDarkAllowed\": false, //可选，Boolean类型，是否强制允许暗黑模式 \"resizeableActivity\": false, //可选，Boolean类型，是否支持分屏调整窗口大小 \"hasTaskAffinity\": false, //可选，Boolean类型，是否设置android：taskAffinity \"buildFeatures\": { //（HBuilderX3.5.0+版本支持）可选，JSON对象，Android平台云端打包时build.gradle的buildFeatures配置项 \"dataBinding\": false, //可选，Boolean类型，是否设置dataBinding \"viewBinding\": false //可选，Boolean类型，是否设置viewBinding } }, \"ios\": { //可选，JSON对象，iOS平台云端打包配置 \"appid\": \"\", //必填，字符串类型，iOS平台Bundle ID \"mobileprovision\": \"\", //必填，字符串类型，iOS打包使用的profile文件路径 \"p12\": \"\", //必填，字符串类型，iOS打包使用的证书文件路径 \"password\": \"\", //必填，字符串类型，iOS打包使用的证书密码 \"devices\": \"iphone\", //必填，字符串类型，iOS支持的设备类型，可取值iphone、ipad、universal \"urlschemewhitelist\": \"baidumap\",//可选，字符串类型，应用访问白名单列表，参考：https://uniapp.dcloud.io/tutorial/app-ios-schemewhitelist \"urltypes\": \"\", //可选，字符串类型，参考：https://uniapp.dcloud.io/tutorial/app-ios-schemes \"UIBackgroundModes\": \"audio\", //可选，字符串类型，应用后台运行模式，参考：https://uniapp.dcloud.io/tutorial/app-ios-uibackgroundmodes \"frameworks\": [ //可选，字符串数组类型，依赖的系统库，已废弃，推荐使用uni原生插件扩展使用系统依赖库 \"CoreLocation.framework\" ], \"deploymentTarget\": \"10.0\", //可选，字符串类型，iOS支持的最低版本 \"privacyDescription\": { //可选，JSON对象，iOS隐私信息访问的许可描述 \"NSPhotoLibraryUsageDescription\": \"\", //可选，字符串类型，系统相册读取权限描述 \"NSPhotoLibraryAddUsageDescription\": \"\", //可选，字符串类型，系统相册写入权限描述 \"NSCameraUsageDescription\": \"\", //可选，字符串类型，摄像头使用权限描述 \"NSMicrophoneUsageDescription\": \"\", //可选，字符串类型，麦克风使用权限描述 \"NSLocationWhenInUseUsageDescription\": \"\", //可选，字符串类型，运行期访问位置权限描述 \"NSLocationAlwaysUsageDescription\": \"\", //可选，字符串类型，后台运行访问位置权限描述 \"NSLocationAlwaysAndWhenInUseUsageDescription\": \"\", //可选，字符串类型，运行期后后台访问位置权限描述 \"NSCalendarsUsageDescription\": \"\", //可选，字符串类型，使用日历权限描述 \"NSContactsUsageDescription\": \"\", //可选，字符串类型，使用通讯录权限描述 \"NSBluetoothPeripheralUsageDescription\": \"\", //可选，字符串类型，使用蓝牙权限描述 \"NSBluetoothAlwaysUsageDescription\": \"\", //可选，字符串类型，后台使用蓝牙权限描述 \"NSSpeechRecognitionUsageDescription\": \"\", //可选，字符串类型，系统语音识别权限描述 \"NSRemindersUsageDescription\": \"\", //可选，字符串类型，系统提醒事项权限描述 \"NSMotionUsageDescription\": \"\", //可选，字符串类型，使用运动与健康权限描述 \"NSHealthUpdateUsageDescription\": \"\", //可选，字符串类型，使用健康更新权限描述 \"NSHealthShareUsageDescription\": \"\", //可选，字符串类型，使用健康分享权限描述 \"NSAppleMusicUsageDescription\": \"\", //可选，字符串类型，使用媒体资料库权限描述 \"NFCReaderUsageDescription\": \"\", //可选，字符串类型，使用NFC权限描述 \"NSHealthClinicalHealthRecordsShareUsageDescription\": \"\", //可选，字符串类型，访问临床记录权限描述 \"NSHomeKitUsageDescription\": \"\", //可选，字符串类型，访问HomeKit权限描述 \"NSSiriUsageDescription\": \"\", //可选，字符串类型，访问Siri权限描述 \"NSFaceIDUsageDescription\": \"\", //可选，字符串类型，使用FaceID权限描述 \"NSLocalNetworkUsageDescription\": \"\", //可选，字符串类型，访问本地网络权限描述 \"NSUserTrackingUsageDescription\": \"\" //可选，字符串类型，跟踪用户活动权限描述 }, \"idfa\": true, //可选，Boolean类型，是否使用广告标识 \"capabilities\": { //可选，JSON对象，应用的能力配置（Capabilities） }, \"CFBundleName\": \"HBuilder\", //可选，字符串类型，CFBundleName名称 \"validArchitectures\": [ //可选，字符串数组类型，编译时支持的CPU指令，可取值arm64、arm64e、armv7、armv7s、x86_64 \"arm64\" ], \"pushRegisterMode\": \"manual\" //可选，使用“Push(消息推送)”模块时申请系统推送权限模式，manual表示调用push相关API时申请，其它值表示应用启动时自动申请 }, \"sdkConfigs\": { //可选，JSON对象，三方SDK相关配置 \"geolocation\": { //可选，JSON对象，Geolocation(定位)模块三方SDK配置 \"system\": { //可选，JSON对象，使用系统定位 \"__platform__\" : [ \"ios\", \"android\" ] //可选，字符串数组类型，支持的平台 }, \"amap\": { //可选，JSON对象，使用高德定位SDK配置 \"__platform__\" : [\"ios\", \"android\"], //可选，字符串数组类型，支持的平台 \"appkey_ios\": \"\", //必填，字符串类型，iOS平台高德定位appkey \"appkey_android\": \"\" //必填，字符串类型，Android平台高德定位appkey }, \"baidu\": { //可选，JSON对象，使用百度定位SDK配置 \"__platform__\" : [ \"ios\", \"android\" ], //可选，字符串数组类型，支持的平台 \"appkey_ios\": \"\", //必填，字符串类型，iOS平台百度定位appkey \"appkey_android\": \"\" //必填，字符串类型，Android平台百度定位appkey } }, \"maps\" : { //可选，JSON对象，Maps(地图)模块三方SDK配置 \"amap\": { //可选，JSON对象，使用高德地图SDK配置 \"appkey_ios\": \"\", //必填，字符串类型，iOS平台高德地图appkey \"appkey_android\": \"\" //必填，字符串类型，Android平台高德地图appkey }, \"baidu\": { //可选，JSON对象，使用百度地图SDK配置 \"appkey_ios\": \"\", //必填，字符串类型，iOS平台百度地图appkey \"appkey_android\": \"\" //必填，字符串类型，Android平台百度地图appkey }, \"google\": { //可选，JSON对象，使用Google地图SDK配置 \"APIKey_ios\": \"\", //必填，字符串类型，iOS平台Google地图APIKey \"APIKey_android\": \"\" //必填，字符串类型，Android平台Google地图APIKey } }, \"oauth\": { //可选，JSON对象，OAuth(登录鉴权)模块三方SDK配置 \"univerify\" : { //可选，JSON对象，使用一键登录(univerify)SDK配置，无需手动配置参数，云端打包自动获取配置参数 }, \"apple\": { //可选，JSON对象，使用苹果登录(Sign in with Apple)SDK配置，无配置参数，仅iOS平台支持 }, \"weixin\": { //可选，JSON对象，使用微信登录SDK配置 \"appid\": \"\", //必填，字符串类型，微信开放平台申请的appid \"appsecret\": \"\", //必填，字符串类型，微信开放平台申请的appsecret \"UniversalLinks\": \"\" //可选，字符串类型，微信开放平台配置的iOS平台通用链接 }, \"qq\": { //可选，JSON对象，使用QQ登录SDK配置 \"appid\": \"\", //必填，字符串类型，QQ开放平台申请的appid \"UniversalLinks\": \"\" //可选，字符串类型，QQ开放平台配置的iOS平台通用链接 }, \"sina\": { //可选，JSON对象，使用新浪微博登录SDK配置 \"appkey\": \"\", //必填，字符串类型，新浪微博开放平台申请的appid \"redirect_uri\": \"\", //必填，字符串类型，新浪微博开放平台配置的redirect_uri \"UniversalLinks\": \"\" //可选，字符串类型，新浪微博开放平台配置的iOS平台通用链接 }, \"google\": { //可选，JSON对象，使用Google登录SDK配置 \"clientid\": \"\" //必填，字符串类型，Google开发者后台申请的clientid }, \"facebook\": { //可选，JSON对象，使用Facebook登录SDK配置 \"appid\": \"\" //必填，字符串类型，Facebook开发者后台申请的appid } }, \"payment\": { //可选，JSON对象，Payment(支付)模块三方SDK配置 \"appleiap\": { //可选，JSON对象，使用Apple应用内支付配置，无配置参数，仅iOS平台支持 }, \"alipay\": { //可选，JSON对象，使用支付宝支付SDK配置 \"__platform__\": [ \"ios\", \"android\" ] //可选，字符串数组类型，支持的平台 }, \"weixin\": { //可选，JSON对象，使用微信支付SDK配置 \"__platform__\": [ \"ios\", \"android\" ], //可选，字符串数组类型，支持的平台 \"appid\": \"\", //必填，字符串类型，微信开放平台申请的appid \"UniversalLinks\": \"\" //可选，字符串类型，微信开放平台配置的iOS平台通用链接 }, \"paypal\": { //可选，JSON对象，使用paypal支付SDK配置 \"__platform__\": [ \"ios\", \"android\" ], //可选，字符串数组类型，支持的平台 \"returnURL_ios\": \"\", //必填，字符串类型，paypa开发者者后台配置的iOS平台returnURL \"returnURL_android\": \"\" //必填，字符串类型，paypa开发者者后台配置的Android平台returnURL }, \"stripe\": { //可选，JSON对象，使用stripe支付SDK配置 \"__platform__\": [ \"ios\", \"android\" ], //可选，字符串数组类型，支持的平台 \"returnURL_ios\" : \"\" //必填，字符串类型，stripe开发者者后台配置的iOS平台returnURL }, \"google\": { //可选，JSON对象，使用google支付SDK配置，无配置参数，仅Android平台支持 } }, \"push\": { //可选，JSON对象，Push(消息推送)模块三方SDK配置 \"unipush\": { //可选，JSON对象，使用UniPush SDK配置，无需手动配置参数，云端打包自动获取配置参数 \"icons\": { //可选，JSON对象，推送图标配置 \"push\": { //可选，JSON对象，Push图标配置 \"ldpi\": \"\", //可选，字符串类型，普通屏设备推送图标路径，分辨率要求48x48 \"mdpi\": \"\", //可选，字符串类型，大屏设备设备推送图标路径，分辨率要求48x48 \"hdpi\": \"\", //可选，字符串类型，高分屏设备推送图标路径，分辨率要求72x72 \"xdpi\": \"\", //可选，字符串类型，720P高分屏设备推送图标路径，分辨率要求96x96 \"xxdpi\": \"\", //可选，字符串类型，1080P高密度屏幕推送图标路径，分辨率要求144x144 \"xxxdpi\": \"\", //可选，字符串类型，4K屏设备推送图标路径，分辨率要求192x192 }, \"smal\": { //可选，JSON对象，Push小图标配置 \"ldpi\": \"\", //可选，字符串类型，普通屏设备推送小图标路径，分辨率要求18x18 \"mdpi\": \"\", //可选，字符串类型，大屏设备设备推送小图标路径，分辨率要求24x24 \"hdpi\": \"\", //可选，字符串类型，高分屏设备推送小图标路径，分辨率要求36x36 \"xdpi\": \"\", //可选，字符串类型，720P高分屏设备推送小图标路径，分辨率要求48x48 \"xxdpi\": \"\", //可选，字符串类型，1080P高密度屏幕推送小图标路径，分辨率要求72x72 \"xxxdpi\": \"\", //可选，字符串类型，4K屏设备推送小图标路径，分辨率要求96x96 } } }, \"igexin\": { //可选，JSON对象，使用个推推送SDK配置，**已废弃，推荐使用UniPush，UniPush是个推推送VIP版，功能更强大** \"appid\": \"\", //必填，字符串类型，个推开放平台申请的appid \"appkey\": \"\", //必填，字符串类型，个推开放平台申请的appkey \"appsecret\": \"\", //必填，字符串类型，个推开放平台申请的appsecret \"icons\": { //可选，JSON对象，推送图标配置 \"push\": { //可选，JSON对象，Push图标配置 \"ldpi\": \"\", //可选，字符串类型，普通屏设备推送图标路径，分辨率要求48x48 \"mdpi\": \"\", //可选，字符串类型，大屏设备设备推送图标路径，分辨率要求48x48 \"hdpi\": \"\", //可选，字符串类型，高分屏设备推送图标路径，分辨率要求72x72 \"xdpi\": \"\", //可选，字符串类型，720P高分屏设备推送图标路径，分辨率要求96x96 \"xxdpi\": \"\", //可选，字符串类型，1080P高密度屏幕推送图标路径，分辨率要求144x144 \"xxxdpi\": \"\", //可选，字符串类型，4K屏设备推送图标路径，分辨率要求192x192 }, \"smal\": { //可选，JSON对象，Push小图标配置 \"ldpi\": \"\", //可选，字符串类型，普通屏设备推送小图标路径，分辨率要求18x18 \"mdpi\": \"\", //可选，字符串类型，大屏设备设备推送小图标路径，分辨率要求24x24 \"hdpi\": \"\", //可选，字符串类型，高分屏设备推送小图标路径，分辨率要求36x36 \"xdpi\": \"\", //可选，字符串类型，720P高分屏设备推送小图标路径，分辨率要求48x48 \"xxdpi\": \"\", //可选，字符串类型，1080P高密度屏幕推送小图标路径，分辨率要求72x72 \"xxxdpi\": \"\", //可选，字符串类型，4K屏设备推送小图标路径，分辨率要求96x96 } } } }, \"share\": { //可选，JSON对象，Share(分享)模块三方SDK配置 \"weixin\": { //可选，JSON对象，使用微信分享SDK配置 \"appid\": \"\", //必填，字符串类型，微信开放平台申请的appid \"UniversalLinks\": \"\" //可选，字符串类型，微信开放平台配置的iOS平台通用链接 }, \"qq\": { //可选，JSON对象，使用QQ分享SDK配置 \"appid\": \"\", //必填，字符串类型，QQ开放平台申请的appid \"UniversalLinks\": \"\" //可选，字符串类型，QQ开放平台配置的iOS平台通用链接 }, \"sina\": { //可选，JSON对象，使用新浪微博分享SDK配置 \"appkey\": \"\", //必填，字符串类型，新浪微博开放平台申请的appid \"redirect_uri\": \"\", //必填，字符串类型，新浪微博开放平台配置的redirect_uri \"UniversalLinks\": \"\" //可选，字符串类型，新浪微博开放平台配置的iOS平台通用链接 } }, \"speech\": { //可选，JSON对象，Speech(语音识别)模块三方SDK配置 \"baidu\": { //可选，JSON对象，使用百度语音识别SDK配置 \"appid\": \"\", //必填，字符串类型，百度开放平台申请的appid \"apikey\": \"\", //必填，字符串类型，百度开放平台申请的apikey \"secretkey\": \"\" //必填，字符串类型，百度开放平台申请的secretkey } }, \"statics\": { //可选，JSON对象，Statistic(统计)模块三方SDK配置 \"umeng\": { //可选，JSON对象，使用友盟统计SDK配置 \"appkey_ios\": \"\", //必填，字符串类型，友盟统计开放平台申请的iOS平台appkey \"channelid_ios\": \"\", //可选，字符串类型，友盟统计iOS平台的渠道标识 \"appkey_android\": \"\", //必填，字符串类型，友盟统计开放平台申请的Android平台appkey \"channelid_android\": \"\" //可选，字符串类型，友盟统计Android平台的渠道标识 }, \"google\" : { //可选，JSON对象，使用Google Analytics for Firebase配置 \"config_ios\" : \"\", //必填，字符串类型，Google Firebase统计开发者后台获取的iOS平台配置文件路径 \"config_android\" : \"\" //必填，字符串类型，Google Firebase统计开发者后台获取的Android平台配置文件路径 } }, \"ad\": { //可选，JSON对象，uni-AD配置 \"360\": { //可选，JSON对象，使用360广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"csj\": { //可选，JSON对象，使用今日头条穿山甲广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"gdt\": { //可选，JSON对象，使用腾讯优量汇广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"ks\": { //可选，JSON对象，使用快手广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"ks-content\": { //可选，JSON对象，使用快手内容联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"sigmob\": { //可选，JSON对象，使用Sigmob广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"hw\": { //可选，JSON对象，使用华为广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"bd\": { //可选，JSON对象，使用百度百青藤广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 }, \"BXM-AD\": { //可选，JSON对象，使用互动游戏(变现猫)SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数 } } }, \"icons\": { //可选，JSON对象，应用图标相关配置 \"ios\":{ //可选，JSON对象，iOS平台图标配置 \"appstore\": \"\", //必填，字符串类型，分辨率1024x1024, 提交app sotre使用的图标路径 \"iphone\":{ //可选，JSON对象，iPhone设备图标配置 \"app@2x\": \"\", //可选，字符串类型，分辨率120x120，程序图标路径 \"app@3x\": \"\", //可选，字符串类型，分辨率180x180，程序图标路径 \"spotlight@2x\": \"\", //可选，字符串类型，分辨率80x80，Spotlight搜索图标路径 \"spotlight@3x\": \"\", //可选，字符串类型，分辨率120x120，Spotlight搜索图标路径 \"settings@2x\": \"\", //可选，字符串类型，分辨率58x58，Settings设置图标路径 \"settings@3x\": \"\", //可选，字符串类型，分辨率87x87，Settings设置图标路径 \"notification@2x\": \"\", //可选，字符串类型，分辨率40x40，通知栏图标路径 \"notification@3x\": \"\" //可选，字符串类型，分辨率60x60，通知栏图标路径 }, \"ipad\":{ //可选，JSON对象，iPad设备图标配置 \"app\": \"\", //可选，字符串类型，分辨率76x76，程序图标图标路径 \"app@2x\": \"\", //可选，字符串类型，分辨率152x152，程序图标图标路径 \"proapp@2x\": \"\", //可选，字符串类型，分辨率167x167，程序图标图标路径 \"spotlight\": \"\", //可选，字符串类型，分辨率40x40，Spotlight搜索图标路径 \"spotlight@2x\": \"\", //可选，字符串类型，分辨率80x80，Spotlight搜索图标路径 \"settings\": \"\", //可选，字符串类型，分辨率29x29，Settings设置图标路径 \"settings@2x\": \"\", //可选，字符串类型，分辨率58x58，Settings设置图标路径 \"notification\": \"\", //可选，字符串类型，分辨率20x20，通知栏图标路径 \"notification@2x\": \"\" //可选，字符串类型，分辨率740x40，通知栏图标路径 } }, \"android\":{ //可选，JSON对象，Android平台图标配置 \"ldpi\": \"\", //可选，字符串类型，普通屏设备程序图标，分辨率要求48x48，已废弃 \"mdpi\": \"\", //可选，字符串类型，大屏设备程序图标，分辨率要求48x48，已废弃 \"hdpi\": \"\", //可选，字符串类型，高分屏设备程序图标，分辨率要求72x72 \"xhdpi\": \"\", //可选，字符串类型，720P高分屏设备程序图标，分辨率要求96x96 \"xxhdpi\": \"\", //可选，字符串类型，1080P高分屏设备程序图标，分辨率要求144x144 \"xxxhdpi\": \"\" //可选，字符串类型，2K屏设备程序图标，分辨率要求192x192 } }, \"splashscreen\":{ //可选，JSON对象，启动界面配置 \"iosStyle\": \"common\", //可选，字符串类型，iOS平台启动界面样式，可取值common、default、storyboard \"ios\":{ //可选，JSON对象，iOS平台启动界面配置 \"storyboard\": \"\", //可选，字符串类型，自定义storyboard启动界面文件路径，iosStyle值为storyboard时生效 \"iphone\":{ //可选，JSON对象，iPhone设备启动图配置，iosStyle值为default时生效 \"default\": \"\", //可选，字符串类型，分辨率320x480，iPhone3（G/GS）启动图片路径，已废弃 \"retina35\": \"\", //可选，字符串类型，分辨率640x960，3.5英寸设备(iPhone4/4S)启动图片路径，已废弃 \"retina40\": \"\", //可选，字符串类型，分辨率640x1136，4.0英寸设备(iPhone5/5S)启动图片路径 \"retina40l\":\"\", //可选，字符串类型，分辨率1136x640，4.0英寸设备(iPhone5/5S)横屏启动图片路径 \"retina47\": \"\", //可选，字符串类型，分辨率750x1334，4.7英寸设备（iPhone6/7/8）启动图片路径 \"retina47l\": \"\", //可选，字符串类型，分辨率1334x750，4.7英寸设备（iPhone6/7/8）横屏启动图片路径 \"retina55\": \"\", //可选，字符串类型，分辨率1242x2208，5.5英寸设备（iPhone6/7/8Plus）启动图片路径 \"retina55l\": \"\", //可选，字符串类型，分辨率2208x1242，5.5英寸设备（iPhone6/7/8Plus）横屏启动图片路径 \"iphonex\": \"\", //可选，字符串类型，分辨率1125x2436，5.8英寸设备（iPhoneX/XS）启动图片路径 \"iphonexl\": \"\", //可选，字符串类型，分辨率2436x1125，5.8英寸设备（iPhoneX/XS）横屏启动图片路径 \"portrait-896h@2x\": \"\", //可选，字符串类型，分辨率828x1792，6.1英寸设备（iPhoneXR）启动图片路径 \"landscape-896h@2x\": \"\", //可选，字符串类型，分辨率1792x828，6.1英寸设备（iPhoneXR）iPhoneXR横屏启动图片路径 \"portrait-896h@3x\": \"\", //可选，字符串类型，分辨率1242x2688，6.5英寸设备（iPhoneXS Max）启动图片路径 \"landscape-896h@3x\": \"\" //可选，字符串类型，分辨率2688x1242，6.5英寸设备（iPhoneXS Max）横屏启动图片路径 }, \"ipad\":{ //可选，JSON对象，iPad设备启动图配置，iosStyle值为default时生效 \"portrait\": \"\", //可选，字符串类型，分辨率768x1004，iPad竖屏启动图片路径，已废弃 \"portrait-retina\": \"\", //可选，字符串类型，分辨率1536x2008，iPad高分屏竖屏启动图片路径，已废弃 \"landscape\": \"\", //可选，字符串类型，分辨率1024x748，iPad横屏启动图片路径，已废弃 \"landscape-retina\": \"\", //可选，字符串类型，分辨率2048x1496，iPad高分屏横屏启动图片路径，已废弃 \"portrait7\": \"\", //可选，字符串类型，分辨率768x1024，9.7/7.9英寸iPad/mini竖屏启动图片路径 \"landscape7\": \"\", //可选，字符串类型，分辨率1024x768，9.7/7.9英寸iPad/mini横屏启动图片路径 \"portrait-retina7\": \"\", //可选，字符串类型，分辨率1536x2048，9.7/7.9英寸iPad/mini高分屏竖屏图片路径 \"landscape-retina7\": \"\", //可选，字符串类型，分辨率2048x1536，9.7/7.9英寸iPad/mini高分屏横屏启动图片路径 \"portrait-1112h@2x\":\"\", //可选，字符串类型，分辨率1668x2224，10.5英寸iPad Pro竖屏启动图片路径 \"landscape-1112h@2x\":\"\", //可选，字符串类型，分辨率2224x1668，10.5英寸iPad Pro横屏启动图片路径 \"portrait-1194h@2x\":\"\", //可选，字符串类型，分辨率1668x2388，11英寸iPad Pro竖屏启动图片路径 \"landscape-1194h@2x\":\"\", //可选，字符串类型，分辨率2388x1668，11英寸iPad Pro横屏启动图片路径 \"portrait-1366h@2x\":\"\", //可选，字符串类型，分辨率2048x2732，12.9英寸iPad Pro竖屏启动图片路径 \"landscape-1366h@2x\":\"\" //可选，字符串类型，分辨率2732x2048，12.9英寸iPad Pro横屏启动图片路径 } }, \"androidStyle\": \"common\",//可选，字符串类型，Android平台启动界面样式，可取值common、default \"android\":{ //可选，JSON对象，Android平台启动图片配置， androidStyle值为default时生效 \"ldpi\": \"\", //可选，字符串类型，分辨率320x442，低密度屏幕启动图片路径，已废弃 \"mdpi\": \"\", //可选，字符串类型，分辨率240x282，中密度屏幕启动图片路径，已废弃 \"hdpi\": \"\", //可选，字符串类型，分辨率480x762，高密度屏幕启动图片路径 \"xhdpi\": \"\", //可选，字符串类型，分辨率720x1242，720P高密度屏幕启动图片路径 \"xxhdpi\": \"\" //可选，字符串类型，分辨率1080x1882，1080P高密度屏幕启动图片路径 } }, \"orientation\": [ //可选，字符串数组类型，应用支持的横竖屏，**已废弃，使用screenOrientation配置** \"portrait-primary\", \"portrait-secondary\", \"landscape-primary\", \"landscape-secondary\" ] }, \"compatible\": { //可选，JSON对象，uni-app兼容模式 \"ignoreVersion\": false, //可选，Boolean类型，是否忽略版本兼容检查提示 \"runtimeVersion\": \"\", //可选，字符串类型，兼容的uni-app运行环境版本号，多个版本使用,分割 \"compilerVersion\": \"\" //可选，字符串类型，兼容的编译器版本号 }, \"confusion\": { //可选，JSON对象，原生混淆加密配置，参考：https://uniapp.dcloud.io/tutorial/app-sec-confusion \"description\": \"\", //可选，字符串类型，原生混淆描述 \"resources\": { //必填，JSON对象，原生混淆文件配置 \"js/common.js\": { //可选，JSON对象，键名为需要原生混淆的文件路径 } }, }, \"channel\": \"\", //可选，字符串类型，渠道标识 \"cers\": { //可选，JSON对象，应用的异常崩溃与错误报告系统配置 \"crash\": true, //可选，Boolean类型，是否提交应用异常崩溃信息 }, \"cache\": { //可选，JSON对象，Webview窗口默认使用的缓存模式，uni-app项目已废弃 \"mode\": \"default\" //可选，字符串类型，可取值default、cacheElseNetwork、noCache、cacheOnly }, \"error\": { //可选，JSON对象，页面加载错误配置，uni-app项目仅对webview组件有效，参考：https://uniapp.dcloud.io/tutorial/app-webview-error \"url\": \"\" //必填，字符串类型，webview页面错误是跳转的页面地址 }, \"kernel\": { //可选，JSON对象，webview内核配置 \"ios\": \"WKWebview\", //可选，iOS平台使用的webview类型，可取值WKWebview、UIWebview \"recovery\": \"reload\" //可选，iOS平台使用WKWebview时，内核崩溃后的处理逻辑，可取值restart、reload、none }, \"launchwebview\": { //可选，JSON对象，应用首页相关配置，uni-app项目不建议手动修改 \"plusrequire\": \"normal\", //可选，字符串类型，加载plus API时机，可取值ahead、normal、later、none \"injection\": false, //可选，Boolean类型，是否提前注入plus API \"overrideresource\": [ //可选，JSON对象数组，应用首页的拦截资源相关配置 { \"match\": \"\", //可选，字符串类型，匹配拦截的资源url地址的正则表达式 \"redirect\":\"\", //可选，字符串类型，拦截资源的重定向地址 \"mime\":\"\", //可选，字符串类型，拦截资源的数据类型mime \"encoding\":\"\", //可选，字符串类型，拦截资源的数据编码 \"header\": { //可选，JSON对象，拦截资源的http头数据 } } ], \"overrideurl\": { //可选，JSON对象，应用首页的拦截链接请求处理逻辑 \"mode\": \"reject\", //可选，字符串类型，拦截模式，可取值allow、reject \"match\": \"\", //可选，字符串类型，匹配拦截规则，支持正则表达式 \"exclude\": \"none\" //可选，字符串类型，排除拦截理规则，可取值none、redirect }, \"replacewebapi\": { //可选，JSON对象，是否重写Web API实现相关配置 \"geolocation\": \"none\" //可选，字符串类型，重写标准定位API，可取值none、alldevice、auto }, \"subNViews\": [ //可选，JSON对象数组，首页原生View相关配置，已废弃 { \"id\": \"\", //可选，字符串类型，原生View标识 \"styles\": { //可选，JSON对象，原生View样式 }, \"tags\": [ //可选，JSON对象数组，原生View中包含的tag标签列表 {} ] } ], \"titleNView\": { //可选，JSON对象，标题栏相关配置 \"backgroundColor\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，标题栏背景颜色 \"titleText\": \"\", //可选，字符串类型，标题栏标题文字内容 \"titleColor\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，标题栏标题文字颜色 \"titleSize\": \"17px\", //可选，字符串类型，标题字体大小，默认大小为17px \"autoBackButton\": true, //可选，Boolean类型，是否显示标题栏上返回键 \"backButton\": { //可选，JSON对象，返回键样式 \"backgournd\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，返回按钮背景颜色 \"color\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，返回图标颜色 \"colorPressed\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB，返回图标按下时的颜色 }, \"buttons\": [ //可选，JSON对象数组，标题栏按钮配置 { \"color\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，按钮上的文字颜色 \"colorPressed\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，按钮按下状态的文字颜色 \"float\": \"right\", //可选，字符串类型，按钮显示位置，可取值left、right \"fontWeight\": \"normal\", //可选，字符串类型，按钮上文字的粗细，可取值normal、bold \"fontSize\": \"22px\", //可选，字符串类型，按钮上文字的大小 \"fontSrc\": \"\", //可选，字符串类型，按钮上文字使用的字体文件路径 \"text\": \"\" //可选，字符串类型，按钮上显示的文字 } ], \"splitLine\": { //可选，JSON对象，标题栏分割线样式 \"color\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，分割线颜色 \"height\": \"1px\" //可选，字符串类型，分割线高度 } }, \"statusbar\": { //可选，JSON对象，状态栏配置 \"background\": \"#RRGGBB\" //可选，字符串类型，#RRGGBB格式，沉浸式状态栏样式下系统状态栏背景颜色 }, \"top\": \"0px\", //可选，字符串类型，Webview的顶部偏移量，支持px、%单位 \"height\": \"100%\", //可选，字符串类型，Webview窗口高度，支持px、%单位 \"bottom\": \"0px\", //可选，字符串类型，Webview的底部偏移量，仅在未同时设置top和height属性时生效 \"backButtonAutoControl\": \"none\", //可选，字符串类型，运行环境自动处理返回键的控制逻辑，可取值none、hide、close \"additionalHttpHeaders\": { //可选，JSON对象，额外添加HTTP请求头数据 } }, \"nativePlugins\": { //可选，JSON数组对象，uni原生插件配置，参考：https://nativesupport.dcloud.net.cn/NativePlugin/use/use_local_plugin \"%UniPlugin-ID%\": { //可选，JSON对象，键名为插件标识，值为插件配置参数 } }, \"popGesture\": \"none\", //可选，字符串类型，窗口侧滑返回默认效果，可取值none、close、hide \"runmode\": \"liberate\", //可选，字符串类型，应用资源运行模式，可取值normal、liberate \"safearea\": { //可选，JSON对象，安全区域配置 \"background\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，安全区域背景颜色 \"backgroundDark\": \"#RRGGBB\", //可选，字符串类型，#RRGGBB格式，暗黑模式安全区域背景颜色 \"bottom\": { //可选，JSON对象，底部安全区域配置 \"offset\": \"none\" //可选，字符串类型，安全区域偏移值，可取值auto、none }, \"left\": { //可选，JSON对象，左侧安全区域配置 \"offset\": \"none\" //可选，字符串类型，安全区域偏移值，可取值auto、none }, \"right\": { //可选，JSON对象，左侧安全区域配置 \"offset\": \"none\" //可选，字符串类型，安全区域偏移值，可取值auto、none } }, \"softinput\": { //可选，JSON对象，软键盘相关配置 \"navBar\": \"auto\", //可选，字符串类型，iOS平台软键盘上导航条的显示模式，可取值auto、none \"auxiliary\": false, //可选，Boolean类型，是否开启辅助输入功能 \"mode\": \"adjustResize\" //可选，字符串类型，弹出系统软键盘模式，可取值adjustResize、adjustPan }, \"ssl\": { //可选，JSON对象，ssl相关设置 \"untrustedca\": \"accept\" //可选，字符串类型，https请求时服务器非受信证书的处理逻辑，可取值accept、refuse、warning }, \"statusbar\": { //可选，JSON对象，应用启动后的系统状态栏相关配置 \"immersed\": \"none\", //可选，字符串类型，沉浸式状态栏样式，可取值none、suggestedDevice、supportedDevice \"style\": \"light\", //可选，字符串类型，系统状态栏样式（前景颜色），可取值dark、light \"background\": \"#RRGGBB\" //可选，字符串类型，#RRGGBB格式，系统状态栏背景颜色 }, \"useragent\": { //可选，JSON对象，应用UserAgent相关配置，默认值为系统UserAgent，并添加 uni-app Html5Plus/1.0 \"value\": \"\", //可选，字符串类型，设置的默认userAgent值 \"concatenate\": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后 }, \"useragent_android\": { //可选，JSON对象，Android平台应用UserAgent相关配置，优先级高于useragent配置 \"value\": \"\", //可选，字符串类型，设置的默认userAgent值 \"concatenate\": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后 }, \"useragent_ios\": { //可选，JSON对象，iOS平台应用UserAgent相关配置，优先级高于useragent配置 \"value\": \"\", //可选，字符串类型，设置的默认userAgent值 \"concatenate\": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后 } }, \"quickapp\": {}, \"mp-weixin\": { \"appid\": \"wx开头的微信小程序appid\", \"uniStatistics\": { \"enable\": false } }, \"mp-baidu\": { \"appid\": \"百度小程序appid\" }, \"mp-toutiao\": { \"appid\": \"字节跳动小程序appid\" }, \"mp-lark\": { \"appid\": \"飞书小程序appid\" }, \"h5\": { \"title\": \"演示\", \"template\": \"index.html\", \"router\": { \"mode\": \"history\", \"base\": \"/hello/\" }, \"async\": { \"loading\": \"AsyncLoading\", \"error\": \"AsyncError\", \"delay\": 200, \"timeout\": 3000 } } } 3. package.json 包配置 uni-app 通过在package.json文件中增加uni-app扩展节点，可实现自定义条件编译平台。 扩展新的平台后，有3点影响： 可以在代码里编写自定义的条件编译，为这个新平台编写专用代码 运行时可以执行面向新平台的编译运行 发行时可以执行面向新平台的编译发行 注意只能扩展web和小程序平台，不能扩展app打包。并且扩展小程序平台时只能基于指定的基准平台扩展子平台，不能扩展基准平台。基准平台详见下文。 package.json扩展配置用法： { /** * package.json其它原有配置 * 拷贝代码后请去掉注释！ */ \"uni-app\": {// 扩展配置 \"scripts\": { \"custom-platform\": { //自定义编译平台配置，可通过cli方式调用 \"title\":\"自定义扩展名称\", // 在HBuilderX中会显示在 运行/发行 菜单中 \"browser\":\"\", //运行到的目标浏览器，仅当UNI_PLATFORM为h5时有效 \"env\": {//环境变量 \"UNI_PLATFORM\": \"\", //基准平台 \"MY_TEST\": \"\", // ... 其他自定义环境变量 }, \"define\": { //自定义条件编译 \"CUSTOM-CONST\": true //自定义条件编译常量，建议为大写 } } } } } UNI_PLATFORM仅支持填写uni-app默认支持的基准平台，目前仅限如下枚举值：h5、mp-weixin、mp-alipay、mp-baidu、mp-toutiao、mp-qq browser 仅在UNI_PLATFORM为h5时有效,目前仅限如下枚举值：chrome、firefox、ie、edge、safari、hbuilderx package.json文件中不允许出现注释，否则扩展配置无效 vue-cli需更新到最新版，HBuilderX需升级到 2.1.6+ 版本 4. vue.config.js vue.config.js 是一个可选的配置文件，如果项目的根目录中存在这个文件，那么它会被自动加载，一般用于配置 webpack 等编译选项，具体规范参考：vue.config.js 支持情况 CLI 工程 HBuilderX 2.1.5 及以上版本 注意事项 仅vue页面生效 部分配置项会被编译配置覆盖，例如： publicPath 不支持，如果需要配置，请在 manifest.json->h5->router->base 中配置，参考文档：h5-router outputDir 不支持 assetsDir 固定 static pages 不支持 runtimeCompiler 固定 false productionSourceMap 固定 false css.extract H5 平台固定 false，其他平台固定 true parallel 固定 false 使用cli项目时，默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在transpileDependencies中列出来。详情参考 自定义静态资源目录 const path = require('path') const CopyWebpackPlugin = require('copy-webpack-plugin') //最新版本copy-webpack-plugin插件暂不兼容，推荐v5.0.0 module.exports = { configureWebpack: { plugins: [ new CopyWebpackPlugin([ { from: path.join(__dirname, 'src/images'), to: path.join(__dirname, 'dist', process.env.NODE_ENV === 'production' ? 'build' : 'dev', process.env.UNI_PLATFORM, 'images') } ]) ] } } 注入全局依赖 // 示例从插件市场下载 mp-storage const webpack = require('webpack') module.exports = { configureWebpack: { plugins: [ new webpack.ProvidePlugin({ 'localStorage': ['mp-storage', 'localStorage'], 'window.localStorage': ['mp-storage', 'localStorage'] }) ] } } 发布时删除console module.exports = { chainWebpack: (config) => { // 发行或运行时启用了压缩时会生效 config.optimization.minimizer('terser').tap((args) => { const compress = args[0].terserOptions.compress // 非 App 平台移除 console 代码(包含所有 console 方法，如 log,debug,info...) compress.drop_console = true compress.pure_funcs = [ '__f__', // App 平台 vue 移除日志代码 // 'console.debug' // 可移除指定的 console 方法 ] return args }) } } 发布时动态修改 manifest.json // 读取 manifest.json ，修改后重新写入 const fs = require('fs') const manifestPath = './src/manifest.json' let Manifest = fs.readFileSync(manifestPath, { encoding: 'utf-8' }) function replaceManifest(path, value) { const arr = path.split('.') const len = arr.length const lastItem = arr[len - 1] let i = 0 let ManifestArr = Manifest.split(/\\n/) for (let index = 0; index 5. vite.config.js 用到再看。 6. uni.scss uni.scss文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置。 uni-app 官方扩展插件（uni ui）及 插件市场 上很多三方插件均使用了这些样式变量，如果你是插件开发者，建议你使用 scss 预处理，并在插件代码中直接使用这些变量（无需 import 这个文件），方便用户通过搭积木的方式开发整体风格一致的App。 uni.scss是一个特殊文件，在代码中无需 import 这个文件即可在scss代码中使用这里的样式变量。uni-app的编译器在webpack配置中特殊处理了这个uni.scss，使得每个scss文件都被注入这个uni.scss，达到全局可用的效果。如果开发者想要less、stylus的全局使用，需要在vue.config.js中自行配置webpack策略。 pages.json不支持scss，原生导航栏和tabbar的动态修改只能使用js api 7. App.vue App.vue是uni-app的主组件，所有页面都是在App.vue下进行切换的，是页面入口文件。但App.vue本身不是页面，这里不能编写视图元素，也就是没有。 应用生命周期仅可在App.vue中监听，在页面监听无效。 7.1 应用生命周期 函数名 说明 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onError 当 uni-app 报错时触发 onUniNViewMessage 对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯 onUnhandledRejection 对未处理的 Promise 拒绝事件监听函数（2.8.1+） onPageNotFound 页面不存在监听函数 onThemeChange 监听系统主题变化 // 只能在App.vue里监听应用的生命周期 export default { onLaunch: function() { console.log('App Launch') }, onShow: function() { console.log('App Show') }, onHide: function() { console.log('App Hide') } } 应用生命周期仅可在App.vue中监听，在其它页面监听无效。 以组合式 API 使用时，在 Vue2 和 Vue3 中存在一定区别，请分别参考：Vue2 组合式 API 使用文档 和 Vue3 组合式 API 使用文档。 应用启动参数，可以在API uni.getLaunchOptionsSync获取，详见 onlaunch里进行页面跳转，如遇白屏报错，请参考https://ask.dcloud.net.cn/article/35942 App.vue 不能写模板 onPageNotFound 页面实际上已经打开了（比如通过分享卡片、小程序码）且发现页面不存在，才会触发，api 跳转不存在的页面不会触发（如 uni.navigateTo） 7.2 globalData App.vue 中定义globalData的相关配置： export default { globalData: { text: 'text' } } js中操作globalData的方式如下： getApp().globalData.text = 'test' 在应用onLaunch时，getApp对象还未获取，暂时可以使用this.globalData获取globalData。 如果需要把globalData的数据绑定到页面上，可在页面的onShow页面生命周期里进行变量重赋值。 nvue的weex编译模式中使用globalData的话，由于weex生命周期不支持onShow，但熟悉5+的话，可利用监听webview的addEventListener show事件实现onShow效果，或者直接使用weex生命周期中的beforeCreate。但建议开发者使用uni-app编译模式，而不是weex编译模式。 globalData是简单的全局变量，如果使用状态管理，请使用vuex（main.js中定义） 7.3 全局样式 在App.vue中，可以定义一些全局通用样式，例如需要加一个通用的背景色，首屏页面渲染的动画等都可以写在App.vue中。 注意如果工程下同时有vue和nvue文件，全局样式的所有css会应用于所有文件，而nvue支持的css有限，编译器会在控制台报警，提示某些css无法在nvue中支持。此时需要把nvue不支持的css写在单独的条件编译里。如： /* #ifndef APP-PLUS-NVUE */ @import './common/uni.css'; /* #endif*/ 8. main.js main.js是 uni-app 的入口文件，主要作用是初始化vue实例、定义全局组件、使用需要的插件如 vuex。 首先引入了Vue库和App.vue，创建了一个vue实例，并且挂载vue实例。 使用Vue.use引用插件，使用Vue.prototype添加全局变量，使用Vue.component注册全局组件。 无法使用vue-router，路由须在pages.json中进行配置。如果开发者坚持使用vue-router，可以在插件市场找到转换插件。 nvue 暂不支持在 main.js 注册全局组件 import Vue from 'vue' import App from './App' import pageHead from './components/page-head.vue' //全局引用 page-head 组件 Vue.config.productionTip = false Vue.component('page-head', pageHead) //全局注册 page-head 组件，每个页面将可以直接使用该组件 App.mpType = 'app' const app = new Vue({ ...App }) app.$mount() //挂载 Vue 实例 IV>uni-app 组件 1. 基础组件 基础组件在uni-app框架中已经内置，无需将内置组件的文件导入项目，也无需注册内置组件，随时可以直接使用 2. NVUE组件 3. 拓展组件 扩展组件需要将组件导入项目中才可以使用。 uni-ui不包括基础组件，它是基础组件的补充。 4. datacom 组件规范 用到再看。 5. 组件库选型指南 选择组件的建议: 首先使用内置组件 然后使用uni ui扩展组件 其他需求依靠插件市场其他组件灵活补充 5.1 uni ui 优化逻辑层和视图层的通信折损：非H5端的各个平台，包括App和各种小程序，其逻辑层和视图层是分离的，两层之间通信交互会有折损，导致诸如跟手滑动不流畅。uni ui在底层会利用wxs等技术，把适当的js代码运行在视图层，减少通信折损，保证诸如swiperAction左滑菜单等跟手操作流畅顺滑 自动差量diff数据：在uni-app下，开发App和小程序，不需要手动setData，底层自动会差量更新数据。但如果使用了小程序组件，则需要按小程序的setData方式来更新数据，很难做到自动diff更新数据。 背景停止：很多ui组件是会一直动的，比如轮播图、跑马灯。即便这个窗体被新窗体挡住，它在背景层仍然在消耗着硬件资源。在Android的webview版本为chrome66以上，背景操作ui会引发很严重的性能问题，造成前台界面明显卡顿。而uni ui的组件，会自动判断自己的显示状态，在组件不再可见时，不会再做动画消耗硬件资源。 纯vue语法：uni ui的引用、开发都是纯vue方式。而小程序组件的引用注册、开发都是小程序语法，两种语法混合在一个工程，写的也不舒服，维护也麻烦。 与uni统计自动整合：比如使用uni ui的导航栏组件，就不需要写统计的自定义事件来触发页面标题上报。uni统计会自动识别导航栏组件的标题。类似的，收藏组件、购物车组件，都可以免打点直接使用。 uni ui兼容Android 4.4等低端机webview，没有浏览器兼容问题。 uni ui支持nvue：App端，uni-app同时支持webview渲染和原生渲染，而uni ui是可以一套代码同时支持webview渲染和原生渲染的。为了兼容原生渲染，uni ui也做到了纯flex布局。 uni ui内置vue doc，使用组件时有良好的代码提示 支持easycom规范，使用非常简单 支持datacom规范，云端一体全部封装掉 支持uni_module规范，方便插件的更新 推荐在HBuilderX新建项目时，直接选择uni ui项目模板，然后在代码里直接敲u，所有组件都拉出来，不用引用、不用注册，直接就用。 5.2 uView 整合了非常多组件，功能丰富、文档清晰，但不支持nvue(2.x已支持nvue) 5.3 colorUI css库 颜值很高，css库而非组件 5.4 unify UI 全端支持的组件库，侧重nvue（商城已下架） 5.5 mypUI 全端支持的组件库，侧重nvue 5.6 ThorUI 5.7 graceUI V>uni-app API 1. 概述 1.1 API Promise 化 具体 API Promise 化 的策略 异步的方法，如果不传入 success、fail、complete 等 callback 参数，将以 Promise 返回数据。例如：uni.getImageInfo() 异步的方法，且有返回对象，如果希望获取返回对象，必须至少传入一项 success、fail、complete 等 callback 参数。 // 正常使用 const task = uni.connectSocket( success(res){ console.log(res) } ) // Promise 化 uni.connectSocket().then(res => { // 此处即为正常使用时 success 回调的 res // uni.connectSocket() 正常使用时是会返回 task 对象的，如果想获取 task ，则不要使用 Promise 化 console.log(res) }) 不进行 Promise 化 的 API 同步的方法（即以 sync 结束）。例如：uni.getSystemInfoSync() 以 create 开头的方法。例如：uni.createMapContext() 以 manager 结束的方法。例如：uni.getBackgroundAudioManager() 1.2 Vue 2 和 Vue 3 的 API Promise 化 Vue2 对部分 API 进行了 Promise 封装，返回数据的第一个参数是错误对象，第二个参数是返回数据。此时使用 catch 是拿不到报错信息的，因为内部对错误进行了拦截。 Vue3 对部分 API 进行了 Promise 封装，调用成功会进入 then 方法 回调。调用失败会进入 catch 方法 回调 //VUE 2 // 默认方式 uni.request({ url: \"https://www.example.com/request\", success: (res) => { console.log(res.data); }, fail: (err) => { console.error(err); }, }); // Promise uni .request({ url: \"https://www.example.com/request\", }) .then((data) => { // data为一个数组 // 数组第一项为错误信息 即为 fail 回调 // 第二项为返回数据 var [err, res] = data; console.log(res.data); }); // Await async function request() { var [err, res] = await uni.request({ url: \"https://www.example.com/request\", }); console.log(res.data); } //VUE 3 // 默认方式 uni.request({ url: \"https://www.example.com/request\", success: (res) => { console.log(res.data); }, fail: (err) => { console.error(err); }, }); // 使用 Promise then/catch 方式调用 uni .request({ url: \"https://www.example.com/request\", }) .then((res) => { // 此处的 res 参数，与使用默认方式调用时 success 回调中的 res 参数一致 console.log(res.data); }) .catch((err) => { // 此处的 err 参数，与使用默认方式调用时 fail 回调中的 err 参数一致 console.error(err); }); // 使用 Async/Await 方式调用 async function request() { try { var res = await uni.request({ url: \"https://www.example.com/request\", }); // 此处的 res 参数，与使用默认方式调用时 success 回调中的 res 参数一致 console.log(res); } catch (err) { // 此处的 err 参数，与使用默认方式调用时 fail 回调中的 err 参数一致 console.error(err); } } 2. 基础 2.1 日志打印 console.debug, console.log, console.info, console.warn, console.error 快捷键 clog clogv 2.2 定时器 2.2.1 setTimeout(callback, delay, rest) 设定一个定时器。在定时到期以后执行注册的回调函数 参数说明 参数 类型 必填 说明 callback Function 是 回调函数 delay Number 否 延迟的时间，函数的调用会在该延迟之后发生，单位 ms rest Any 否 param1, param2, ..., paramN 等附加参数，它们会作为参数传递给回调函数 返回值 返回值 类型 说明 timeoutID Number 定时器的编号，这个值可以传递给 clearTimeout 来取消该定时 2.2.2 clearTimeout(timeoutID) 取消由 setTimeout 设置的定时器。 参数说明 参数 类型 必填 说明 timeoutID Number 是 要取消的定时器的 ID 2.2.3 setInterval(callback, delay, rest) 设定一个定时器。按照指定的周期（以毫秒计）来执行注册的回调函数 参数说明 参数 类型 必填 说明 callback Function 是 回调函数 delay Number 否 执行回调函数之间的时间间隔，单位 ms rest Any 否 param1, param2, ..., paramN 等附加参数，它们会作为参数传递给回调函数 返回值 返回值 类型 说明 intervalID Number 定时器的编号，这个值可以传递给 clearInterval 来取消该定时 2.2.4 clearInterval(intervalID) 取消由 setInterval 设置的定时器。 参数说明 参数 类型 必填 说明 intervalID Number 是 要取消的定时器的 ID 2.3 Base64 转 ArrayBuffer & Base64 转 ArrayBuffer 2.3.1 uni.base64ToArrayBuffer(base64) 将 Base64 字符串转成 ArrayBuffer 对象 const base64 = 'test' const arrayBuffer = uni.base64ToArrayBuffer(base64) 2.3.2 uni.arrayBufferToBase64(arrayBuffer) 将 ArrayBuffer 对象转成 Base64 字符串 const arrayBuffer = new Uint8Array([55, 55, 55]) const base64 = uni.arrayBufferToBase64(arrayBuffer) 2.4 uni.getLaunchOptionsSync() 获取启动时的参数。返回值与App.onLaunch的回调参数一致 2.5 uni.getEnterOptionsSync() 获取启动时的参数。 2.6 uni.onPageNotFound(CALLBACK) 监听应用要打开的页面不存在事件。该事件与 App.onPageNotFound 的回调时机一致 uni.offPageNotFound(CALLBACK) 取消监听应用要打开的页面不存在事件。 2.7 uni.onError(CALLBACK) 监听小程序错误事件。如脚本错误或 API 调用报错等。该事件与 App.onError 的回调时机与参数一致。 uni.offError(CALLBACK) 取消监听应用错误事件。 2.8 uni.onAppShow(CALLBACK) 监听应用切前台事件。该事件与 App.onShow 的回调参数一致。 uni.offAppShow(CALLBACK) 取消监听小程序切前台事件。 2.9 uni.onAppHide(CALLBACK) 监听应用切前台事件。该事件与 App.onShow 的回调参数一致。 uni.offAppHide(CALLBACK) 取消监听小程序切后台事件。 2.10 拦截器 2.10.1 uni.addInterceptor(STRING, OBJECT) 添加拦截器 仅支持异步接口，如：uni.setStorage(OBJECT)，暂不支持同步接口如：uni.setStorageSync(KEY,DATA) uniCloud请求云端接口时（callFunction、uploadFile等）也会使用uni.request发送请求，请确保拦截器内不错误的处理此类请求 STRING 参数说明 需要拦截的api名称，如：uni.addInterceptor('request', OBJECT) ，将拦截 uni.request() OBJECT 参数说明 参数名 类型 必填 默认值 说明 平台差异说明 invoke Function 否 拦截前触发 returnValue Function 否 方法调用后触发，处理返回值 success Function 否 成功回调拦截 fail Function 否 失败回调拦截 complete Function 否 完成回调拦截 uni.request({ url: 'request/login', //仅为示例，并非真实接口地址。 success: (res) => { console.log(res.data); // 打印： {code:1,...} } }); uni.addInterceptor('request', { invoke(args) { // request 触发前拼接 url args.url = 'https://www.example.com/'+args.url }, success(args) { // 请求成功后，修改code值为1 args.data.code = 1 }, fail(err) { console.log('interceptor-fail',err) }, complete(res) { console.log('interceptor-complete',res) } }) uni.addInterceptor({ returnValue(args) { // 只返回 data 字段 return args.data } }) 2.10.2 uni.removeInterceptor(STRING) 删除拦截器 STRING 参数说明 需要删除拦截器的api名称 uni.removeInterceptor('request') 2.11 uni.canIUse(String) 判断应用的 API，回调，参数，组件等是否在当前版本可用。 平台差异说明 App、web 端暂不支持 ${API}.${method}.${param}.${options} 方式调用，只支持 ${API} App Web 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ程序 √ √ (uni-app 3.4.13+) √ √ √ √ √ String 参数说明 使用 ${API}.${method}.${param}.${options} 或者 ${component}.${attribute}.${option} 方式来调用，例如： ${API} 代表 API 名字 ${method} 代表调用方式，有效值为return, success, object, callback ${param} 代表参数或者返回值 ${options} 代表参数的可选值 ${component} 代表组件名字 ${attribute} 代表组件属性 ${option} 代表组件属性的可选值 uni.canIUse('getSystemInfoSync.return.screenWidth'); uni.canIUse('getSystemInfo.success.screenWidth'); uni.canIUse('showToast.object.image'); uni.canIUse('request.object.method.GET'); uni.canIUse('live-player'); uni.canIUse('text.selectable'); uni.canIUse('button.open-type.contact'); 3. 网路 3.1 uni.request(OBJECT) 发起网络请求。 OBJECT 参数说明 参数名 类型 必填 默认值 说明 平台差异说明 url String 是 开发者服务器接口地址 data Object/String/ArrayBuffer 否 请求的参数 App 3.3.7 以下不支持 ArrayBuffer 类型 header Object 否 设置请求的 header，header 中不能设置 Referer App、H5端会自动带上cookie，且H5端不可手动修改 method String 否 GET 有效值详见下方说明 timeout Number 否 60000 超时时间，单位 ms H5(HBuilderX 2.9.9+)、APP(HBuilderX 2.9.9+)、微信小程序（2.10.0）、支付宝小程序 dataType String 否 json 如果设为 json，会对返回的数据进行一次 JSON.parse，非 json 不会进行 JSON.parse responseType String 否 text 设置响应的数据类型。合法值：text、arraybuffer 支付宝小程序不支持 sslVerify Boolean 否 true 验证 ssl 证书 仅App安卓端支持（HBuilderX 2.3.3+），不支持离线打包 withCredentials Boolean 否 false 跨域请求时是否携带凭证（cookies） 仅H5支持（HBuilderX 2.6.15+） firstIpv4 Boolean 否 false DNS解析时优先使用ipv4 仅 App-Android 支持 (HBuilderX 2.8.0+) enableHttp2 Boolean 否 false 开启 http2 微信小程序 enableQuic Boolean 否 false 开启 quic 微信小程序 enableCache Boolean 否 false 开启 cache 微信小程序、字节跳动小程序 2.31.0+ enableHttpDNS Boolean 否 false 是否开启 HttpDNS 服务。如开启，需要同时填入 httpDNSServiceId 。 HttpDNS 用法详见 移动解析HttpDNS 微信小程序 httpDNSServiceId String 否 HttpDNS 服务商 Id。 HttpDNS 用法详见 移动解析HttpDNS 微信小程序 enableChunked Boolean 否 false 开启 transfer-encoding chunked 微信小程序 forceCellularNetwork Boolean 否 false wifi下使用移动网络发送请求 微信小程序 enableCookie Boolean 否 false 开启后可在headers中编辑cookie 支付宝小程序 10.2.33+ cloudCache Object/Boolean 否 false 是否开启云加速（详见云加速服务） 百度小程序 3.310.11+ defer Boolean 否 false 控制当前请求是否延时至首屏内容渲染后发送 百度小程序 3.310.11+ success Function 否 收到开发者服务器成功返回的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） method 有效值 注意：method有效值必须大写，每个平台支持的method有效值不同，详细见下表。 method App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 快手小程序 京东小程序 GET √ √ √ √ √ √ √ √ POST √ √ √ √ √ √ √ √ PUT √ √ √ x √ √ x x DELETE √ √ √ x √ x x x CONNECT x √ √ x x x x x HEAD √ √ √ x √ x x x OPTIONS √ √ √ x √ x x x TRACE x √ √ x x x x x success 返回参数说明 参数 类型 说明 data Object/String/ArrayBuffer 开发者服务器返回的数据 statusCode Number 开发者服务器返回的 HTTP 状态码 header Object 开发者服务器返回的 HTTP Response Header cookies Array 开发者服务器返回的 cookies，格式为字符串数组 data 数据说明 最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String。转换规则如下： 对于 GET 方法，会将数据转换为 query string。例如 { name: 'name', age: 18 } 转换后的结果是 name=name&age=18。 对于 POST 方法且 header['content-type'] 为 application/json 的数据，会进行 JSON 序列化。 对于 POST 方法且 header['content-type'] 为 application/x-www-form-urlencoded 的数据，会将数据转换为 query string。 uni.request({ url: 'https://www.example.com/request', //仅为示例，并非真实接口地址。 data: { text: 'uni.request' }, header: { 'custom-header': 'hello' //自定义请求头信息 }, success: (res) => { console.log(res.data); this.text = 'request success'; } }); 返回值 如果希望返回一个 requestTask 对象，需要至少传入 success / fail / complete 参数中的一个。例如： var requestTask = uni.request({ url: 'https://www.example.com/request', //仅为示例，并非真实接口地址。 complete: ()=> {} }); requestTask.abort(); 如果没有传入 success / fail / complete 参数，则会返回封装后的 Promise 对象：Promise 封装 通过 requestTask，可中断请求任务。 requestTask 对象的方法列表 方法 参数 说明 abort 中断请求任务 offHeadersReceived 取消监听 HTTP Response Header 事件，仅微信小程序平台支持，文档详情 onHeadersReceived 监听 HTTP Response Header 事件。会比请求完成事件更早，仅微信小程序平台支持，文档详情 const requestTask = uni.request({ url: 'https://www.example.com/request', //仅为示例，并非真实接口地址。 data: { name: 'name', age: 18 }, success: function(res) { console.log(res.data); } }); // 中断请求任务 requestTask.abort(); 请求的 header 中 content-type 默认为 application/json。 避免在 header 中使用中文，或者使用 encodeURIComponent 进行编码，否则在百度小程序报错。（来自：快狗打车前端团队） 网络请求的 超时时间 可以统一在 manifest.json 中配置 networkTimeout。 H5 端本地调试需注意跨域问题，参考：调试跨域问题解决方案 注意由于百度小程序iOS客户端，请求失败时会进入fail回调，需要针对百度增加相应的处理以解决该问题。 注意小程序端不支持自动保持 cookie，服务器应避免验证 cookie。如果服务器无法修改，也可以使用一些模拟手段，比如这样的工具https://github.com/charleslo1/weapp-cookie 可以请求时带上 cookie 并将响应的 cookie 保存在本地。 H5端 cookie 受跨域限制（和平时开发网站时一样），旧版的 uni.request 未支持 withCredentials 配置，可以直接使用 xhr 对象或者其他类库。 根据 W3C 规范，H5 端无法获取 response header 中 Set-Cookie、Set-Cookie2 这2个字段，对于跨域请求，允许获取的 response header 字段只限于“simple response header”和“Access-Control-Expose-Headers”（详情） uni-app 插件市场有flyio、axios等三方封装的拦截器可用 低版本手机自身不支持 ipv6，如果服务器仅允许 ipv6，会导致老手机无法正常运行或访问速度非常慢 localhost、127.0.0.1等服务器地址，只能在电脑端运行，手机端连接时不能访问。请使用标准IP并保证手机能连接电脑网络 debug 模式，安卓端暂时无法获取响应头，url中含有非法字符（如未编码为%20的空格）时会请求失败 iOS App第一次安装启动后，会弹出是否允许联网的询问框，在用户点击同意前，调用联网API会失败。请注意判断这种情况。比如官方提供的新闻模板示例（HBuilderX新建项目可选择），会判断如果无法联网，则提供一个错误页，提示用户设置网络及下拉刷新重试。 良好体验的App，还会判断当前是否处于飞行模式（参考）、是wifi还是3G（参考） 部分安卓设备，真机运行或debug模式下的网速，低于release模式很多。 使用一些比较小众的证书机构（如：CFCA OV OCA）签发的 ssl 证书在安卓设备请求会失败，因为这些机构的根证书不在系统内置根证书库，可以更换其他常见机构签发的证书（如：Let's Encrypt），或者配置 sslVerify 为 false 关闭 ssl 证书验证（不推荐）。 离线打包不支持 sslVerify 配置 单次网络请求数据量建议控制在50K以下（仅指json数据，不含图片），过多数据应分页获取，以提升应用体验。 3.2 uni.uploadFile(OBJECT) - 上传 将本地资源上传到开发者服务器，客户端发起一个 POST 请求，其中 content-type 为 multipart/form-data。 如页面通过 uni.chooseImage 等接口获取到一个本地资源的临时文件路径后，可通过此接口将本地资源上传到指定服务器。另外选择和上传非图像、视频文件参考：https://ask.dcloud.net.cn/article/35547。 OBJECT 参数说明 参数名 类型 必填 说明 平台差异说明 url String 是 开发者服务器 url files Array 是（files和filePath选其一） 需要上传的文件列表。使用 files 时，filePath 和 name 不生效。 App、H5（ 2.6.15+） fileType String 见平台差异说明 文件类型，image/video/audio 仅支付宝小程序，且必填。 file File 否 要上传的文件对象。 仅H5（2.6.15+）支持 filePath String 是（files和filePath选其一） 要上传文件资源的路径。 name String 是 文件对应的 key , 开发者在服务器端通过这个 key 可以获取到文件二进制内容 header Object 否 HTTP 请求 Header, header 中不能设置 Referer。 timeout Number 否 超时时间，单位 ms H5(HBuilderX 2.9.9+)、APP(HBuilderX 2.9.9+) formData Object 否 HTTP 请求中其他额外的 form data success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 注意： App支持多文件上传，微信小程序只支持单文件上传，传多个文件需要反复调用本API。所以跨端的写法就是循环调用本API。 hello uni-app中的客服反馈，支持多图上传。uni-app插件市场中也有多个封装的组件。 App平台选择和上传非图像、视频文件，参考https://ask.dcloud.net.cn/article/35547 网络请求的 超时时间 可以统一在 manifest.json 中配置 networkTimeout。 支付宝小程序开发工具上传文件返回的http状态码为字符串形式，支付宝小程序真机返回的状态码为数字形式 files参数说明 files 参数是一个 file 对象的数组，file 对象的结构如下： 参数名 类型 必填 说明 name String 否 multipart 提交时，表单的项目名，默认为 file file File 否 要上传的文件对象，仅H5（2.6.15+）支持 uri String 是 文件的本地地址 Tip: 如果 name 不填或填的值相同，可能导致服务端读取文件时只能读取到一个文件。 success 返回参数说明 参数 类型 说明 data String 开发者服务器返回的数据 statusCode Number 开发者服务器返回的 HTTP 状态码 uni.chooseImage({ success: (chooseImageRes) => { const tempFilePaths = chooseImageRes.tempFilePaths; uni.uploadFile({ url: 'https://www.example.com/upload', //仅为示例，非真实的接口地址 filePath: tempFilePaths[0], name: 'file', formData: { 'user': 'test' }, success: (uploadFileRes) => { console.log(uploadFileRes.data); } }); } }); 返回值 如果希望返回一个 uploadTask 对象，需要至少传入 success / fail / complete 参数中的一个。例如： var uploadTask = uni.uploadFile({ url: 'https://www.example.com/upload', //仅为示例，并非真实接口地址。 complete: ()=> {} }); uploadTask.abort(); 如果没有传入 success / fail / complete 参数，则会返回封装后的 Promise 对象：Promise 封装 通过 uploadTask，可监听上传进度变化事件，以及取消上传任务。 uploadTask 对象的方法列表 方法 参数 说明 abort 中断上传任务 onProgressUpdate callback 监听上传进度变化 onHeadersReceived callback 监听 HTTP Response Header 事件。会比请求完成事件更早,仅微信小程序平台支持，规范详情 offProgressUpdate callback 取消监听上传进度变化事件，仅微信小程序平台支持，规范详情 offHeadersReceived callback 取消监听 HTTP Response Header 事件，仅微信小程序平台支持，规范详情 onProgressUpdate 返回参数说明 参数 类型 说明 progress Number 上传进度百分比 totalBytesSent Number 已经上传的数据长度，单位 Bytes totalBytesExpectedToSend Number 预期需要上传的数据总长度，单位 Bytes uni.chooseImage({ success: (chooseImageRes) => { const tempFilePaths = chooseImageRes.tempFilePaths; const uploadTask = uni.uploadFile({ url: 'https://www.example.com/upload', //仅为示例，非真实的接口地址 filePath: tempFilePaths[0], name: 'file', formData: { 'user': 'test' }, success: (uploadFileRes) => { console.log(uploadFileRes.data); } }); uploadTask.onProgressUpdate((res) => { console.log('上传进度' + res.progress); console.log('已经上传的数据长度' + res.totalBytesSent); console.log('预期需要上传的数据总长度' + res.totalBytesExpectedToSend); // 测试条件，取消上传任务。 if (res.progress > 50) { uploadTask.abort(); } }); } }); 3.3 uni.downloadFile(OBJECT) - 下载 下载文件资源到本地，客户端直接发起一个 HTTP GET 请求，返回文件的本地临时路径。 OBJECT 参数说明 参数名 类型 必填 说明 平台差异说明 url String 是 下载资源的 url header Object 否 HTTP 请求 Header, header 中不能设置 Referer。 timeout Number 否 超时时间，单位 ms H5(HBuilderX 2.9.9+)、APP(HBuilderX 2.9.9+) success Function 否 下载成功后以 tempFilePath 的形式传给页面，res = {tempFilePath: '文件的临时路径'} fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） filePath string 否 指定文件下载后存储的路径 (本地路径) 微信小程序（IOS小程序保存到相册需要添加此字段才可以正常保存） 注：文件的临时路径，在应用本次启动期间可以正常使用，如需持久保存，需在主动调用 uni.saveFile，才能在应用下次启动时访问得到。 success 返回参数说明 参数 类型 说明 tempFilePath String 临时文件路径，下载后的文件会存储到一个临时文件 statusCode Number 开发者服务器返回的 HTTP 状态码 注意 网络请求的 超时时间 可以统一在 manifest.json 中配置 networkTimeout。 uni.downloadFile({ url: 'https://www.example.com/file/test', //仅为示例，并非真实的资源 success: (res) => { if (res.statusCode === 200) { console.log('下载成功'); } } }); 返回值 如果希望返回一个 downloadTask 对象，需要至少传入 success / fail / complete 参数中的一个。例如： var downloadTask = uni.downloadFile({ url: 'https://www.example.com/file/test', //仅为示例，并非真实接口地址。 complete: ()=> {} }); downloadTask.abort(); 如果没有传入 success / fail / complete 参数，则会返回封装后的 Promise 对象：Promise 封装 通过 downloadTask，可监听下载进度变化事件，以及取消下载任务。 downloadTask 对象的方法列表 方法 参数 说明 最低版本 abort 中断下载任务 * onProgressUpdate callback 监听下载进度变化 * onHeadersReceived callback 监听 HTTP Response Header 事件，会比请求完成事件更早,仅微信小程序平台支持，规范详情 offProgressUpdate callback 取消监听下载进度变化事件，仅微信小程序平台支持，规范详情 offHeadersReceived callback 取消监听 HTTP Response Header 事件，仅微信小程序平台支持，规范详情 onProgressUpdate 返回参数说明 参数 类型 说明 progress Number 下载进度百分比 totalBytesWritten Number 已经下载的数据长度，单位 Bytes totalBytesExpectedToWrite Number 预期需要下载的数据总长度，单位 Bytes const downloadTask = uni.downloadFile({ url: 'http://www.example.com/file/test', //仅为示例，并非真实的资源 success: (res) => { if (res.statusCode === 200) { console.log('下载成功'); } } }); downloadTask.onProgressUpdate((res) => { console.log('下载进度' + res.progress); console.log('已经下载的数据长度' + res.totalBytesWritten); console.log('预期需要下载的数据总长度' + res.totalBytesExpectedToWrite); // 满足测试条件，取消下载任务。 if (res.progress > 50) { downloadTask.abort(); } }); 3.4 WebSocket 用到再看。 3.5 SocketTask 用到再看。 4. 页面和路由 4.1 uni.navigateTo(OBJECT) 保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。 OBJECT参数说明 参数 类型 必填 默认值 说明 平台差异说明 url String 是 需要跳转的应用内非 tabBar 的页面的路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&分隔；如 'path?key=value&key2=value2'，path为下一个页面的路径，下一个页面的onLoad函数可得到传递的参数 animationType String 否 pop-in 窗口显示的动画效果，详见：窗口动画 App animationDuration Number 否 300 窗口动画持续时间，单位为 ms App events Object 否 页面间通信接口，用于监听被打开页面发送到当前页面的数据。2.8.9+ 开始支持。 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） object.success 回调函数 参数 Object res 属性 类型 说明 eventChannel EventChannel 和被打开页面进行通信 // 在起始页面跳转到test.vue页面，并监听test.vue发送过来的事件数据 uni.navigateTo({ url: 'pages/test?id=1', events: { // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function(data) { console.log(data) }, someEvent: function(data) { console.log(data) } ... }, success: function(res) { // 通过eventChannel向被打开页面传送数据 res.eventChannel.emit('acceptDataFromOpenerPage', { data: 'data from starter page' }) } }) // 在test.vue页面，向起始页通过事件传递数据 onLoad: function(option) { const eventChannel = this.getOpenerEventChannel(); eventChannel.emit('acceptDataFromOpenedPage', {data: 'data from test page'}); eventChannel.emit('someEvent', {data: 'data from test page for someEvent'}); // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据 eventChannel.on('acceptDataFromOpenerPage', function(data) { console.log(data) }) } url有长度限制，太长的字符串会传递失败，可改用窗体通信、全局变量，另外参数中出现空格等特殊字符时需要对参数进行编码，如下为使用encodeURIComponent对参数进行编码的示例。 // 在test.vue页面接受参数 onLoad: function (option) { const item = JSON.parse(decodeURIComponent(option.item)); } 页面跳转路径有层级限制，不能无限制跳转新页面 跳转到 tabBar 页面只能使用 switchTab 跳转 路由API的目标页面必须是在pages.json里注册的vue页面。如果想打开web url，在App平台可以使用 plus.runtime.openURL或web-view组件；H5平台使用 window.open；小程序平台使用web-view组件（url需在小程序的联网白名单中）。在hello uni-app中有个组件ulink.vue已对多端进行封装，可参考。 4.2 uni.redirectTo(OBJECT) 关闭当前页面，跳转到应用内的某个页面。 跳转到 tabBar 页面只能使用 switchTab 跳转 OBJECT参数说明 参数 类型 必填 说明 url String 是 需要跳转的应用内非 tabBar 的页面的路径，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&分隔；如 'path?key=value&key2=value2' success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.redirectTo({ url: 'test?id=1' }); 4.3 uni.reLaunch(OBJECT) 关闭所有页面，打开到应用内的某个页面。 如果调用了 uni.preloadPage(OBJECT) 不会关闭，仅触发生命周期 onHide H5端调用uni.reLaunch之后之前页面栈会销毁，但是无法清空浏览器之前的历史记录，此时navigateBack不能返回，如果存在历史记录的话点击浏览器的返回按钮或者调用history.back()仍然可以导航到浏览器的其他历史记录。 OBJECT参数说明 参数 类型 必填 说明 url String 是 需要跳转的应用内页面路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&分隔；如 'path?key=value&key2=value2'，如果跳转的页面路径是 tabBar 页面则不能带参数 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.reLaunch({ url: 'test?id=1' }); 4.4 uni.switchTab(OBJECT) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。 如果调用了 uni.preloadPage(OBJECT) 不会关闭，仅触发生命周期 onHide OBJECT参数说明 参数 类型 必填 说明 url String 是 需要跳转的 tabBar 页面的路径（需在 pages.json 的 tabBar 字段定义的页面），路径后不能带参数 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） { \"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\" },{ \"pagePath\": \"pages/other/other\", \"text\": \"其他\" }] } } uni.switchTab({ url: '/pages/index/index' }); 4.5 uni.navigateBack(OBJECT) 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。 OBJECT参数说明 参数 类型 必填 默认值 说明 平台差异说明 delta Number 否 1 返回的页面数，如果 delta 大于现有页面数，则返回到首页。 animationType String 否 pop-out 窗口关闭的动画效果，详见：窗口动画 App animationDuration Number 否 300 窗口关闭动画的持续时间，单位为 ms App success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） // 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码 // 此处是A页面 uni.navigateTo({ url: 'B?id=1' }); // 此处是B页面 uni.navigateTo({ url: 'C?id=1' }); // 在C页面内 navigateBack，将返回A页面 uni.navigateBack({ delta: 2 }); 4.6 uni.preloadPage(OBJECT) 预加载页面，是一种性能优化技术。被预载的页面，在打开时速度更快。 平台差异说明 App-nvue H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 √(2.7.12+) √(2.7.12+) x x x x x OBJECT参数说明 属性 类型 必填 说明 url string 是 预加载页面url success Function 否 预加载成功完成回调 fail Function 否 预加载失败回调 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） H5 平台 预加载 /pages/test/test 对应的js文件，不执行页面预渲染逻辑 uni.preloadPage({url: \"/pages/test/test\"}); App-nvue 平台 预加载nvue页面 /pages/test/test uni.preloadPage({url: \"/pages/test/test\"}); 注意事项 App平台仅支持预加载 nvue 页面，执行页面预渲染，预载时触发生命周期 onLoad，onReady，不触发 onShow 打开新页面时，url 完全相同（包含参数）时，优先使用预加载页面，触发生命周期 onShow tabbar页面，仅支持预加载尚未显示过的页面，否则返回 fail，提示 already exists 同一时间，相同 url 仅 preloadPage 一次 当同一个预载页面已被打开(在路由栈)，再次打开相同url时，不再使用该预加载页面，而是打开新的非预载页面 uni.reLanuch, uni.switchTab, uni.navigateBack(含Android返回键) 切换页面时，预加载页面不会被销毁，仅触发生命周期 onHide 在预载页面使用 uni.redirectTo 时，预加载页面会被销毁，触发生命周期 onUnload 示例 uni.preloadPage({url: \"/pages/test/test\"}); // 预加载 /pages/test/test 页面（仅触发onLoad，onReady) uni.navigateTo({url: \"/pages/test/test\"}); // url匹配，跳转预加载页面（仅触发onShow) uni.navigateTo({url: \"/pages/test/test?a=b\"}); // url不匹配，正常打开新页面 HBuilderX 2.7.12+的hello uni-app，在navigator示例和uni ui的日历示例中增加了页面预载示例。 4.7 uni.unPreloadPage(OBJECT) 取消预载页面。 仅App-nvue支持 当预载页面未被打开时，使用 unPreloadPage时会销毁该页面，触发生命周期 onUnload 当预载页面已被打开时，使用 unPreloadPage时不销毁该页面，但该预加载页面不再继续存在，会随着路由变化而销毁 4.8 窗口动画 窗口的显示/关闭动画效果，支持在 API、组件、pages.json 中配置，优先级为：(API == 组件) > pages.json。 4.8.1 API 有效的路由 API navigateTo navigateBack uni.navigateTo({ url: '../test/test', animationType: 'pop-in', animationDuration: 200 }); uni.navigateBack({ delta: 1, animationType: 'pop-out', animationDuration: 200 }); 4.8.2 组件 open-type 有效值 navigateTo navigateBack navigator navigator 4.8.3 pages.json \"style\": { \"app-plus\": { \"animationType\": \"fade-in\", \"animationDuration\": 300 } } 显示动画与关闭动画，会有默认的对应规则。但是如果通过 API 或组件配置了窗口关闭的动画类型，则不会使用默认的类型。 显示动画 关闭动画 显示动画描述（关闭动画与之相反） slide-in-right slide-out-right 新窗体从右侧进入 slide-in-left slide-out-left 新窗体从左侧进入 slide-in-top slide-out-top 新窗体从顶部进入 slide-in-bottom slide-out-bottom 新窗体从底部进入 pop-in pop-out 新窗体从左侧进入，且老窗体被挤压而出 fade-in fade-out 新窗体从透明到不透明逐渐显示 zoom-out zoom-in 新窗体从小到大缩放显示 zoom-fade-out zoom-fade-in 新窗体从小到大逐渐放大并且从透明到不透明逐渐显示 none none 无动画 纯nvue项目（render为native），窗体动画默认进入动画为popin，返回为pop-out。如果想修改动画类型，只能通过uni.navigateTo API修改，在组件或pages.json里配置动画类型无效 非纯nvue项目，App端窗体动画，默认进入动画为slider-in-right，默认返回动画为pop-out webview 中嵌入 uni-app H5时，使用 uni.webView.navigateTo... 跳转页面 4.9 页面 4.9.1 getCurrentPages getCurrentPages() 函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。 getCurrentPages()仅用于展示页面栈的情况，请勿修改页面栈，以免造成页面状态错误。 每个页面实例的方法属性列表： 方法 描述 平台说明 page.$getAppWebview() 获取当前页面的webview对象实例 App page.$vm 当前页面的 Vue 实例 page.route 获取当前页面的路由 navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 不能在 App.vue 里面进行页面跳转。 4.9.2 $getAppWebview() uni-app 在 getCurrentPages()获得的页面里内置了一个方法 $getAppWebview() 可以得到当前webview的对象实例，从而实现对 webview 更强大的控制。在 html5Plus 中，plus.webview具有强大的控制能力，可参考：WebviewObject。 但uni-app框架有自己的窗口管理机制，请不要自己创建和销毁webview，如有需求覆盖子窗体上去，请使用原生子窗体subNvue。 获取当前页面 webview 的对象实例 export default { data() { return { title: 'Hello' } }, onLoad() { // #ifdef APP-PLUS const currentWebview = this.$scope.$getAppWebview(); //此对象相当于html5plus里的plus.webview.currentWebview()。在uni-app里vue页面直接使用plus.webview.currentWebview()无效 currentWebview.setBounce({position:{top:'100px'},changeoffset:{top:'0px'}}); //动态重设bounce效果 // #endif } } 获取指定页面 webview 的对象实例 var pages = getCurrentPages(); var page = pages[pages.length - 1]; // #ifdef APP-PLUS var currentWebview = page.$getAppWebview(); console.log(currentWebview.id);//获得当前webview的id console.log(currentWebview.isVisible());//查询当前webview是否可见 // #endif 4.9.3 $vm 通过页面的 Vue 实例可以获取页面的数据、调用页面上的方法以及监听页面的生命周期等 const page = getCurrentPages()[0]; const vm = page.$vm; // 监听生命周期，小程序端部分其他生命周期需在页面选项中配置过才可生效 vm.$on('hook:onHide', () => { console.log('onHide'); }); // 获取页面数据 console.log(vm.$data.title); // 调用页面方法 vm.test(); 4.10 EventChannel EventChannel.emit(string eventName, any args) EventChannel.off(string eventName, function fn) EventChannel.on(string eventName, function fn) EventChannel.once(string eventName, function fn) uni.navigateTo({ url: 'pages/test?id=1', events: { // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function(data) { console.log(data) }, someEvent: function(data) { console.log(data) } ... }, success: function(res) { // 通过eventChannel向被打开页面传送数据 res.eventChannel.emit('acceptDataFromOpenerPage', { data: 'test' }) } }) // uni.navigateTo 目标页面 pages/test.vue onLoad: function(option) { console.log(option.query) const eventChannel = this.getOpenerEventChannel() eventChannel.emit('acceptDataFromOpenedPage', {data: 'test'}); eventChannel.emit('someEvent', {data: 'test'}); // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据 eventChannel.on('acceptDataFromOpenerPage', function(data) { console.log(data) }) } 4.11 页面通讯 uni.$emit(eventName,OBJECT) uni.$on(eventName,callback) uni.$once(eventName,callback) uni.$off([eventName, callback]) Tip: uni.$emit、 uni.$on 、 uni.$once 、uni.$off 触发的事件都是 App 全局级别的，跨任意组件，页面，nvue，vue 等 使用时，注意及时销毁事件监听，比如，页面 onLoad 里边 uni.$on 注册监听，onUnload 里边 uni.$off 移除，或者一次性的事件，直接使用 uni.$once 监听 注意 uni.$on 定义完成后才能接收到 uni.$emit 传递的数据 和EventChannel的区别: EventChannel只能用在(N)Vue页面, 通过this.getOpenerEventChannel()来获取EventChannel对象, 而uni.$emit可以作用于全局。 4.12 subNvue 原生子窗体 用到再看。 5. 数据缓存 5.1 异步操作 uni.setStorage(OBJECT) 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。 OBJECT 参数说明 参数名 类型 必填 说明 key String 是 本地缓存中的指定的 key data Any 是 需要存储的内容，只支持原生类型、及能够通过 JSON.stringify 序列化的对象 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.setStorage({ key: 'storage_key', data: 'hello', success: function () { console.log('success'); } }); uni.getStorage(OBJECT) 从本地缓存中异步获取指定 key 对应的内容。 OBJECT 参数说明 参数名 类型 必填 说明 key String 是 本地缓存中的指定的 key success Function 是 接口调用的回调函数，res = {data: key对应的内容} fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数 类型 说明 data Any key 对应的内容 uni.getStorage({ key: 'storage_key', success: function (res) { console.log(res.data); } }); uni.getStorageInfo(OBJECT) 异步获取当前 storage 的相关信息。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 HBuilderX 2.0.3+ √ √ √ √ OBJECT 参数说明 参数名 类型 必填 说明 success Function 是 接口调用的回调函数，详见返回参数说明 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数 类型 说明 keys Array＜String＞ 当前 storage 中所有的 key currentSize Number 当前占用的空间大小, 单位：kb limitSize Number 限制的空间大小, 单位：kb uni.getStorageInfo({ success: function (res) { console.log(res.keys); console.log(res.currentSize); console.log(res.limitSize); } }); uni.removeStorage(OBJECT) 从本地缓存中异步移除指定 key。 OBJECT 参数说明 参数名 类型 必填 说明 key String 是 本地缓存中的指定的 key success Function 是 接口调用的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.removeStorage({ key: 'storage_key', success: function (res) { console.log('success'); } }); uni.clearStorage() 清理本地数据缓存。 uni.clearStorage(); 5.2 同步操作 uni.setStorageSync(KEY,DATA) 将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。 参数说明 | 参数 | 类型 | 必填 | 说明 | | :--- | :----- | :--- | :----------------------------------------------------------- | | key | String | 是 | 本地缓存中的指定的 key | | data | Any | 是 | 需要存储的内容，只支持原生类型、及能够通过 JSON.stringify 序列化的对象 | try { uni.setStorageSync('storage_key', 'hello'); } catch (e) { // error } uni.getStorageSync(KEY) 从本地缓存中同步获取指定 key 对应的内容。 参数说明 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key try { const value = uni.getStorageSync('storage_key'); if (value) { console.log(value); } } catch (e) { // error } uni.getStorageInfoSync() 同步获取当前 storage 的相关信息。 try { const res = uni.getStorageInfoSync(); console.log(res.keys); console.log(res.currentSize); console.log(res.limitSize); } catch (e) { // error } uni.removeStorageSync(KEY) 从本地缓存中同步移除指定 key。 try { uni.removeStorageSync('storage_key'); } catch (e) { // error } uni.clearStorageSync() 同步清理本地数据缓存。 try { uni.clearStorageSync(); } catch (e) { // error } H5端为localStorage，浏览器限制5M大小，是缓存概念，可能会被清理 App端为原生的plus.storage，无大小限制，不是缓存，是持久化的 各个小程序端为其自带的storage api，数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。 微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 支付宝小程序单条数据转换成字符串后，字符串长度最大200*1024。同一个支付宝用户，同一个小程序缓存总上限为10MB。 百度小程序策略详见、字节跳动小程序策略详见 非App平台清空Storage会导致uni.getSystemInfo获取到的deviceId改变 除此之外，其他数据存储方案： H5端还支持websql、indexedDB、sessionStorage App端还支持SQLite、IO文件等本地存储方案。 6. 位置 6.1 获取位置信息 uni.getLocation(OBJECT) 获取当前的地理位置、速度。 6.2 查看位置 uni.openLocation(OBJECT) 使用应用内置地图查看位置。 6.3 位置更新 uni.onLocationChange(FUNCTION CALLBACK) 监听实时地理位置变化事件，需结合 uni.startLocationUpdate 或 uni.startLocationUpdateBackground 使用 6.4 地图组件控制 uni.createMapContext(mapId,this) 创建并返回 map 上下文 mapContext 对象。在自定义组件下，第二个参数传入组件实例this，以操作组件内 组件。 7. 媒体 7.1 图片 7.1.1 uni.chooseImage(OBJECT) 从本地相册选择图片或使用相机拍照。 App端如需要更丰富的相机拍照API（如直接调用前置摄像头），参考plus.camera OBJECT 参数说明 参数名 类型 必填 说明 平台差异说明 count Number 否 最多可以选择的图片张数，默认9 见下方说明 sizeType Array 否 original 原图，compressed 压缩图，默认二者都有 App、微信小程序、支付宝小程序、百度小程序 extension Array 否 根据文件拓展名过滤，每一项都不能是空字符串。默认不过滤。 H5(HBuilder X2.9.9+) sourceType Array 否 album 从相册选图，camera 使用相机，默认二者都有。如需直接开相机或直接选相册，请只使用一个选项 crop Object 否 图像裁剪参数，设置后 sizeType 失效 App 3.1.19+ success Function 是 成功则返回图片的本地文件路径列表 tempFilePaths fail Function 否 接口调用失败的回调函数 小程序、App complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） crop 参数说明 参数名 类型 必填 说明 平台差异说明 quality Number 否 取值范围为1-100，数值越小，质量越低（仅对jpg格式有效）。默认值为80。 width Number 是 裁剪的宽度，单位为px，用于计算裁剪宽高比。 height Number 是 裁剪的高度，单位为px，用于计算裁剪宽高比。 resize Boolean 否 是否将width和height作为裁剪保存图片真实的像素值。默认值为true。注：设置为false时在裁剪编辑界面显示图片的像素值，设置为true时不显示 Tips count 值在 H5 平台的表现，基于浏览器本身的规范。目前测试的结果来看，只能限制单选/多选，并不能限制数量。并且，在实际的手机浏览器很少有能够支持多选的。 sourceType 值在 H5 平台根据浏览器的不同而表现不同，一般不可限制仅使用相册，部分浏览器也无法限制是否使用相机。 可以通过用户授权API来判断用户是否给应用授予相册或摄像头的访问权限https://uniapp.dcloud.io/api/other/authorize App端如需选择非媒体文件，可在插件市场搜索文件选择，其中Android端可以使用Native.js，无需原生插件，而iOS端需要原生插件。 选择照片大多为了上传，uni ui封装了更完善的uni-file-picker组件，文件选择、上传到uniCloud的免费存储和cdn中，一站式集成。强烈推荐使用。 注：文件的临时路径，在应用本次启动期间可以正常使用，如需持久保存，需在主动调用 uni.saveFile，在应用下次启动时才能访问得到。 success 返回参数说明 参数 类型 说明 tempFilePaths Array 图片的本地文件路径列表 tempFiles Array、Array 图片的本地文件列表，每一项是一个 File 对象 File 对象结构如下 参数 类型 说明 path String 本地文件路径 size Number 本地文件大小，单位：B name String 包含扩展名的文件名称，仅H5支持 type String 文件类型，仅H5支持 uni.chooseImage({ count: 6, //默认9 sizeType: ['original', 'compressed'], //可以指定是原图还是压缩图，默认二者都有 sourceType: ['album'], //从相册选择 success: function (res) { console.log(JSON.stringify(res.tempFilePaths)); } }); 7.1.2 uni.previewImage(OBJECT) 预览图片。 OBJECT 参数说明 参数名 类型 必填 说明 平台差异说明 current String/Number 详见下方说明 详见下方说明 urls Array 是 需要预览的图片链接列表 indicator String 否 图片指示器样式，可取值：\"default\" - 底部圆点指示器； \"number\" - 顶部数字指示器； \"none\" - 不显示指示器。 App loop Boolean 否 是否可循环预览，默认值为 false App longPressActions Object 否 长按图片显示操作菜单，如不填默认为保存相册 App 1.9.5+ success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） current 参数说明 current 为当前显示图片的链接/索引值，不填或填写的值无效则为 urls 的第一张。App平台在 1.9.5至1.9.8之间，current为必填。不填会报错 注意，当 urls 中有重复的图片链接时： 传链接，预览结果始终显示该链接在 urls 中第一次出现的位置。 传索引值，在微信/百度/字节跳动小程序平台，会过滤掉传入的 urls 中该索引值之前与其对应图片链接重复的值。其它平台会保留原始的 urls 不会做去重处理。 举例说明： 一组图片 [A, B1, C, B2, D]，其中 B1 与 B2 的图片链接是一样的。 传 B2 的链接，预览的结果是 B1，前一张是 A，下一张是 C。 传 B2 的索引值 3，预览的结果是 B2，前一张是 C，下一张是 D。此时在微信/百度/字节跳动小程序平台，最终传入的 urls 是 [A, C, B2, D]，过滤掉了与 B2 重复的 B1。 longPressActions 参数说明 参数 类型 必填 说明 itemList Array 是 按钮的文字数组 itemColor String 否 按钮的文字颜色，字符串格式，默认为\"#000000\" success Function 否 接口调用成功的回调函数，详见返回参数说明 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数 类型 说明 index Number 用户长按图片的索引值 tapIndex Number 用户点击按钮列表的索引值 // 从相册选择6张图 uni.chooseImage({ count: 6, sizeType: ['original', 'compressed'], sourceType: ['album'], success: function(res) { // 预览图片 uni.previewImage({ urls: res.tempFilePaths, longPressActions: { itemList: ['发送给朋友', '保存图片', '收藏'], success: function(data) { console.log('选中了第' + (data.tapIndex + 1) + '个按钮,第' + (data.index + 1) + '张图片'); }, fail: function(err) { console.log(err.errMsg); } } }); } }); 在非H5端，previewImage是原生实现的，界面自定义灵活度较低。 插件市场有前端实现的previewImage，性能低于原生实现，但界面可随意定义；插件市场也有适于App端的previewImage原生插件，提供了更多功能。 7.1.3 uni.closePreviewImage(OBJECT) 关闭预览图片。 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 飞书小程序 QQ小程序 快手小程序 京东小程序 √ (3.2.15+) √ (3.2.15+) x x x x x x x x OBJECT 参数说明 参数名 类型 必填 说明 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 7.1.4 uni.getImageInfo(OBJECT) 获取图片信息。 小程序下获取网络图片信息需先配置download域名白名单才能生效。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ √ √ √ √ √ √ √ √ OBJECT 参数说明 参数名 类型 必填 说明 src String 是 图片的路径，可以是相对路径，临时文件路径，存储文件路径，网络图片路径 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数名 类型 说明 平台差异说明 width Number 图片宽度，单位px height Number 图片高度，单位px path String 返回图片的本地路径 orientation String 返回图片的方向，有效值见下表 App、小程序、京东小程序 type String 返回图片的格式 App、小程序、京东小程序 orientation 参数说明 枚举值 说明 up 默认 down 180度旋转 left 逆时针旋转90度 right 顺时针旋转90度 up-mirrored 同up，但水平翻转 down-mirrored 同down，但水平翻转 left-mirrored 同left，但垂直翻转 right-mirrored 同right，但垂直翻转 uni.chooseImage({ count: 1, sourceType: ['album'], success: function (res) { uni.getImageInfo({ src: res.tempFilePaths[0], success: function (image) { console.log(image.width); console.log(image.height); } }); } }); 7.1.5 uni.saveImageToPhotosAlbum(OBJECT) 保存图片到系统相册。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √ √ √ √ √ OBJECT 参数说明 参数名 类型 必填 说明 filePath String 是 图片文件路径，可以是临时文件路径也可以是永久文件路径，不支持网络图片路径 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数名 类型 说明 path String 保存到相册的图片路径，仅 App 3.0.5+ 支持 errMsg String 调用结果 注意 可以通过用户授权API来判断用户是否给应用授予相册的访问权限https://uniapp.dcloud.io/api/other/authorize H5没有API可触发保存到相册行为，下载图片时浏览器会询问图片存放地址。 uni.chooseImage({ count: 1, sourceType: ['camera'], success: function (res) { uni.saveImageToPhotosAlbum({ filePath: res.tempFilePaths[0], success: function () { console.log('save success'); } }); } }); 7.1.6 uni.compressImage(OBJECT) 压缩图片接口，可选压缩质量 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √(基础库版本>=3.110.3) √ √ √ √ OBJECT 参数说明 属性 类型 默认值 必填 说明 平台差异说明 src String 是 图片路径，图片的路径，可以是相对路径、临时文件路径、存储文件路径 quality Number 80 否 压缩质量，范围0～100，数值越小，质量越低，压缩率越高（仅对jpg有效） width String auto 否 缩放图片的宽度，支持像素值（如\"100px\"）、百分比（如\"50%\"）、自动计算（如\"auto\"，即根据width与源图宽的缩放比例计算，若未设置width则使用源图宽度） App 3.0.0+ height String auto 否 缩放图片的高度，支持像素值（如\"100px\"）、百分比（如\"50%\"）、自动计算（如\"auto\"，即根据height与源图高的缩放比例计算，若未设置height则使用源图高度） App 3.0.0+ compressedWidth Number - 否 压缩后图片的宽度，单位为px，若不填写则默认以 compressHeight 为准等比缩放 微信小程序2.26.0 + compressHeight Number - 否 压缩后图片的高度，单位为px，若不填写则默认以 compressedWidth 为准等比缩放 微信小程序2.26.0 + rotate Number 0 否 旋转度数，范围0～360 App 3.0.0+ success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 属性 类型 说明 tempFilePath String 压缩后图片的临时文件路径 uni.compressImage({ src: '/static/logo.jpg', quality: 80, success: res => { console.log(res.tempFilePath) } }) 7.2 文件 7.2.1 uni.chooseFile(OBJECT) 从本地选择文件。 本API主要用于选择非媒体文件，如果选择的文件是媒体文件，另有3个专用API： 图片选择 视频选择 多媒体文件选择(含图片视频) 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 x √(HBuilder X2.9.9+) x(可使用wx.chooseMessageFile) x x x x x x App端如需选择非媒体文件，可在插件市场搜索文件选择，其中Android端可以使用Native.js，无需原生插件，而iOS端需要原生插件。 App端如果想选择下载到_doc、_downloads、_documents等plus.io控制的目录下的文件，可通过plus.io Api，自己做选择框。 选择文件大多为了上传，uni ui封装了更完善的uni-file-picker组件，文件选择、上传到uniCloud的免费存储和cdn中，一站式集成。强烈推荐使用。 OBJECT 参数说明 参数名 类型 默认值 必填 说明 平台差异说明 count Number 100 否 最多可以选择的文件数量 见下方说明 type String 'all' 否 所选的文件的类型 见下方说明 extension Array 否 根据文件拓展名过滤，每一项都不能是空字符串。默认不过滤。 见下方说明 sourceType Array ['album','camera'] 否 （仅在type为image或video时可用）album 从相册选图，camera 使用相机，默认二者都有。如需直接开相机或直接选相册，请只使用一个选项 success Function 是 成功则返回图片的本地文件路径列表 tempFilePaths fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） Tips count 值在 H5 平台的表现，基于浏览器本身的规范。目前测试的结果来看，只能限制单选/多选，并不能限制数量。并且，在实际的手机浏览器很少有能够支持多选的。 sourceType 值在 H5 平台根据浏览器的不同而表现不同，一般不可限制仅使用相册，部分浏览器也无法限制是否使用相机。 extension暂只支持文件后缀名，例如['.zip','.exe','.js']，不支持application/msword等类似值 注：文件的临时路径，在应用本次启动期间可以正常使用，如需持久保存，需在主动调用 uni.saveFile，在应用下次启动时才能访问得到。 OBJECT.type 的合法值 值 说明 all 从所有文件选择 video 只能选择视频文件 image 只能选择图片文件 Tips 如果type属性和extension同时存在，例如{type:'image',extension:['.png','.jpg']}，则会选择image/png,image/jpg文件 如果只配置extension属性，例如{extension:['.doc','.xlsx','.docx']}，则会选择.doc,.xlsx,.docx文件，详情见accept属性 在微信环境中，如果type=\"all\"，则extension属性失效 success 返回参数说明 参数 类型 说明 tempFilePaths Array 文件的本地文件路径列表 tempFiles Array、Array 文件的本地文件列表，每一项是一个 File 对象 File 对象结构如下 参数 类型 说明 path String 本地文件路径 size Number 本地文件大小，单位：B name String 包含扩展名的文件名称，仅H5支持 type String 文件类型，仅H5支持 uni.chooseFile({ count: 6, //默认100 extension:['.zip','.doc'], success: function (res) { console.log(JSON.stringify(res.tempFilePaths)); } }); // 选择图片文件 uni.chooseFile({ count: 10, type: 'image', success (res) { // tempFilePath可以作为img标签的src属性显示图片 const tempFilePaths = res.tempFiles } }) 7.3 录音功能 7.4 背景音频播放管理 7.5 音频组件控制 7.6 视频 7.7 视频组件控制 7.8 相机组件控制 7.9 直播组件控制 7.10 富文本 7.11 音视频合成 8. 设备 8.1 系统 8.1.1 uni.getSystemInfo(OBJECT), uni.getSystemInfoSync(OBJECT) uni-app提供了异步(uni.getSystemInfo)和同步(uni.getSystemInfoSync)的2个API获取系统信息。 按照运行环境层级排序，从底层向上，uni-app有6个概念： device：运行应用的设备，如iphone、huawei os：设备的操作系统，如 ios、andriod、windows、mac、linux rom：基于操作系统的定制，Android系统特有概念，如miui、鸿蒙 host：运行应用的宿主程序，即OS和应用之间的运行环境，如浏览器、微信等小程序宿主、集成uniMPSDK的App。uni-app直接开发的app没有host概念 uni：uni-app框架相关的信息，如uni-app框架的编译器版本、运行时版本 app：开发者的应用相关的信息，如应用名称、版本 OBJECT 参数说明： 参数名 类型 必填 说明 success Function 是 接口调用成功的回调 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） #success 返回参数说明 参数分类 参数getSystemInfoSync 说明 App平台值域 Web平台值域 小程序平台值域 备注 uni框架最低版本要求 device deviceId 设备 id 。由 uni-app 框架生成并存储，清空 Storage 会导致改变 deviceType 设备类型。如phone、pad、pc、unknow 详见 phone、pad、pc、unknow phone、pad、pc uni-app 3.4.10+ deviceBrand 设备品牌。如：apple、huawei 不支持 uni-app 3.4.10+ deviceModel 设备型号 部分设备无法获取 uni-app 3.4.10+ deviceOrientation 设备方向 竖屏 portrait、横屏 landscape 竖屏 portrait、横屏 landscape 竖屏 portrait、横屏 landscape。仅微信百度小程序支持 uni-app 3.4.13+ devicePixelRatio 设备像素比 uni-app 3.4.13+ os osName 系统名称 ios、android ios、android、windows、macos、linux ios、android、windows、macos uni-app 3.4.10+ osVersion 操作系统版本。如 ios 版本，andriod 版本 uni-app 3.4.10+ osLanguage 操作系统语言详见 Android仅支持主语言+地区：zh-CN 中文简体、iOS支持主语言+次语言+地区zh-Hans-CN 中文简体 与浏览器语言一致 不支持 uni-app 3.4.10+ osTheme 操作系统主题 light、dark。iOS平台只有将应用主题设置为跟随系统时才能获取到系统的主题 不支持 不支持 uni-app 3.4.10+ osAndroidAPILevel Android 系统API库的版本。详情参考Android 官方文档 仅 Android 支持 不支持 不支持 uni-app 3.4.10+ rom romName rom 名称 Android 部分机型获取不到值，详见。iOS 不支持 不支持 不支持 uni-app 3.4.13+ romVersion rom 版本 Android 部分机型获取不到值，详见。iOS 不支持 不支持 不支持 uni-app 3.4.13+ browser browserName 浏览器名称或App的webview名称 chrome(android)、wkwebview(ios)、x5webview(app打包x5引擎) chrome、edge、safari、firefox 不支持 uni-app 3.4.10+ browserVersion 浏览器版本、webview 版本 不支持 uni-app 3.4.10+ host hostName 小程序宿主或uniMPSDK的集成宿主名称，如：WeChat、FeiShu 仅 UniMPSDK 支持 不支持 详见 微信小程序真机运行才有真值 uni-app 3.4.10+ hostVersion 宿主版本。如：微信版本号 仅 UniMPSDK 支持 不支持 小程序宿主版本 uni-app 3.4.10+ hostLanguage 宿主语言 仅 UniMPSDK 支持 不支持 小程序宿主语言 uni-app 3.4.10+ hostTheme 宿主主题 light、dark。仅 UniMPSDK 支持 不支持 light、dark。前提是微信小程序全局配置\"darkmode\":true时才能获取 uni-app 3.4.10+ hostFontSizeSetting 用户字体大小设置。以“我-设置-通用-字体大小”中的设置为准，单位：px 不支持 不支持 微信小程序、支付宝小程序、百度小程序、QQ小程序、字节小程序(2.53.0+) uni-app 3.4.13+ hostPackageName 小程序宿主包名 仅 UniMPSDK 支持 不支持 不支持 uni-app 3.4.10+ hostSDKVersion uni小程序SDK版本、小程序客户端基础库版本 仅 UniMPSDK 支持 不支持 uni-app 3.4.13+ uni-app框架 uniPlatform uni-app 运行平台，与条件编译平台相同。详见 app web或h5 各家小程序，如mp-weixin uni-app 3.4.10+ uniCompileVersion uni 编译器版本号。详见 3.4.10、3.2.9 等 3.4.10、3.2.9 等 3.4.10、3.2.9 等 uni-app 3.4.10+ uniRuntimeVersion uni 运行时版本。详见 3.4.10、3.2.9 等 3.4.10、3.2.9 等 3.4.10、3.2.9 等 uni-app 3.4.10+ app appId manifest 中应用appid，即DCloud appid。 uni-app 3.4.10+ appName manifest 中应用名称 和字节跳动小程序字段冲突，字节跳动小程序原字段与hostName一致 uni-app 3.4.10+ appVersion manifest 中应用版本名称。 uni-app 3.4.10+ appVersionCode manifest 中应用版本名号。 uni-app 3.4.10+ appWgtVersion 应用资源（wgt）的版本名称。 uni-app 3.4.15+ appLanguage 应用设置的语言 en、zh-Hans、zh-Hant、fr、es en、zh-Hans、zh-Hant、fr、es en、zh-Hans、zh-Hant、fr、es uni-app 3.4.13+ 其他 ua userAgent标识 不支持 uni-app 3.4.10+ screenWidth 屏幕宽度 screenHeight 屏幕高度 windowWidth 可使用窗口宽度 windowHeight 可使用窗口高度 windowTop 可使用窗口的顶部位置 windowBottom 可使用窗口的底部位置 statusBarHeight 手机状态栏的高度 safeArea 在竖屏正方向下的安全区域。由于此属性理解和使用比较困难，更推荐使用 safeAreaInsets 属性。详见 微信、百度（开发者工具暂不支持，真机有效）、字节跳动、飞书、支付宝（iOS真机）、快手、QQ小程序、华为快应用 safeAreaInsets 在竖屏正方向下的安全区域插入位置。与小程序定义的 safeArea 用途相同，但是规范参考 iOS 平台的 safeAreaInsets 更利于理解和使用。详见 微信、百度（开发者工具暂不支持，真机有效）、字节跳动、飞书、支付宝小程序（iOS真机）、华为快应用 uni-app 2.5.3+ uni.getSystemInfo({ success: function (res) { console.log(res.appName) } }); 8.1.2 uni.getDeviceInfo() 获取设备基础信息 App H5 微信小程序 支付宝小程序 字节跳动小程序 快手小程序 QQ小程序 百度小程序 京东小程序 钉钉小程序 飞书小程序 √ (3.4.13+) √ (3.4.13+) √ (2.20.1+) x x x x x x x x 返回参数说明 参数名 类型 说明 平台差异说明 deviceBrand string 设备品牌。如：apple、huawei H5 不支持 deviceId string 设备 id 。由 uni-app 框架生成并存储，清空 Storage 会导致改变 deviceModel string 设备型号 deviceType string 设备类型phone、pad、pc deviceOrientation string 设备方向 竖屏 portrait、横屏 landscape App、H5。微信小程序请使用 (getSystemInfo Api)[/api/system/info.html] 获取 devicePixelRatio string 设备像素比 App、H5。微信小程序请使用 (getSystemInfo Api)[/api/system/info.html] 获取 system string 操作系统及版本 platform 客户端平台 小程序特殊的返回参数 参数名 类型 说明 平台差异说明 abi String 应用二进制接口类型（仅 Android 支持） 仅微信小程序 benchmarkLevel Number 设备性能等级（仅 Android 支持）。取值为：-2 或 0（该设备无法运行小游戏），-1（性能未知），>=1（设备性能值，该值越高，设备性能越好，目前最高不到50） 仅微信小程序 不推荐使用的返回参数，仅为向下兼容保留 参数名 类型 说明 平台差异说明 brand string 设备品牌 H5 不支持 model string 设备型号。新机型刚推出一段时间会显示unknown，微信会尽快进行适配。 Tips deviceId：android 平台 根据优先使用imei、mac，如果没有获取到就使用随机生成的标识。ios 平台 是直接使用随机生成的标识 8.1.3 uni.getWindowInfo() 获取窗口信息 App H5 微信小程序 支付宝小程序 字节跳动小程序 快手小程序 QQ小程序 百度小程序 京东小程序 钉钉小程序 飞书小程序 √ (3.4.13+) √ (3.4.13+) √ (2.20.1+) x x x x x x x x 返回参数说明 参数名 类型 说明 平台差异说明 pixelRatio number 设备像素比 screenWidth number 屏幕宽度 screenHeight number 屏幕高度 windowWidth number 可使用窗口宽度 windowHeight number 可使用窗口高度 windowTop number 可使用窗口的顶部位置 windowBottom number 可使用窗口的底部位置 statusBarHeight number 手机状态栏的高度 screenTop number 窗口上边缘的 y 值 safeArea object 在竖屏正方向下的安全区域 safeAreaInsets object 在竖屏正方向下的安全区域插入位置 8.1.4 uni.getAppBaseInfo() 获取微信 APP 基础信息 App H5 微信小程序 支付宝小程序 字节跳动小程序 快手小程序 QQ小程序 百度小程序 京东小程序 钉钉小程序 飞书小程序 √ (3.4.13+) √ (3.4.13+) √ (2.20.1+) x x x x x x x x 返回参数说明 参数名 类型 说明 平台差异说明 appId string manifest.json 中应用appid，即DCloud appid。 appName string manifest.json 中应用名称 appVersion string manifest.json 中应用版本名称。 appVersionCode string manifest.json 中应用版本名号。 appLanguage string 应用设置的语言en、zh-Hans、zh-Hant、fr、es App、H5 appWgtVersion string 应用资源（wgt）的版本名称。 App 3.5.5+ hostLanguage string 小程序宿主语言 App 仅 UNIMPSDK 支持、H5 不支持 hostVersion string App、小程序宿主版本。如：微信版本号 App 仅 UNIMPSDK 支持、H5 不支持 hostName string 小程序宿主名称 App 仅 UNIMPSDK 支持、H5 不支持 hostPackageName string 小程序宿主包名 仅 UNIMPSDK 支持 hostSDKVersion string uni小程序SDK版本、小程序客户端基础库版本 App 仅 UNIMPSDK 支持、H5 不支持 hostTheme string 系统当前主题，取值为light或dark。微信小程序全局配置\"darkmode\":true时才能获取，否则为 undefined （不支持小游戏） App 仅 UNIMPSDK 支持、H5 不支持 hostFontSizeSetting string 用户字体大小设置。以“我-设置-通用-字体大小”中的设置为准，单位：px 仅 小程序 支持 小程序特殊的返回参数 参数名 类型 说明 平台差异说明 SDKVersion string 客户端基础库版本 仅微信小程序 enableDebug boolean 是否已打开调试。可通过右上角菜单或 wx.setEnableDebug 打开调试 仅微信小程序 host Object 当前小程序运行的宿主环境 仅微信小程序 theme string 系统当前主题，取值为light或dark，全局配置\"darkmode\":true时才能获取，否则为 undefined （不支持小游戏） 仅微信小程序 8.1.5 uni.getAppAuthorizeSetting() 获取 APP 授权设置 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 钉钉小程序 QQ小程序 快手小程序 京东小程序 HBuilderX (3.5.2+) x 基础库 (2.20.1+) x x x x x x x 返回参数说明 属性 类型 说明 平台差异说明 albumAuthorized 'authorized'/'denied'/'not determined' 允许使用相册的开关 App 端仅 iOS 支持 bluetoothAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许使用蓝牙的开关 App 端仅 iOS 支持 cameraAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许使用摄像头的开关 locationAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许使用定位的开关 locationAccuracy String 定位准确度。\"reduced\" 表示模糊定位；\"full\" 表示精准定位；\"unsupported\" 表示不支持 App 端仅 iOS 支持 microphoneAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许使用麦克风的开关 notificationAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许通知的开关 notificationAlertAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许通知带有提醒的开关 App 端仅 iOS（10.0+）支持 notificationBadgeAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许通知带有标记的开关 App 端仅 iOS（10.0+）支持 notificationSoundAuthorized 'authorized'/'denied'/'not determined'/'config error' 允许通知带有声音的开关 App 端仅 iOS（10.0+）支持 phoneCalendarAuthorized 'authorized'/'denied'/'not determined' 允许读写日历的开关 App 端不支持 不推荐使用的返回参数，仅为兼容保留 |locationReducedAccuracy|boolean|模糊定位。true 表示模糊定位，false 表示精确定位 |App 端仅 iOS 支持| Tips： 'authorized'：表示已经获得授权，无需再次请求授权； 'denied'：表示请求授权被拒绝，无法再次请求授权；（此情况需要引导用户打开系统设置，在设置页中打开权限） 'not determined'：表示尚未请求授权，会在App下一次调用系统相应权限时请求；（仅 iOS 会出现。此种情况下引导用户打开系统设置，不展示开关） 'config error' ：只有在 App 端时返回 bluetoothAuthorized： Android平台不会返回 config error iOS平台：表示没有在 manifest.json -> App模块配置 中配置 BlueTooth(低功耗蓝牙) 模块 cameraAuthorized： Android平台：表示没有授予 android.permission.CAMERA 权限 iOS平台不会返回 config error locationAuthorized： Android平台：表示没有授予 android.permission.ACCESS_COARSE_LOCATION 权限 iOS平台：表示没有在 manifest.json -> App模块配置 中配置 Geolocation(定位) 模块 microphoneAuthorized： Android平台：表示没有授予 android.permission.RECORD_AUDIO 权限 iOS平台不会返回 config error notificationAuthorized、notificationAlertAuthorized、notificationBadgeAuthorized、notificationSoundAuthorized： Android平台不支持 iOS平台：表示没有在 manifest.json -> App模块配置 中配置 Push(推送) 模块 const appAuthorizeSetting = uni.getAppAuthorizeSetting() console.log(appAuthorizeSetting.albumAuthorized) console.log(appAuthorizeSetting.bluetoothAuthorized) console.log(appAuthorizeSetting.cameraAuthorized) console.log(appAuthorizeSetting.locationAuthorized) console.log(appAuthorizeSetting.locationReducedAccuracy) console.log(appAuthorizeSetting.microphoneAuthorized) console.log(appAuthorizeSetting.notificationAlertAuthorized) console.log(appAuthorizeSetting.notificationAuthorized) console.log(appAuthorizeSetting.notificationBadgeAuthorized) console.log(appAuthorizeSetting.notificationSoundAuthorized) console.log(appAuthorizeSetting.phoneCalendarAuthorized) 8.1.6 uni.getSystemSetting() 获取设备设置 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 钉钉小程序 QQ小程序 快手小程序 京东小程序 HBuilderX (3.5.2+) x 基础库 (2.20.1+) x x x x x x x 返回参数说明 属性 类型 说明 bluetoothEnabled boolean 蓝牙的系统开关。当值为 false 时，App端：有可能是配置不正确导致，此时会返回 bluetoothError 属性描述错误。 bluetoothError String App端：Android平台没有权限或者iOS平台模块配置错误时返回字符串，否则不返回此属性。详情见下 locationEnabled boolean 地理位置的系统开关。当值为 false 时，App端：Android平台是准确的；iOS平台有可能是配置不正确导致，此时会返回 locationError 属性描述错误. locationError String App端：Android平台不返回此属性；iOS平台模块配置错误时返回字符串，否则不返回此属性。详情见下 wifiEnabled boolean Wi-Fi 的系统开关 deviceOrientation string 设备方向。竖屏：portrait，横屏：landscape const systemSetting = uni.getSystemSetting() console.log(systemSetting.bluetoothEnabled) console.log(systemSetting.deviceOrientation) console.log(systemSetting.locationEnabled) console.log(systemSetting.wifiEnabled) 8.1.7 uni.openAppAuthorizeSetting() 跳转系统授权管理页 App端 打开系统App的权限设置界面 微信小程序 打开系统微信App的权限设置界面 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 钉钉小程序 QQ小程序 快手小程序 京东小程序 HBuilderX (3.5.3+) x 基础库 (2.20.1+) x x x x x x x OBJECT 参数说明 参数名 类型 必填 说明 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.openAppAuthorizeSetting({ success (res) { console.log(res) } }) 8.2 内存 8.3 网络状态 8.3.1 uni.getNetworkType(OBJECT) 获取网络类型。 OBJECT 参数说明 参数名 类型 必填 说明 success Function 是 接口调用成功，返回网络类型 networkType fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数 说明 networkType 网络类型 networkType 有效值 值 说明 平台差异说明 wifi wifi 网络 2g 2g 网络 3g 3g 网络 4g 4g 网络 5g 5g 网络 ethernet 有线网络 App unknown Android 下不常见的网络类型 none 无网络 uni.getNetworkType({ success: function (res) { console.log(res.networkType); } }); 8.3.2 uni.onNetworkStatusChange(CALLBACK) 监听网络状态变化。可使用uni.offNetworkStatusChange取消监听。 CALLBACK 返回参数 参数 类型 说明 平台差异说明 isConnected Boolean 当前是否有网络连接 字节跳动小程序不支持 networkType String 网络类型 uni.onNetworkStatusChange(function (res) { console.log(res.isConnected); console.log(res.networkType); }); 8.3.3 uni.offNetworkStatusChange(CALLBACK) 取消监听网络状态变化。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 HBuilderX 3.0.1+ HBuilderX 3.0.1+ 基础库 2.9.3+ x x x x √ x Tips CALLBACK必须为调用uni.onNetworkStatusChange时传入的CALLBACK var CALLBACK = function(res) { // ...这里写你的业务逻辑 } uni.offNetworkStatusChange(CALLBACK) uni.onNetworkStatusChange(CALLBACK); 8.4 系统主题 8.5 加速度计 8.6 罗盘 8.7 陀螺仪 8.8 拨打电话 uni.makePhoneCall(OBJECT) OBJECT 参数说明 参数名 类型 必填 说明 phoneNumber String 是 需要拨打的电话号码 success Function 否 接口调用成功的回调 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.makePhoneCall({ phoneNumber: '114' //仅为示例 }); Android需要在 manifest.json 增加权限 Android不弹出询问框直接拨打电话：https://ask.dcloud.net.cn/question/4035 发送短信：http://www.html5plus.org/doc/zh_cn/messaging.html Android读取短信验证码：http://ask.dcloud.net.cn/article/676 Android遍历读取短信：https://ask.dcloud.net.cn/article/12934 注意需要赋予相关权限。 钉钉小程序端拨打电话，详见https://open.dingtalk.com/document/orgapp-client/call-menu 8.9 扫码 uni.scanCode(OBJECT) 调起客户端扫码界面，扫码成功后返回对应的结果。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √ √ √ √ √ OBJECT 参数说明 参数名 类型 必填 说明 平台差异说明 onlyFromCamera Boolean 否 是否只能从相机扫码，不允许从相册选择图片 字节跳动小程序、百度小程序、支付宝小程序不支持此参数 scanType Array 否 扫码类型，参考下方scanType的合法值 字节跳动小程序不支持此参数 autoDecodeCharset Boolean 否 是否启用自动识别字符编码功能，默认为否 App autoZoom Boolean 否 是否启用自动放大，默认启用 仅 App-Android (3.5.4+) 支持 barCodeInput Boolean 否 是否支持手动输入条形码 仅飞书小程序（V3.14.0）支持 hideAlbum Boolean 否 是否隐藏相册（不允许从相册选择图片），只能从相机扫码。默认值为 false。 仅支付宝小程序支持 success Function 否 接口调用成功的回调，返回内容详见返回参数说明。 fail Function 否 接口调用失败的回调函数（识别失败、用户取消等情况下触发） complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） scanType的合法值 值 说明 barCode 一维码 qrCode 二维码 datamatrix Data Matrix 码 pdf417 PDF417 条码 success 返回参数说明 参数 说明 平台差异说明 result 所扫码的内容 scanType 所扫码的类型 App、微信小程序、百度小程序、QQ小程序、京东小程序、支付宝小程序 charSet 所扫码的字符集 App、微信小程序、百度小程序(所扫码的字符集，仅支持 Android 系统)、QQ小程序、京东小程序 path 当所扫的码为当前应用的合法二维码时，会返回此字段，内容为二维码携带的 path。 微信小程序、QQ小程序、京东小程序 rawData 原始数据，base64 编码 微信小程序、QQ小程序、京东小程序、支付宝小程序 code 扫码所得数据 支付宝小程序 qrCode 扫描二维码时返回二维码数据 支付宝小程序 barCode 扫描条形码时返回条形码数据 支付宝小程序 imageChannel 来源 支付宝小程序 // 允许从相机和相册扫码 uni.scanCode({ success: function (res) { console.log('条码类型：' + res.scanType); console.log('条码内容：' + res.result); } }); // 只允许通过相机扫码 uni.scanCode({ onlyFromCamera: true, success: function (res) { console.log('条码类型：' + res.scanType); console.log('条码内容：' + res.result); } }); // 调起条码扫描 uni.scanCode({ scanType: ['barCode'], success: function (res) { console.log('条码类型：' + res.scanType); console.log('条码内容：' + res.result); } }); App-vue如果想自定义扫码，可参考uni-app中如何使用5+的原生界面控件和plus.barcode API App-nvue，支持barcode组件，可自定义扫码界面。详见。App端自定义扫码界面，建议使用nvue方式。 App的扫码引擎，使用业内开源的通用扫码库，扫码效率比不过微信、支付宝等商业扫码库。如需更强的扫码效果，请使用支付宝提供的扫码插件：https://ext.dcloud.net.cn/plugin?id=2636 微信小程序自定义扫码界面，可使用camera组件。详见 微信内嵌浏览器运行H5版时，可通过js sdk实现扫码，需要引入一个单独的js，详见 在扫码界面点击返回也会进入 fail 回调中 支付宝小程序不支持 success 回调中的charSet，path HX 3.4.4之后版本 android 新增 检测到 QR 码时自动放大功能，提升扫码识别率。 8.10 剪贴板 8.10.1 uni.setClipboardData(OBJECT) 设置系统剪贴板的内容。 OBJECT 参数说明 参数名 类型 必填 说明 平台差异说明 data String 是 需要设置的内容 showToast Boolean 否 配置是否弹出提示，默认弹出提示 App (3.2.13+)、H5 (3.2.13+) success Function 否 接口调用成功的回调 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.setClipboardData({ data: 'hello', success: function () { console.log('success'); } }); 8.10.2 uni.getClipboardData(OBJECT) 获取系统剪贴板内容。 OBJECT 参数说明 参数名 类型 必填 说明 success Function 否 接口调用成功的回调 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数 类型 说明 data String 剪贴板的内容 uni.getClipboardData({ success: function (res) { console.log(res.data); } }); 设置剪贴板内容后，小程序平台会自动弹出轻提示；（微信小程序在成功回调success里设置toast可覆盖自带的轻提示）。App平台默认与小程序保持一致策略。如不希望在App平台弹出提示，可使用Native.js自行操作剪贴板，插件市场有封装好的示例https://ext.dcloud.net.cn/plugin?id=712。也可以在设置剪切板后立即uni.hideToast()。 8.11 屏幕亮度 8.12 用户截屏事件 8.12.1 uni.onUserCaptureScreen(CALLBACK) 监听用户主动截屏事件，用户使用系统截屏按键截屏时触发此事件。 CALLBACK返回参数： 属性 类型 说明 path string 截屏文件路径，仅App-Android平台支持 uni.onUserCaptureScreen(function() { console.log('用户截屏了') }); Android的截屏监听原理是监听相册中截屏目录的文件新增，需赋予App本地文件读取权限。 8.12.2 uni.offUserCaptureScreen(function callback) 用户主动截屏事件。取消事件监听。 参数 属性 类型 说明 回调函数 Function 用户主动截屏事件的回调函数 8.13 振动 8.14 手机联系人 8.15 蓝牙 8.16 低功耗蓝牙 8.17 iBeacon 8.18 wifi 8.19 电量 8.20 NFC 8.21 设备方向 8.22 生物认证 生物认证，包含手机的指纹识别、faceid两部分。即通过人体身体特征来进行身份认证识别。 如需要专业的活体检测、人脸识别、金融级实人认证，需另见文档uni实人认证 9. 键盘 9.1 uni.hideKeyboard() 隐藏软键盘 隐藏已经显示的软键盘，如果软键盘没有显示则不做任何操作。 9.2 uni.onKeyboardHeightChange(CALLBACK) 监听键盘高度变化 参数 function listener 键盘高度变化事件的监听函数 参数 Object res 参数 类型 说明 height Number 键盘高度 uni.onKeyboardHeightChange(res => { console.log(res.height) }) 9.3 uni.offKeyboardHeightChange(CALLBACK) 参数 function listener onKeyboardHeightChange 传入的监听函数。不传此参数则移除所有监听函数。 const listener = function (res) { console.log(res) } uni.onKeyboardHeightChange(listener) uni.offKeyboardHeightChange(listener) // 需传入与监听时同一个的函数对象 9.4 uni.getSelectedTextRange(OBJECT) 在input、textarea等focus之后，获取输入框的光标位置。注意：只有在focus的时候调用此接口才有效。目前仅支持 vue 页面，nvue 可以直接使用 weex 的 getSelectionRange。 OBJECT 参数说明： 参数名 类型 默认值 必填 说明 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明： 属性 类型 说明 start Number 输入框光标起始位置 end Number 输入框光标结束位置 uni.getSelectedTextRange({ success: res => { console.log('getSelectedTextRange res', res.start, res.end) } }) 10. 界面 10.1 交互反馈 10.1.1 uni.showToast(OBJECT) 显示消息提示框 OBJECT参数说明 参数 类型 必填 说明 平台差异说明 title String 是 提示的内容，长度与 icon 取值有关。 icon String 否 图标，有效值详见下方说明，默认：success。 image String 否 自定义图标的本地路径（app端暂不支持gif） App、H5、微信小程序、百度小程序 mask Boolean 否 是否显示透明蒙层，防止触摸穿透，默认：false App、微信小程序 duration Number 否 提示的延迟时间，单位毫秒，默认：1500 position String 否 纯文本轻提示显示位置，填写有效值后只有 title 属性生效，且不支持通过 uni.hideToast 隐藏。有效值详见下方说明。 App success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） icon 值说明 值 说明 平台差异说明 success 显示成功图标，此时 title 文本在小程序平台最多显示 7 个汉字长度。 支付宝小程序无长度无限制 error 显示错误图标，此时 title 文本在小程序平台最多显示 7 个汉字长度。 支付宝小程序、快手小程序、字节小程序、百度小程序、京东小程序、QQ小程序不支持 fail 显示错误图标，此时 title 文本无长度显示。 支付宝小程序、字节小程序 exception 显示异常图标。此时 title 文本无长度显示。 支付宝小程序 loading 显示加载图标，此时 title 文本在小程序平台最多显示 7 个汉字长度。 支付宝小程序不支持 none 不显示图标，此时 title 文本在小程序最多可显示两行，App仅支持单行显示。 uni.showToast({ title: '标题', duration: 2000 }); position 值说明（仅App生效） 值 说明 top 居上显示 center 居中显示 bottom 居底显示 App端可通过plus.nativeUI.toast API实现更多功能。 10.1.2 uni.hideToast() 隐藏消息提示框。 uni.hideToast(); 10.1.3 uni.showLoading(OBJECT) 显示 loading 提示框, 需主动调用 uni.hideLoading 才能关闭提示框。 OBJECT参数说明 参数 类型 必填 说明 平台差异说明 title String 是 提示的文字内容，显示在loading的下方 mask Boolean 否 是否显示透明蒙层，防止触摸穿透，默认：false H5、App、微信小程序、百度小程序 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.showLoading({ title: '加载中' }); 10.1.4 uni.hideLoading() 隐藏 loading 提示框。 uni.showLoading({ title: '加载中' }); setTimeout(function () { uni.hideLoading(); }, 2000); 10.1.5 uni.showModal(OBJECT) 显示模态弹窗，可以只有一个确定按钮，也可以同时有确定和取消按钮。类似于一个API整合了 html 中：alert、confirm。 OBJECT参数说明 参数 类型 必填 说明 平台差异说明 title String 否 提示的标题 content String 否 提示的内容 showCancel Boolean 否 是否显示取消按钮，默认为 true cancelText String 否 取消按钮的文字，默认为\"取消\" cancelColor HexColor 否 取消按钮的文字颜色，默认为\"#000000\" H5、微信小程序、百度小程序、字节小程序（2.62.0+） confirmText String 否 确定按钮的文字，默认为\"确定\" confirmColor HexColor 否 确定按钮的文字颜色，H5平台默认为\"#007aff\"，微信小程序平台默认为\"#576B95\"，百度小程序平台默认为\"#3c76ff\" H5、微信小程序、百度小程序、字节小程序（2.62.0+） editable Boolean 否 是否显示输入框 H5 (3.2.10+)、App (3.2.10+)、微信小程序 (2.17.1+)、字节小程序（2.62.0+） placeholderText String 否 显示输入框时的提示文本 H5 (3.2.10+)、App (3.2.10+)、微信小程序 (2.17.1+)、字节小程序（2.62.0+） success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success返回参数说明 参数 类型 说明 平台差异说明 confirm Boolean 为 true 时，表示用户点击了确定按钮 cancel Boolean 为 true 时，表示用户点击了取消（用于 Android 系统区分点击蒙层关闭还是点击取消按钮关闭） content String editable 为 true 时，用户输入的文本 H5 (3.2.10+)、App (3.2.10+)、微信小程序 (2.17.1+)、字节小程序（2.62.0+） uni.showModal({ title: '提示', content: '这是一个模态弹窗', success: function (res) { if (res.confirm) { console.log('用户点击确定'); } else if (res.cancel) { console.log('用户点击取消'); } } }); 弹框同时使用确定取消时，需注意不同平台的确认取消按钮位置不同。在微信、H5中，确认按钮默认在右边。在App中，iOS的确认按钮默认在右边，而Android默认在左边。产生这种差异的原因是uni.showModal在App和小程序上调用的是原生提供的弹出框，原生平台的策略本身就不同。如果需要调整，可以通过自行控制按钮的文字，即“确定”按钮的文字其实可以设置为“取消”； showModal不满足需求时，可以自行开发组件弹框。插件市场有很多自定义弹框的组件，需注意在非H5平台，前端组件无法覆盖原生组件（如地图、video），遮罩也无法盖住tabbar和navigationbar。如需覆盖原生组件或遮罩tabbar等，App端推荐使用subNvue； 小程序平台，cancelText和confirmText有长度限制，最多允许 4 个字符； 钉钉小程序真机与模拟器表现有差异，真机title，content均为必填项 各家小程序平台对于 confirm、cancel 字段返回规则可能不尽相同，包含两种情况：{ confirm: true, cancel: false } 或 { confirm: true }，但并不影响使用 if 去做判断 10.1.6 uni.showActionSheet(OBJECT) 从底部向上弹出操作菜单 OBJECT参数说明 参数 类型 必填 说明 平台差异说明 title String 否 菜单标题 App、H5、支付宝小程序、钉钉小程序、微信小程序 3.4.5+（仅真机有效） alertText String 否 警示文案（同菜单标题） 微信小程序（仅真机有效） itemList Array 是 按钮的文字数组 微信、百度、字节跳动小程序数组长度最大为6个 itemColor HexColor 否 按钮的文字颜色，字符串格式，默认为\"#000000\" App-iOS、字节跳动小程序、飞书小程序不支持 popover Object 否 大屏设备弹出原生选择按钮框的指示区域，默认居中显示 App-iPad（2.6.6+）、H5（2.9.2） success Function 否 接口调用成功的回调函数，详见返回参数说明 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） popover 值说明（仅App生效） 值 类型 说明 top Number 指示区域坐标，使用原生 navigationBar 时一般需要加上 navigationBar 的高度 left Number 指示区域坐标 width Number 指示区域宽度 height Number 指示区域高度 success返回参数说明 参数 类型 说明 tapIndex Number 用户点击的按钮，从上到下的顺序，从0开始 uni.showActionSheet({ itemList: ['A', 'B', 'C'], success: function (res) { console.log('选中了第' + (res.tapIndex + 1) + '个按钮'); }, fail: function (res) { console.log(res.errMsg); } }); App平台，iPad设备支持设置弹出框的位置，详见 plus.nativeUI的文档 App平台，实现原生的、复杂的底部图文菜单，例如分享菜单，可参考https://ext.dcloud.net.cn/plugin?id=69 在非H5端，本章的所有弹出控件都是原生控件，层级最高，可覆盖video、map、tabbar等原生控件。 uni-app插件市场有很多封装好的前端组件，但注意前端组件层级不是最高，无法覆盖原生组件，除非使用cover-view或nvue。 10.2 设置导航条 10.2.1 uni.setNavigationBarTitle(OBJECT) 动态设置当前页面的标题。 OBJECT参数说明 参数 类型 必填 说明 title String 是 页面标题 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.setNavigationBarTitle({ title: '新的标题' }); 如果需要在页面进入时设置标题，可以在onReady内执行，以避免被框架内的修改所覆盖。如果必须在onShow内执行需要延迟一小段时间 10.2.2 uni.setNavigationBarColor(OBJECT) 设置页面导航条颜色。如果需要进入页面就设置颜色，请延迟执行，防止被框架内设置颜色逻辑覆盖 OBJECT参数说明 参数 类型 必填 说明 平台差异说明 frontColor String 是 前景颜色值，包括按钮、标题、状态栏的颜色，仅支持 #ffffff 和 #000000 App、H5、微信小程序、百度小程序、字节跳动小程序、QQ小程序、快手小程序、京东小程序 backgroundColor String 是 背景颜色值，有效值为十六进制颜色 animation Object 否 动画效果，{duration,timingFunc} 微信小程序、百度小程序、QQ小程序、快手小程序、京东小程序 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） Android 上的 backgroundColor 参数有限制，黑色大于 rgb(30,30,30), 白色小于 rgb(235,235,235) 如果需要在页面进入时设置标题，可以在onReady内执行，以避免被框架内的修改所覆盖。如果必须在onShow内执行需要延迟一小段时间 animation 结构 属性 类型 默认值 必填 说明 duration number 0 否 动画变化时间，单位 ms timingFunc String 'linear' 否 动画变化方式 animation.timingFunc 有效值 值 说明 linear 动画从头到尾的速度是相同的。 easeIn 动画以低速开始 easeOut 动画以低速结束。 easeInOut 动画以低速开始和结束。 success返回参数说明 参数名 类型 说明 errMsg String 调用结果 uni.setNavigationBarColor({ frontColor: '#ffffff', backgroundColor: '#ff0000', animation: { duration: 400, timingFunc: 'easeIn' } }) 10.2.3 uni.showNavigationBarLoading(OBJECT) 在当前页面显示导航条加载动画。 App平台调用此API时会在屏幕中间悬浮显示loading OBJECT参数说明 参数 类型 必填 说明 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.showNavigationBarLoading() 10.2.4 uni.hideNavigationBarLoading(OBJECT) 在当前页面隐藏导航条加载动画。 App平台调用此API时会关闭屏幕中间悬浮显示的loading OBJECT参数说明 参数 类型 必填 说明 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.hideNavigationBarLoading() 10.2.5 uni.hideHomeButton(OBJECT) 隐藏返回首页按钮。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 x x √ x x 1.48.0+ 1.10.0+ x √ OBJECT参数说明 参数 类型 必填 说明 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.hideHomeButton() 微信小程序自基础库版本2.8.3开始支持 当用户打开的小程序最底层页面是非首页时，默认展示“返回首页”按钮，开发者可在页面onShow中调用hideHomeButton进行隐藏。 10.3 设置TabBar 10.3.1 uni.setTabBarItem(OBJECT) 动态设置 tabBar 某一项的内容 OBJECT参数说明： 属性 类型 默认值 必填 说明 平台差异 index number 是 tabBar 的哪一项，从左边算起 text String 否 tab 上的按钮文字 iconPath String 否 图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，当 position 为 top 时，此参数无效。微信小程序 2.7.0+、支付宝小程序支持网络图片，其他平台暂不支持网络图片 selectedIconPath String 否 选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px ，当 position 为 top 时，此参数无效 pagePath String 否 页面绝对路径，必须在 pages 中先定义，被替换掉的 pagePath 不会变成普通页面（仍然需要使用 uni.switchTab 跳转） App（2.8.4+）、H5（2.8.4+） visible Boolean true 否 该项是否显示 App（3.2.10+）、H5（3.2.10+） iconfont Object 否 字体图标，优先级高于 iconPath App（3.4.4+） success Funtion 否 接口调用成功的回调函数 fail Funtion 否 接口调用失败的回调函数 complete Funtion 否 接口调用结束的回调函数（调用成功、失败都会执行） iconfont参数说明： 属性 类型 说明 text String 字库 Unicode 码 selectedText String 选中后字库 Unicode 码 fontSize String 字体图标字号(px) color String 字体图标颜色 selectedColor String 字体图标选中颜色 uni.setTabBarItem({ index: 0, text: 'text', iconPath: '/path/to/iconPath', selectedIconPath: '/path/to/selectedIconPath' }) 注意: 设置 iconfont 属性时，pages.json iconfontSrc 需要指定字体文件，参考下面的配置 // pages.json { \"tabBar\": { \"iconfontSrc\":\"static/iconfont.ttf\", \"list\": [ { \"pagePath\": \"pages/index/index\", \"text\": \"Tab1\", \"iconfont\": { \"text\": \"\\ue102\", \"selectedText\": \"\\ue103\", \"fontSize\": \"17px\", \"color\": \"#000000\", \"selectedColor\": \"#0000ff\" } } ] } } 10.3.2 uni.setTabBarStyle(OBJECT) 动态设置 tabBar 的整体样式 OBJECT参数说明： 属性 类型 默认值 必填 说明 color String 否 tab 上的文字默认颜色，HexColor selectedColor String 否 tab 上的文字选中时的颜色，HexColor backgroundColor String 否 tab 的背景色，HexColor backgroundImage String 否 图片背景。支持设置本地图片或创建线性渐变如，优先级高于 backgroundColor，仅 App 2.7.1+ 支持 backgroundRepeat String 否 背景图平铺方式。repeat：背景图片在垂直方向和水平方向平铺；repeat-x：背景图片在水平方向平铺，垂直方向拉伸；repeat-y：背景图片在垂直方向平铺，水平方向拉伸；no-repeat：背景图片在垂直方向和水平方向都拉伸。 默认使用 no-repeat。仅 App 2.7.1+ 支持 borderStyle String 否 tabBar上边框的颜色， 仅支持 black/white midButton Object 否 中间按钮 仅在 list 项为偶数时有效 详情。HBuilderX 3.6.9+ success Funtion 否 接口调用成功的回调函数 fail Funtion 否 接口调用失败的回调函数 complete Funtion 否 接口调用结束的回调函数（调用成功、失败都会执行） backgroundImage创建线性渐变说明 backgroundImage: linear-gradient(to top, #a80077, #66ff00); 目前暂不支持 radial-gradient（径向渐变）。 目前只支持两种颜色的渐变，渐变方向如下： to right：从左向右渐变 to left：从右向左渐变 to bottom：从上到下渐变 to top：从下到上渐变 to bottom right：从左上角到右下角 to top left：从右下角到左上角 uni.setTabBarStyle({ color: '#FF0000', selectedColor: '#00FF00', backgroundColor: '#0000FF', borderStyle: 'white' }) 10.3.3 uni.hideTabBar(OBJECT) 隐藏 tabBar OBJECT参数说明： 属性 类型 默认值 必填 说明 animation boolean false 否 是否需要动画效果，仅微信小程序、支付宝小程序、百度小程序、字节跳动小程序、飞书小程序、QQ小程序、快手小程序、京东小程序支持 success Funtion 否 接口调用成功的回调函数 fail Funtion 否 接口调用失败的回调函数 complete Funtion 否 接口调用结束的回调函数（调用成功、失败都会执行） 10.3.4 uni.showTabBar(OBJECT) 显示 tabBar OBJECT参数说明： 属性 类型 默认值 必填 说明 animation boolean false 否 是否需要动画效果，仅微信小程序、支付宝小程序、百度小程序、字节跳动小程序、飞书小程序、QQ小程序、快手小程序、京东小程序支持 success Funtion 否 接口调用成功的回调函数 fail Funtion 否 接口调用失败的回调函数 complete Funtion 否 接口调用结束的回调函数（调用成功、失败都会执行） 10.3.5 uni.setTabBarBadge(OBJECT) 为 tabBar 某一项的右上角添加文本。 OBJECT参数说明： 参数 类型 必填 说明 index Number 是 tabBar的哪一项，从左边算起 text String 是 显示的文本，不超过 3 个半角字符 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.setTabBarBadge({ index: 0, text: '1' }) 10.3.6 uni.removeTabBarBadge(OBJECT) 移除 tabBar 某一项右上角的文本。 OBJECT参数说明： 参数 类型 必填 说明 index Number 是 tabBar的哪一项，从左边算起 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 10.3.7 uni.showTabBarRedDot(OBJECT) 显示 tabBar 某一项的右上角的红点。 OBJECT参数说明： 参数 类型 必填 说明 index Number 是 tabBar的哪一项，从左边算起 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 10.3.8 uni.hideTabBarRedDot(OBJECT) 隐藏 tabBar 某一项的右上角的红点。 OBJECT参数说明： 参数 类型 必填 说明 index Number 是 tabBar的哪一项，从左边算起 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 10.3.9 uni.onTabBarMidButtonTap(CALLBACK) 监听中间按钮的点击事件 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √（HBuilderX 2.3.4+） √ x x x x x x x tabbar是原生的，层级高于前端元素 uni-app插件市场有封装的前端tabbar，但性能不如原生tabbar 如果想要一个中间带+号的tabbar，在HBuilderX中新建uni-app项目、选择 底部选项卡 模板 以上大部分操作 tabbar 的 API 需要在 tabbar 渲染后才能使用，避免在 tabbar 未初始化前使用 10.4 页面背景 10.4.1 uni.setBackgroundColor(OBJECT) 动态设置窗口的背景色。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 x x √ x √ x √ √ √ 参数说明 属性 类型 默认值 必填 说明 backgroundColor String 否 窗口的背景色，必须为十六进制颜色值 backgroundColorTop String 否 顶部窗口的背景色，必须为十六进制颜色值，仅 iOS 支持 backgroundColorBottom String 否 底部窗口的背景色，必须为十六进制颜色值，仅 iOS 支持 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.setBackgroundColor({ backgroundColor: '#ffffff', backgroundColorTop: '#222222', backgroundColorBottom: '#333333' }); 10.4.2 uni.setBackgroundTextStyle(OBJECT) 动态设置下拉背景字体、loading 图的样式。 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 x x √ x √ x √ √ √ 参数说明 属性 类型 必填 说明 textStyle String 是 下拉背景字体、loading 图的样式，值为：dark、light success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.setBackgroundTextStyle({ textStyle: 'dark' // 下拉背景字体、loading 图的样式为dark }) 10.5 动画 10.5.1 uni.createAnimation(OBJECT) 用到再看。 10.6 页面滚动 10.5.2 uni.pageScrollTo(OBJECT) 将页面滚动到目标位置。 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 华为快应用 360小程序 √(nvue不支持) √ √ √ √ √ √ √ √ OBJECT参数说明 参数名 类型 必填 说明 scrollTop Number 否 滚动到页面的目标位置（单位px） selector String 否 选择器，App、H5、微信小程序2.7.3+ 、支付宝小程序1.20.0+支持 duration Number 否 滚动动画的时长，默认300ms，单位 ms success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） selector 语法 selector类似于 CSS 的选择器，但仅支持下列语法。 ID选择器：#the-id class选择器（可以连续指定多个）：.a-class.another-class 子元素选择器：.the-parent > .the-child 后代选择器：.the-ancestor .the-descendant 跨自定义组件的后代选择器：.the-ancestor >>> .the-descendant 多选择器的并集：#a-node, .some-other-nodes uni.pageScrollTo({ scrollTop: 0, duration: 300 }); ​ 10.6 窗口尺寸变化 10.6.1 uni.onWindowResize(CALLBACK) 监听窗口尺寸变化事件 平台差异说明 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序 飞书小程序 QQ小程序 √ √ √ x x x √ √ CALLBACK 参数说明 属性 类型 说明 size Object 变化后的窗口的大小，单位为 px ，{windowWidth,windowHeight} const windowResizeCallback = (res) => { console.log('变化后的窗口宽度=' + res.size.windowWidth) console.log('变化后的窗口高度=' + res.size.windowHeight) } uni.onWindowResize(windowResizeCallback) 如App端设置软键盘弹出方式为adjustResize ，则在键盘弹出时，会触发此事件。 横竖屏切换时，会触发此事件。 10.6.2 uni.offWindowResize(CALLBACK) 取消监听窗口尺寸变化事件 CALLBACK为调用uni.onWindowResize时传入的CALLBACK uni.offWindowResize(windowResizeCallback) 10.7 窗口样式相关的 API 10.8 字体 动态加载网络字体，文件地址需为下载类型。微信小程序 '2.10.0'起支持全局生效，需在 app.vue 中调用。 引入中文字体，体积过大时会发生错误，建议抽离出部分中文，减少体积，或者用图片替代 微信小程序端只支持网络字体，字体链接必须是https。App支持网络或本地的字体（本地字体需使用平台绝对路径）。 微信小程序端字体链接必须是同源下的，或开启了cors支持，微信小程序的域名是servicewechat.com 工具里提示 Faild to load font可以忽略 nvue不支持。nvue使用 Weex 提供的 DOM.addRule 加载自定义字体，详见 插件市场有加载字体的例子：https://ext.dcloud.net.cn/plugin?id=954 5+App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 1.9.0+ 2.3.4+ 基础库 2.1.0+ 1.11.0+ x x x 参数说明 属性 类型 默认值 必填 说明 global Boolean false 否 是否全局生效 family String 是 定义的字体名称 source String 是 字体资源的地址。建议格式为 TTF 和 WOFF，WOFF2 在低版本的iOS上会不兼容。 desc Object 否 可选的字体描述符 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） Object.desc 的结构 属性 类型 默认值 必填 说明 style String normal 否 字体样式，可选值为 normal / italic / oblique weight String normal 否 字体粗细，可选值为 normal / bold / 100 / 200../ 900 variant String normal 否 设置小型大写字母的字体显示文本，可选值为 normal / small-caps / inherit uni.loadFontFace({ family: 'Bitstream Vera Serif Bold', source: 'url(\"https://sungd.github.io/Pacifico.ttf\")', success() { console.log('success') } }) 10.9 下拉刷新 10.9.1 onPullDownRefresh 在 js 中定义 onPullDownRefresh 处理函数（和onLoad等生命周期函数同级），监听该页面用户下拉刷新事件。 需要在 pages.json 里，找到的当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh。 当处理完数据刷新后，uni.stopPullDownRefresh 可以停止当前页面的下拉刷新。 10.9.2 uni.startPullDownRefresh(OBJECT) 开始下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。 OBJECT 参数说明 参数名 类型 必填 说明 success Function 否 接口调用成功的回调 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明 参数 类型 说明 errMsg String 接口调用结果 10.9.3 uni.stopPullDownRefresh() 停止当前页面下拉刷新。 // pages.json { \"pages\": [ { \"path\": \"pages/index/index\", \"style\": { \"navigationBarTitleText\": \"uni-app\", \"enablePullDownRefresh\": true } } ], \"globalStyle\": { \"navigationBarTextStyle\": \"white\", \"navigationBarBackgroundColor\": \"#0faeff\", \"backgroundColor\": \"#fbf9fe\" } } // 仅做示例，实际开发中延时根据需求来使用。 export default { data() { return { text: 'uni-app' } }, onLoad: function (options) { setTimeout(function () { console.log('start pulldown'); }, 1000); uni.startPullDownRefresh(); }, onPullDownRefresh() { console.log('refresh'); setTimeout(function () { uni.stopPullDownRefresh(); }, 1000); } } 支付宝小程序startPullDownRefresh在开发者工具里会提示暂未开放，请勿使用 支付宝小程序startPullDownRefresh请使用真机调试（非真机预览） 后续支付宝小程序开发工具更新可能会有所修改 FAQ Q：如何暂时禁用掉下拉刷新，待需要的时候再重新开启？ A：App 平台下可以处理此类场景，详细参考：uni-app 中实现动态禁用/开启下拉刷新 Q：自定义title如何让下拉刷新在title之下 A：App和H5端使用circle方式的下拉刷新，设offset在title高度之下。hello uni-app的模板-导航栏中有示例。小程序端无法实现，除非放弃原生下拉刷新，自己模拟下拉刷新，插件市场有类似插件，但性能不如原生下拉刷新。 Q：如何自定义下拉刷新样式 A：小程序端的原生下拉刷新样式是固定的；App端原生的下拉刷新有2种样式可选择，下拉漏出雪花和下拉circle圈。如果使用nvue，可以使用refresh组件自定义下拉刷新，都是原生渲染。如果想使用scroll-view在前端实现自定义下拉刷新，需要注意列表不可太长和太复杂，否则会有性能问题。插件市场搜索下拉刷新有示例。 10.10 节点信息 10.10.1 uni.createSelectorQuery() 返回一个 SelectorQuery 对象实例。可以在这个实例上使用 select 等方法选择节点，并使用 boundingClientRect 等方法选择需要查询的信息。 使用 uni.createSelectorQuery() 需要在生命周期 mounted 后进行调用。 默认需要使用到 selectorQuery.in 方法。 const query = uni.createSelectorQuery().in(this); query.select('#id').boundingClientRect(data => { console.log(\"得到布局位置信息\" + JSON.stringify(data)); console.log(\"节点离页面顶部的距离为\" + data.top); }).exec(); 10.10.2 selectorQuery.select(selector) 在当前页面下选择第一个匹配选择器 selector 的节点，返回一个 NodesRef 对象实例，可以用于获取节点信息。 selector 类似于 CSS 的选择器，但仅支持下列语法。 ID选择器：#the-id class选择器（可以连续指定多个）：.a-class.another-class 子元素选择器：.the-parent > .the-child 后代选择器：.the-ancestor .the-descendant 跨自定义组件的后代选择器：.the-ancestor >>> .the-descendant 多选择器的并集：#a-node, .some-other-nodes 10.10.3 selectorQuery.selectAll(selector) 在当前页面下选择匹配选择器 selector 的所有节点，返回一个 NodesRef 对象实例，可以用于获取节点信息。 10.10.4 selectorQuery.selectViewport() 选择显示区域，可用于获取显示区域的尺寸、滚动位置等信息，返回一个 NodesRef 对象实例。 10.10.5 selectorQuery.exec(callback) 执行所有的请求。请求结果按请求次序构成数组，在callback的第一个参数中返回。 10.10.6 nodesRef.fields(object,callback) 获取节点的相关信息。第一个参数是节点相关信息配置（必选）；第二参数是方法的回调函数，参数是指定的相关节点信息。 object 参数说明 字段名 类型 默认值 必填 说明 平台差异说明 id Boolean false 否 是否返回节点 id dataset Boolean false 否 是否返回节点 dataset App、微信小程序、H5 rect Boolean false 否 是否返回节点布局位置（left right top bottom） size Boolean false 否 是否返回节点尺寸（width height） scrollOffset Boolean false 否 是否返回节点的 scrollLeft scrollTop，节点必须是 scroll-view 或者 viewport properties Array＜string＞ [] 否 指定属性名列表，返回节点对应属性名的当前属性值（只能获得组件文档中标注的常规属性值，id class style 和事件绑定的属性值不可获取） 仅 App 和微信小程序支持 computedStyle Array＜string＞ [] 否 指定样式名列表，返回节点对应样式名的当前值 仅 App 和微信小程序支持 context Boolean false 否 是否返回节点对应的 Context 对象 仅 App 和微信小程序支持 10.10.7 nodesRef.boundingClientRect(callback) 添加节点的布局位置的查询请求。相对于显示区域，以像素为单位。其功能类似于 DOM 的 getBoundingClientRect。返回 NodesRef 对应的 SelectorQuery。 callback 返回参数 属性 类型 说明 id String 节点的 ID dataset Object 节点的 dataset left Number 节点的左边界坐标 right Number 节点的右边界坐标 top Number 节点的上边界坐标 bottom Number 节点的下边界坐标 width Number 节点的宽度 height Number 节点的高度 10.10.8 nodesRef.scrollOffset(callback) 添加节点的滚动位置查询请求。以像素为单位。节点必须是 scroll-view 或者 viewport。返回 NodesRef 对应的 SelectorQuery。 callback 返回参数 属性 类型 说明 id String 节点的 ID dataset Object 节点的 dataset scrollLeft Number 节点的水平滚动位置 scrollTop Number 节点的竖直滚动位置 10.10.9 nodesRef.context(callback) 添加节点的 Context 对象查询请求。支持 VideoContext、CanvasContext、和 MapContext 等的获取。 callback 返回参数 属性 类型 说明 context Object 节点对应的 Context 对象 10.10.10 nodesRef.node(callback) 获取 Node 节点实例。目前支持 Canvas 的获取。 callback 返回参数 属性 类型 说明 node Object 节点对应的 Node 实例 注意 目前仅能用于canvas canvas需设置type=\"webgl\"才能正常使用 uni.createSelectorQuery().selectViewport().scrollOffset(res => { console.log(\"竖直滚动位置\" + res.scrollTop); }).exec(); let view = uni.createSelectorQuery().in(this).select(\".test\"); view.fields({ size: true, scrollOffset: true }, data => { console.log(\"得到节点信息\" + JSON.stringify(data)); console.log(\"节点的宽为\" + data.width); }).exec(); view.boundingClientRect(data => { console.log(\"得到布局位置信息\" + JSON.stringify(data)); console.log(\"节点离页面顶部的距离为\" + data.top); }).exec(); nvue 暂不支持 uni.createSelectorQuery，暂时使用下面的方案 Width: Height: Top: Bottom: Left: Right: // 注意平台差异 // #ifdef APP-NVUE const dom = weex.requireModule('dom') // #endif export default { data () { return { size: { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 } } }, onReady() { setTimeout(()=> { const result = dom.getComponentRect(this.$refs.box, option => { console.log('getComponentRect:', option) this.size = option.size }) console.log('return value:', result) console.log('viewport:', dom.getComponentRect('viewport')) }, 100); } } 10.11 监听节点布局相关 可以解决一些性能问题, 用到再看。 10.12 媒体查询 10.13 菜单 10.14 语言 10.14.1 uni.getLocale() 获取当前设置的语 如果当前应用设置过语言，会获取到之前设置的语言，未设置时会返回根据系统语言类型自动选择的语言。 10.14.2 uni.setLocale(locale) 设置当前语言 仅可设置为框架内置语言与自定义扩展的语言，遵循 BCP47 规范。 10.14.3 uni.onLocaleChange(callback) 用于监听应用语言切换 callback返回参数说明 参数名 类型 说明 locale String 当前语言 组件和接口显示会根据设置的语言环境自动切换，未支持的系统语言环境会显示为英文。 App-Android、App-iOS 平台修改系统语言后会重启应用。 App-Android 平台设置新的语言后会自动重启应用。 框架内置如下语言，如需自定义内容或增加其他语言参考：自定义国际化内容 英语 en 中文简体 zh-Hans 繁体 zh-Hant 法语 fr 西班牙语 es 在 manifest.json -> locale 可以配置应用的默认语言。 仅 3.1.5 - 3.2.4 版本会自动使用 vue-i18n 内配置的语言。 在小程序平台仅影响用户业务层（vue-i18n）的语言配置，不能影响小程序原生组件和接口的语言。 11. 文件 11.1 uni.saveFile(OBJECT) 保存文件到本地。 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √ √ √ x √ 注意：saveFile 会把临时文件移动，因此调用成功后传入的 tempFilePath 将不可用 OBJECT 参数说明： 参数名 类型 必填 说明 tempFilePath String 是 需要保存的文件的临时路径 success Function 否 返回文件的保存路径，res = {savedFilePath: '文件的保存路径'} fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明： 参数 说明 savedFilePath 文件的保存路径 uni.chooseImage({ success: function (res) { var tempFilePaths = res.tempFilePaths; uni.saveFile({ tempFilePath: tempFilePaths[0], success: function (res) { var savedFilePath = res.savedFilePath; } }); } }); 11.2 uni.getSavedFileList(OBJECT) 获取本地已保存的文件列表。 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √ √ √ x √ OBJECT 参数说明： 参数名 类型 必填 说明 success Function 否 接口调用成功的回调函数，返回结果见 success 返回参数说明 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明： 参数 类型 说明 errMsg String 接口调用结果 fileList Array 文件列表 fileList 中的项目说明： 键 类型 说明 filePath String 文件的本地路径 createTime Number 文件的保存时的时间戳，从 1970/01/01 08:00:00 到该时刻的秒数。 size Number 文件大小，以字节为单位。 uni.getSavedFileList({ success: function (res) { console.log(res.fileList); } }); 11.3 uni.getSavedFileInfo(OBJECT) 获取本地文件的文件信息。此接口只能用于获取已保存到本地的文件。 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √ x √ x √ OBJECT 参数说明： 参数名 类型 必填 说明 filePath String 是 文件路径 success Function 否 接口调用成功的回调函数，返回结果见 success 返回参数说明 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明： 参数 类型 说明 errMsg String 接口调用结果 size Number 文件大小，以字节为单位。 createTime Number 文件保存时的时间戳，从 1970/01/01 08:00:00 到该时刻的秒数。 uni.getSavedFileInfo({ filePath: 'unifile://somefile', //仅做示例用，非真正的文件路径 success: function (res) { console.log(res.size); console.log(res.createTime); } }); 11.4 uni.removeSavedFile(OBJECT) 删除本地存储的文件。 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √ √ √ x √ OBJECT 参数说明： 参数名 类型 必填 说明 filePath String 是 需要删除的文件路径 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.getSavedFileList({ success: function (res) { if (res.fileList.length > 0) { uni.removeSavedFile({ filePath: res.fileList[0].filePath, complete: function (res) { console.log(res); } }); } } }); 11.5 uni.getFileInfo(OBJECT) App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ √ √ √ √ √ √ x √ OBJECT 参数说明： 参数名 类型 默认值 必填 说明 平台差异说明 filePath String 是 本地文件路径 digestAlgorithm String md5 否 计算文件摘要的算法，可取值 md5、sha1。 微信小程序、京东小程序、App 2.9.0+ success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回参数说明： 参数 类型 说明 平台差异说明 errMsg String 接口调用结果 size Number 文件大小，以字节为单位。 digest String 按照传入的 digestAlgorithm 计算得出的的文件摘要 微信小程序、京东小程序、App 2.9.0+ 11.6 uni.openDocument(OBJECT) 新开页面打开文档，支持格式：doc, xls, ppt, pdf, docx, xlsx, pptx。 App H5 微信小程序 支付宝小程序 百度小程序 字节跳动小程序、飞书小程序 QQ小程序 快手小程序 京东小程序 √ x √ √ √ √ √ x √ OBJECT 参数说明： 参数名 类型 必填 说明 平台差异说明 filePath String 是 文件路径，可通过 downFile 获得 fileType String 支付宝小程序必填，其他平台非必填 文件类型，指定文件类型打开文件，有效值 doc, xls, ppt, pdf, docx, xlsx, pptx，支付宝小程序仅支持pdf 微信小程序、支付宝小程序、京东小程序 showMenu Boolean 否 右上角是否有可以转发分享的功能 微信小程序 success String 否 接口调用成功的回调函数 fail String 否 接口调用失败的回调函数 微信小程序、京东小程序 complete String 否 接口调用结束的回调函数（调用成功、失败都会执行） uni.downloadFile({ url: 'https://example.com/somefile.pdf', success: function (res) { var filePath = res.tempFilePath; uni.openDocument({ filePath: filePath, showMenu: true, success: function (res) { console.log('打开文档成功'); } }); } }); 平台 打开方式 小程序 在小程序的入口应用内打开 App iOS 在当前应用内打开 App Android 调用系统相关应用打开，无相关应用则不能打开 H5 使用浏览器打开，当前浏览器不支持则不能打开 App端，io操作还可以用更强大的plus.io API。https://www.html5plus.org/doc/zh_cn/io.html App端，打开各种格式的文件，如office、pdf等，还可以用更强大的三方插件，详见插件市场 选择文件上传，uni-app有自带的api：uni.chooseImage和uni.chooseVideo。App端如需选择非媒体文件，可在插件市场搜索文件选择，其中Android端可以使用Native.js，无需原生插件，而iOS端需要原生插件。 12. 绘画 13. 广告 14. 第三方服务 14.1 获取服务提供商 uni.getProvider(OBJECT) 获取服务供应商。 在App平台，可用的服务商，是打包环境中配置的服务商，与手机端是否安装了该服务商的App没有关系。 云打包在manifest中配置相关模块和SDK信息，离线打包在原生工程中配置。某个服务商配置被打包进去，运行时就能得到相应的服务供应商。 14.2 登录 14.3 分享 14.4 支付 14.5 消息推送 14.6 语音 14.7 实人认证 14.8 一键生成iOS通用链接 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-27 17:08:06 "},"webend/vite.html":{"url":"webend/vite.html","title":"vite","keywords":"","body":"I>相关文章 Vite 插件开发实践：微前端的资源处理 关于常用构建工具的一些总结 element-plus按需（自动）引用的配置方法 Vite+Vue项目添加sass预处理器 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-01-13 16:57:51 "},"webend/vscode.html":{"url":"webend/vscode.html","title":"vscode","keywords":"","body":"Settings Sync 配置与使用 Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-11-16 10:19:36 "},"webend/Vue2X.html":{"url":"webend/Vue2X.html","title":"Vue2X","keywords":"","body":"Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2022-09-20 10:27:00 "},"webend/Vue3X.html":{"url":"webend/Vue3X.html","title":"Vue3X","keywords":"","body":"相关网站 Vue3官网 Vue3官网手册 Vue3 API Vue3 在线编辑 Vue2到Vue3迁移文档 Vue Router 官方状态管理库 - Pinia 官网推荐打包工具 - Vite Vue CLI createApp 每个 Vue 应用都是通过 createApp 函数创建一个新的应用实例 //定义 function createApp(rootComponent: Component, rootProps?: object): App //创建新的应用实例 import { createApp } from 'vue'; const app = createApp({ /* 根组件选项 */ }); //或者import根组件, 传入createApp import { createApp } from 'vue'; import App from './App.vue'; const app = createApp(App); app.mount() 参数可以是一个实际的 DOM 元素或一个 CSS 选择器 (使用第一个匹配到的元素)。返回根组件的实例。 如果该组件有模板或定义了渲染函数，它将替换容器内所有现存的 DOM 节点。否则在运行时编译器可用的情况下，容器元素的 innerHTML 将被用作模板。 对于每个应用实例，mount() 仅能调用一次。 //定义 interface App { mount(rootContainer: Element | string): ComponentPublicInstance } import { createApp } from 'vue'; const app = createApp(/* ... */); //使用css选择器 app.mount('#app'); //也可以挂载到一个实际的 DOM 元素。 app.mount(document.body.firstChild); //例如下述demo, createApp没有定义template和渲染函数, 所以app挂在后, 会使用#app内的innerHTML作为模板 import { createApp } from 'vue'; const app = createApp({ data() { return { count: 0 } } }); app.mount('#app'); app.unmount() 卸载一个已挂载的应用实例。卸载一个应用会触发该应用组件树内所有组件的卸载生命周期钩子。 //定义 interface App { unmount(): void } app.version 提供当前应用所使用的 Vue 版本号。这在插件中很有用，因为可能需要根据不同的 Vue 版本执行不同的逻辑。 //定义 interface App { version: string } export default { install(app) { const version = Number(app.version.split('.')[0]); if (version app.config 每个应用实例都会暴露一个 config 对象，其中包含了对这个应用的配置设定。你可以在挂载应用前更改这些属性 (下面列举了每个属性的对应文档)。 import { createApp } from 'vue'; const app = createApp(/* ... */); console.log(app.config); app.config.errorHandler 用于为应用内抛出的未捕获错误指定一个全局处理函数。 //定义 interface AppConfig { errorHandler?: ( err: unknown, //错误对象 instance: ComponentPublicInstance | null, //触发该错误的组件实例 info: string //一个指出错误来源类型信息的字符串 ) => void } app.config.errorHandler = (err, instance, info) => { // 处理错误，例如：报告给一个服务 }; app.config.warnHandler 用于为 Vue 的运行时警告指定一个自定义处理函数。 //定义 interface AppConfig { warnHandler?: ( msg: string, //警告信息 instance: ComponentPublicInstance | null, //来源组件实例 trace: string //组件追踪字符串 ) => void } app.config.warnHandler = (msg, instance, trace) => { // `trace` is the component hierarchy trace }; app.config.performance 设置此项为 true 可以在浏览器开发工具的“性能/时间线”页中启用对组件初始化、编译、渲染和修补的性能表现追踪。仅在开发模式和支持 performance.mark API 的浏览器中工作。 app.config.compilerOptions 配置运行时编译器的选项。设置在此对象上的值将会在浏览器内进行模板编译时使用，并会影响到所配置应用的所有组件。另外你也可以通过 compilerOptions 选项在每个组件的基础上覆盖这些选项。 脚手架的项目需要在脚手架中配置 app.config.compilerOptions.isCustomElement 如果该标签需要当作原生自定义元素则应返回 true。对匹配到的标签，Vue 会将其渲染为原生元素而非将其视为一个 Vue 组件来解析。 //将所有标签前缀为 `ion-` 的标签视为自定义元素 app.config.compilerOptions.isCustomElement = (tag) => { return tag.startsWith('ion-') } app.config.compilerOptions.whitespace 用于调整模板中空格的处理行为 condense | preserve, 默认condense app.config.compilerOptions.whitespace = 'preserve'; app.config.compilerOptions.delimiters 类型 [string, string] 默认 [', '] 此项通常是为了避免与同样使用 mustache 语法的服务器端框架发生冲突。 // 分隔符改为ES6模板字符串样式 app.config.compilerOptions.delimiters = ['${', '}']; app.config.compilerOptions.comments 类型 boolean 默认 false 默认情况下，Vue 会在生产环境移除所有注释，设置该项为 true 会强制 Vue 在生产环境也保留注释。 app.config.compilerOptions.comments = true; app.config.globalProperties 一个用于注册能够被应用内所有组件实例访问到的全局属性的对象。 这是对 Vue 2 中 Vue.prototype 使用方式的一种替代，此写法在 Vue 3 已经不存在了。 如果全局属性与组件自己的属性冲突，组件自己的属性将具有更高的优先级。 //定义 interface AppConfig { globalProperties: Record } app.config.globalProperties.msg = 'hello'; export default { mounted() { const _self = this; console.log(_self.msg); // 'hello' } } app.config.optionMergeStrategies app.provide() 提供一个值，可以在应用中的所有后代组件中注入使用。 第一个参数是注入的 key，第二个参数则是提供的值。返回应用实例本身。 //定义 interface App { provide(key: InjectionKey | symbol | string, value: T): this } import { createApp } from 'vue'; const app = createApp(/* ... */); app.provide('message', 'hello'); //在应用的某个组件中 export default { inject: ['message'], created() { console.log(this.message) // 'hello' } } app.component() Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-08 11:13:41 "},"webend/webpack.html":{"url":"webend/webpack.html","title":"webpack","keywords":"","body":"1>相关文章 Webpack官网 尚硅谷新版Webpack5实战教程(从入门到精通) Webpack v4.44.1 中文文档 webpack externals详解 output.filename 浅谈JSON5 core-js 懒加载 预获取和预加载 模块解析(resolve) - 三种路径(绝对路径, 相对路径, 模块路径)讲解 webpack打包进度展示以及美化教程 babel.config.js 和 .babelrc区别 webpack之externals 『Webpack系列』—— externals用法详解 webpack-chain 速查手册之 ChainedSet webpack-chain 速查手册之 ChainedMap webpack高手秘籍（一） webpack高手秘籍（二） webpack高手秘籍（三） webpack高手秘籍（四） webpack高手秘籍（五） webpack高手秘籍（六） 2>使用 *Webpack的安装和使用 npm install --save-dev webpack webpack-cli webpack-dev-server npx webpack (打包) npx webpack-dev-server (启动node本地服务器) =>npx webpack serve 3>其他知识 *3-1>npx的作用: 在当前文件夹及子文件夹中查询指定的插件, 若查询不到, 则往上一层文件夹做相同动作 *3-2>配置 webpack.ProvidePlugin - 全局声明一个包对象, 在需要使用的地方直接使用 https://webpack.docschina.org/plugins/provide-plugin/#root https://www.cnblogs.com/moqiutao/p/14379648.html //1>在webpack.config.js - plugins配置插件 //对于 ES2015 模块的 export default, 必须指定模块的 default 属性 new webpack.ProvidePlugin({ jsCookie: [\"js-cookie\", \"default\"] }); //或者 new webpack.ProvidePlugin({ jsCookie: [\"js-cookie\"] }); //或者引用本地项目的对象 new webpack.ProvidePlugin({ // 页面中使用jQuery就不需要 webpack_extend: path.resolve(__dirname, './src/normal_frame_extend.js'), // 如果你想全局注册你自己模块下的某个文件,你可以这样注册 $calc: path.resolve(path.join(__dirname, 'src/utils/common.js')), }), //2>在package.json - eslintConfig, 配置globals \"eslintConfig\": { \"globals\":{ \"jsCookie\": \"readonly\", //也可以是true, readonly表示只读 \"$calc\": \"readonly\", } }, //3>在需要使用的地方直接使用jsCookie对象 jsCookie.set(\"test-key\", \"test-val\", { expires: 1, path: \"\", secure: false }); *3-3>配置 externals - 包对象使用CDN的方式 //1>webpack.config.js配置 externalsType: \"script\", externals: { _lodash: [ \"https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.core.min.js\", \"_\" ] }, //2>在需要使用_lodash的地方导入 import _ from \"_lodash\"; console.log(_); *3-4>三种路径解析(绝对路径, 相对路径, 模块路径) //1>绝对路径 - 相对于根目录文件夹的路径 /src/index.js //2>相对路径 - 相对于当前文件的路径 ./match.js //或在webpack.config.js - resolve - alias 配置 { \"@\": path.resolve(__dirname, \"./src\") }, 就可如下使用相对路径 @/match.js //3>模块路径 - import的时候, 对于第三方包, 直接使用包名即可 import _ from 'lodash' *3-5>在js文件里引用scss模块文件的几种方式 // 1.scss文件的名称必须为 *.module.scss, 在js导入才能以模块的形式导入文件 import variables from \"calc-common/src/styles/variables.scss\"; //variables.scss :export { theme: $--color-primary; } // 2.动态为需要模块化的scss文件添加模块化标识 const styleExts = [\"scss\", \"sass\", \"less\"]; const packageCfg = require(\"./package.json\"); let styleModules = []; const regExp = new RegExp(\"/\", \"ig\"); //创建正则RegExp对象 if(packageCfg[\"calc-common\"] && packageCfg[\"calc-common\"][\"style-modules\"]){ styleModules = packageCfg[\"calc-common\"][\"style-modules\"]??[]; styleModules = styleModules.map((mo, index)=>{ return mo.replace(regExp, path.sep); })??[]; } /** * 是否将当前样式文件设置为模块 * @param {string} filePath 文件路径 * @return {boolean} */ function isStyleModule(filePath){ try{ if(!styleModules || styleModules.length{ return filePath.indexOf(mo)>=0; }); // return false; }catch(err){ console.log(\"error...\", filePath); return false; } } css: { // extract: false, //使用ICSS(行内样式)模式 // 将css打包成独立文件 extract: { filename: `css/[name].${version}.css`, // chunkFilename: `css/chunk.[id].${version}.css` chunkFilename: `css/chunk.[name].[contenthash].css` }, sourceMap: !isEnvProd, loaderOptions: { // https://www.npmjs.com/package/css-loader#modules css: { modules: { auto(resourcePath){ return isStyleModule(resourcePath); }, }, // modules: false, // 默认情况下，只有 *.module.[ext] 结尾的文件才会被视作 CSS Modules 模块。设置为 false 后你就可以去掉文件名中的 .module 并将所有的 *.(css|scss|sass|less|styl(us)?) 文件视为 CSS Modules 模块。 }, sass: { // sassOptions: { // outputStyle: 'expanded' // } }, }, }, Copyright © Dylan all right reserved，powered by GitbookLatest revision time: 2023-06-08 11:13:51 "}}